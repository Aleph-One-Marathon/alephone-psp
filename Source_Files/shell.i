# 1 "shell.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++config.h" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++config.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/os_defines.h" 1 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++config.h" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/cpu_defines.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++config.h" 2 3
# 233 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++config.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 245 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++config.h" 3
}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 152 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 3 4
typedef unsigned int size_t;
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 2 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 1 3
# 10 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/_ansi.h" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/_ansi.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/newlib.h" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/_ansi.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/config.h" 1 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/ieeefp.h" 1 3
# 5 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/config.h" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/_ansi.h" 2 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 1 3
# 9 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
extern "C" {



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/_ansi.h" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/_types.h" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/_types.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_types.h" 1 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 1 3
# 9 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
extern "C" {
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 118 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_default_types.h" 3
}
# 8 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/_types.h" 2 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/_types.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/_types.h" 2 3


typedef long _off_t;







typedef short __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 56 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 355 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 158 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (*_read) (struct _reent *, void *, char *, int);

  int (*_write) (struct _reent *, void *, const char *, int);

  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  int (*_close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  int _offset;


  struct _reent *_data;



  _flock_t _lock;

};
# 259 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 291 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 564 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (*__cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 796 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
extern struct _reent *_impure_ptr __attribute__((__section__(".sdata")));
extern struct _reent *const _global_impure_ptr __attribute__((__section__(".sdata")));

void _reclaim_reent (struct _reent *);
# 819 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/reent.h" 3
}
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/stdlib.h" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/alloca.h" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 2 3






extern "C" {

typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;
# 57 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *));




void * calloc (size_t __nmemb, size_t __size);
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *);
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size);
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);


int mkstemp (char *);
char * mktemp (char *);


void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size);
void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);
void _Exit (int __status) __attribute__ ((noreturn));
int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);
long long atoll (const char *__nptr);
long long _atoll_r (struct _reent *, const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__n, char **__end_PTR, int __base);
long long _strtoll_r (struct _reent *, const char *__n, char **__end_PTR, int __base);
unsigned long long strtoull (const char *__n, char **__end_PTR, int __base);
unsigned long long _strtoull_r (struct _reent *, const char *__n, char **__end_PTR, int __base);


void cfree (void *);
void unsetenv (const char *__string);
void _unsetenv_r (struct _reent *, const char *__string);




char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t);
void * _calloc_r (struct _reent *, size_t, size_t);
void _free_r (struct _reent *, void *);
void * _realloc_r (struct _reent *, void *, size_t);
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);

}
# 74 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 2 3
# 105 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;





  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 1 "<command-line>" 2
# 1 "shell.cpp"
# 26 "shell.cpp"
# 1 "../Source_Files/CSeries/cseries.h" 1
# 29 "../Source_Files/CSeries/cseries.h"
# 1 "../config.h" 1
# 30 "../Source_Files/CSeries/cseries.h" 2




# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_main.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_types.h"
typedef enum {
 SDL_FALSE = 0,
 SDL_TRUE = 1
} SDL_bool;







typedef unsigned char Uint8;
typedef signed char Sint8;
typedef unsigned short Uint16;
typedef signed short Sint16;
typedef unsigned int Uint32;
typedef signed int Sint32;
# 75 "/usr/local/pspdev/psp/include/SDL/SDL_types.h"
typedef unsigned long long Uint64;

typedef long long Sint64;
# 90 "/usr/local/pspdev/psp/include/SDL/SDL_types.h"
typedef int SDL_dummy_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_dummy_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_dummy_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_dummy_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_dummy_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_dummy_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_dummy_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_dummy_sint64[(sizeof(Sint64) == 8) * 2 - 1];
# 109 "/usr/local/pspdev/psp/include/SDL/SDL_types.h"
typedef enum {
 DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

typedef int SDL_dummy_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];




enum { SDL_PRESSED = 0x01, SDL_RELEASED = 0x00 };
# 35 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_getenv.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_error.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_error.h"
# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_error.h" 2


extern "C" {



extern void SDL_SetError(const char *fmt, ...);
extern char * SDL_GetError(void);
extern void SDL_ClearError(void);



typedef enum {
 SDL_ENOMEM,
 SDL_EFREAD,
 SDL_EFWRITE,
 SDL_EFSEEK,
 SDL_LASTERROR
} SDL_errorcode;
extern void SDL_Error(SDL_errorcode code);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 61 "/usr/local/pspdev/psp/include/SDL/SDL_error.h" 2
# 37 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 1
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 1 3
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stdarg.h" 1 3 4
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 2 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 1 3
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 70 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/types.h" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 2 3
# 92 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned short ino_t;
# 162 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;


typedef int pid_t;

typedef long key_t;

typedef _ssize_t ssize_t;
# 186 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 246 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/features.h" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/features.h" 3
extern "C" {
# 178 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/features.h" 3
}
# 259 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/types.h" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 2 3

extern "C" {

typedef __FILE FILE;
# 59 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
typedef _fpos_t fpos_t;





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/stdio.h" 1 3
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 2 3
# 170 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));

int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)));

int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)));

int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int remove (const char *);
int rename (const char *, const char *);






int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);


int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));


int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));


int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));

int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)));

int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)));

int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)));

int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)));

int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 310 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 335 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
int dprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));


FILE * fmemopen (void *, size_t, const char *);


FILE * open_memstream (char **, size_t *);

int vdprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));
# 352 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)));

char * _asnprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)));

int _asprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _dprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);
int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

FILE * _fmemopen_r (struct _reent *, void *, size_t, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
int _fprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
size_t _fread_r (struct _reent *, void *, size_t _size, size_t _n, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

int _fseek_r (struct _reent *, FILE *, long, int);
long _ftell_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int _mkstemp_r (struct _reent *, char *);
char * _mktemp_r (struct _reent *, char *);
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)));

int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new);

int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)));

int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)));

int _snprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)));

int _sprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)));

int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)));

char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)));

char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)));

int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));

int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));

int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int _vprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)));

int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)));

int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));

int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)));

int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)));

int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)));

int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)));


ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 494 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 509 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie));
# 521 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions);
# 669 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 3
}
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 38 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 40 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 2


extern "C" {




typedef struct SDL_RWops {




 int ( *seek)(struct SDL_RWops *context, int offset, int whence);





 int ( *read)(struct SDL_RWops *context, void *ptr, int size, int maxnum);





 int ( *write)(struct SDL_RWops *context, const void *ptr, int size, int num);


 int ( *close)(struct SDL_RWops *context);

 Uint32 type;
 union {
     struct {
  int autoclose;
   FILE *fp;
     } stdio;
     struct {
  Uint8 *base;
   Uint8 *here;
  Uint8 *stop;
     } mem;
     struct {
  void *data1;
     } unknown;
 } hidden;

} SDL_RWops;




extern SDL_RWops * SDL_RWFromFile(const char *file, const char *mode);

extern SDL_RWops * SDL_RWFromFP(FILE *fp, int autoclose);

extern SDL_RWops * SDL_RWFromMem(void *mem, int size);
extern SDL_RWops * SDL_RWFromConstMem(const void *mem, int size);

extern SDL_RWops * SDL_AllocRW(void);
extern void SDL_FreeRW(SDL_RWops *area);
# 110 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h"
}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 113 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 2
# 38 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_main.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h" 2


extern "C" {
# 51 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h"
extern Uint32 SDL_GetTicks(void);


extern void SDL_Delay(Uint32 ms);


typedef Uint32 ( *SDL_TimerCallback)(Uint32 interval);
# 87 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h"
extern int SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback);
# 99 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h"
typedef Uint32 ( *SDL_NewTimerCallback)(Uint32 interval, void *param);


typedef struct _SDL_TimerID *SDL_TimerID;




extern SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param);




extern SDL_bool SDL_RemoveTimer(SDL_TimerID t);



}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 119 "/usr/local/pspdev/psp/include/SDL/SDL_timer.h" 2
# 39 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 1
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_main.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_error.h" 1
# 38 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 1
# 39 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_byteorder.h" 1
# 40 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 42 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2


extern "C" {



typedef struct SDL_AudioSpec {
 int freq;
 Uint16 format;
 Uint8 channels;
 Uint8 silence;
 Uint16 samples;
 Uint16 padding;
 Uint32 size;






 void ( *callback)(void *userdata, Uint8 *stream, int len);
 void *userdata;
} SDL_AudioSpec;
# 87 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
typedef struct SDL_AudioCVT {
 int needed;
 Uint16 src_format;
 Uint16 dst_format;
 double rate_incr;
 Uint8 *buf;
 int len;
 int len_cvt;
 int len_mult;
 double len_ratio;
 void ( *filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
 int filter_index;
} SDL_AudioCVT;
# 108 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern int SDL_AudioInit(const char *driver_name);
extern void SDL_AudioQuit(void);





extern char * SDL_AudioDriverName(char *namebuf, int maxlen);
# 158 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern int SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);




typedef enum {
 SDL_AUDIO_STOPPED = 0,
 SDL_AUDIO_PLAYING,
 SDL_AUDIO_PAUSED
} SDL_audiostatus;
extern SDL_audiostatus SDL_GetAudioStatus(void);
# 177 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern void SDL_PauseAudio(int pause_on);
# 196 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
# 205 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern void SDL_FreeWAV(Uint8 *audio_buf);
# 214 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
  Uint16 src_format, Uint8 src_channels, int src_rate,
  Uint16 dst_format, Uint8 dst_channels, int dst_rate);
# 226 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern int SDL_ConvertAudio(SDL_AudioCVT *cvt);
# 236 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h"
extern void SDL_MixAudio(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);







extern void SDL_LockAudio(void);
extern void SDL_UnlockAudio(void);




extern void SDL_CloseAudio(void);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 258 "/usr/local/pspdev/psp/include/SDL/SDL_audio.h" 2
# 40 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h" 2


extern "C" {
# 54 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h"
typedef enum {
 CD_TRAYEMPTY,
 CD_STOPPED,
 CD_PLAYING,
 CD_PAUSED,
 CD_ERROR = -1
} CDstatus;




typedef struct SDL_CDtrack {
 Uint8 id;
 Uint8 type;
 Uint16 unused;
 Uint32 length;
 Uint32 offset;
} SDL_CDtrack;


typedef struct SDL_CD {
 int id;
 CDstatus status;


 int numtracks;
 int cur_track;
 int cur_frame;
 SDL_CDtrack track[99 +1];
} SDL_CD;
# 102 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h"
extern int SDL_CDNumDrives(void);







extern const char * SDL_CDName(int drive);







extern SDL_CD * SDL_CDOpen(int drive);





extern CDstatus SDL_CDStatus(SDL_CD *cdrom);
# 145 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h"
extern int SDL_CDPlayTracks(SDL_CD *cdrom,
  int start_track, int start_frame, int ntracks, int nframes);




extern int SDL_CDPlay(SDL_CD *cdrom, int start, int length);


extern int SDL_CDPause(SDL_CD *cdrom);


extern int SDL_CDResume(SDL_CD *cdrom);


extern int SDL_CDStop(SDL_CD *cdrom);


extern int SDL_CDEject(SDL_CD *cdrom);


extern void SDL_CDClose(SDL_CD *cdrom);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 174 "/usr/local/pspdev/psp/include/SDL/SDL_cdrom.h" 2
# 41 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h" 2


extern "C" {
# 47 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h"
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;






extern int SDL_NumJoysticks(void);






extern const char * SDL_JoystickName(int device_index);
# 71 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h"
extern SDL_Joystick * SDL_JoystickOpen(int device_index);




extern int SDL_JoystickOpened(int device_index);




extern int SDL_JoystickIndex(SDL_Joystick *joystick);




extern int SDL_JoystickNumAxes(SDL_Joystick *joystick);






extern int SDL_JoystickNumBalls(SDL_Joystick *joystick);




extern int SDL_JoystickNumHats(SDL_Joystick *joystick);




extern int SDL_JoystickNumButtons(SDL_Joystick *joystick);






extern void SDL_JoystickUpdate(void);
# 119 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h"
extern int SDL_JoystickEventState(int state);






extern Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
# 144 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h"
extern Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);






extern int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);





extern Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button);




extern void SDL_JoystickClose(SDL_Joystick *joystick);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 170 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h" 2
# 42 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_events.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_active.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_active.h"
# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_active.h" 2


extern "C" {
# 51 "/usr/local/pspdev/psp/include/SDL/SDL_active.h"
extern Uint8 SDL_GetAppState(void);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 59 "/usr/local/pspdev/psp/include/SDL/SDL_active.h" 2
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_keysym.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_keysym.h"
typedef enum {

 SDLK_UNKNOWN = 0,
 SDLK_FIRST = 0,
 SDLK_BACKSPACE = 8,
 SDLK_TAB = 9,
 SDLK_CLEAR = 12,
 SDLK_RETURN = 13,
 SDLK_PAUSE = 19,
 SDLK_ESCAPE = 27,
 SDLK_SPACE = 32,
 SDLK_EXCLAIM = 33,
 SDLK_QUOTEDBL = 34,
 SDLK_HASH = 35,
 SDLK_DOLLAR = 36,
 SDLK_AMPERSAND = 38,
 SDLK_QUOTE = 39,
 SDLK_LEFTPAREN = 40,
 SDLK_RIGHTPAREN = 41,
 SDLK_ASTERISK = 42,
 SDLK_PLUS = 43,
 SDLK_COMMA = 44,
 SDLK_MINUS = 45,
 SDLK_PERIOD = 46,
 SDLK_SLASH = 47,
 SDLK_0 = 48,
 SDLK_1 = 49,
 SDLK_2 = 50,
 SDLK_3 = 51,
 SDLK_4 = 52,
 SDLK_5 = 53,
 SDLK_6 = 54,
 SDLK_7 = 55,
 SDLK_8 = 56,
 SDLK_9 = 57,
 SDLK_COLON = 58,
 SDLK_SEMICOLON = 59,
 SDLK_LESS = 60,
 SDLK_EQUALS = 61,
 SDLK_GREATER = 62,
 SDLK_QUESTION = 63,
 SDLK_AT = 64,



 SDLK_LEFTBRACKET = 91,
 SDLK_BACKSLASH = 92,
 SDLK_RIGHTBRACKET = 93,
 SDLK_CARET = 94,
 SDLK_UNDERSCORE = 95,
 SDLK_BACKQUOTE = 96,
 SDLK_a = 97,
 SDLK_b = 98,
 SDLK_c = 99,
 SDLK_d = 100,
 SDLK_e = 101,
 SDLK_f = 102,
 SDLK_g = 103,
 SDLK_h = 104,
 SDLK_i = 105,
 SDLK_j = 106,
 SDLK_k = 107,
 SDLK_l = 108,
 SDLK_m = 109,
 SDLK_n = 110,
 SDLK_o = 111,
 SDLK_p = 112,
 SDLK_q = 113,
 SDLK_r = 114,
 SDLK_s = 115,
 SDLK_t = 116,
 SDLK_u = 117,
 SDLK_v = 118,
 SDLK_w = 119,
 SDLK_x = 120,
 SDLK_y = 121,
 SDLK_z = 122,
 SDLK_DELETE = 127,



 SDLK_WORLD_0 = 160,
 SDLK_WORLD_1 = 161,
 SDLK_WORLD_2 = 162,
 SDLK_WORLD_3 = 163,
 SDLK_WORLD_4 = 164,
 SDLK_WORLD_5 = 165,
 SDLK_WORLD_6 = 166,
 SDLK_WORLD_7 = 167,
 SDLK_WORLD_8 = 168,
 SDLK_WORLD_9 = 169,
 SDLK_WORLD_10 = 170,
 SDLK_WORLD_11 = 171,
 SDLK_WORLD_12 = 172,
 SDLK_WORLD_13 = 173,
 SDLK_WORLD_14 = 174,
 SDLK_WORLD_15 = 175,
 SDLK_WORLD_16 = 176,
 SDLK_WORLD_17 = 177,
 SDLK_WORLD_18 = 178,
 SDLK_WORLD_19 = 179,
 SDLK_WORLD_20 = 180,
 SDLK_WORLD_21 = 181,
 SDLK_WORLD_22 = 182,
 SDLK_WORLD_23 = 183,
 SDLK_WORLD_24 = 184,
 SDLK_WORLD_25 = 185,
 SDLK_WORLD_26 = 186,
 SDLK_WORLD_27 = 187,
 SDLK_WORLD_28 = 188,
 SDLK_WORLD_29 = 189,
 SDLK_WORLD_30 = 190,
 SDLK_WORLD_31 = 191,
 SDLK_WORLD_32 = 192,
 SDLK_WORLD_33 = 193,
 SDLK_WORLD_34 = 194,
 SDLK_WORLD_35 = 195,
 SDLK_WORLD_36 = 196,
 SDLK_WORLD_37 = 197,
 SDLK_WORLD_38 = 198,
 SDLK_WORLD_39 = 199,
 SDLK_WORLD_40 = 200,
 SDLK_WORLD_41 = 201,
 SDLK_WORLD_42 = 202,
 SDLK_WORLD_43 = 203,
 SDLK_WORLD_44 = 204,
 SDLK_WORLD_45 = 205,
 SDLK_WORLD_46 = 206,
 SDLK_WORLD_47 = 207,
 SDLK_WORLD_48 = 208,
 SDLK_WORLD_49 = 209,
 SDLK_WORLD_50 = 210,
 SDLK_WORLD_51 = 211,
 SDLK_WORLD_52 = 212,
 SDLK_WORLD_53 = 213,
 SDLK_WORLD_54 = 214,
 SDLK_WORLD_55 = 215,
 SDLK_WORLD_56 = 216,
 SDLK_WORLD_57 = 217,
 SDLK_WORLD_58 = 218,
 SDLK_WORLD_59 = 219,
 SDLK_WORLD_60 = 220,
 SDLK_WORLD_61 = 221,
 SDLK_WORLD_62 = 222,
 SDLK_WORLD_63 = 223,
 SDLK_WORLD_64 = 224,
 SDLK_WORLD_65 = 225,
 SDLK_WORLD_66 = 226,
 SDLK_WORLD_67 = 227,
 SDLK_WORLD_68 = 228,
 SDLK_WORLD_69 = 229,
 SDLK_WORLD_70 = 230,
 SDLK_WORLD_71 = 231,
 SDLK_WORLD_72 = 232,
 SDLK_WORLD_73 = 233,
 SDLK_WORLD_74 = 234,
 SDLK_WORLD_75 = 235,
 SDLK_WORLD_76 = 236,
 SDLK_WORLD_77 = 237,
 SDLK_WORLD_78 = 238,
 SDLK_WORLD_79 = 239,
 SDLK_WORLD_80 = 240,
 SDLK_WORLD_81 = 241,
 SDLK_WORLD_82 = 242,
 SDLK_WORLD_83 = 243,
 SDLK_WORLD_84 = 244,
 SDLK_WORLD_85 = 245,
 SDLK_WORLD_86 = 246,
 SDLK_WORLD_87 = 247,
 SDLK_WORLD_88 = 248,
 SDLK_WORLD_89 = 249,
 SDLK_WORLD_90 = 250,
 SDLK_WORLD_91 = 251,
 SDLK_WORLD_92 = 252,
 SDLK_WORLD_93 = 253,
 SDLK_WORLD_94 = 254,
 SDLK_WORLD_95 = 255,


 SDLK_KP0 = 256,
 SDLK_KP1 = 257,
 SDLK_KP2 = 258,
 SDLK_KP3 = 259,
 SDLK_KP4 = 260,
 SDLK_KP5 = 261,
 SDLK_KP6 = 262,
 SDLK_KP7 = 263,
 SDLK_KP8 = 264,
 SDLK_KP9 = 265,
 SDLK_KP_PERIOD = 266,
 SDLK_KP_DIVIDE = 267,
 SDLK_KP_MULTIPLY = 268,
 SDLK_KP_MINUS = 269,
 SDLK_KP_PLUS = 270,
 SDLK_KP_ENTER = 271,
 SDLK_KP_EQUALS = 272,


 SDLK_UP = 273,
 SDLK_DOWN = 274,
 SDLK_RIGHT = 275,
 SDLK_LEFT = 276,
 SDLK_INSERT = 277,
 SDLK_HOME = 278,
 SDLK_END = 279,
 SDLK_PAGEUP = 280,
 SDLK_PAGEDOWN = 281,


 SDLK_F1 = 282,
 SDLK_F2 = 283,
 SDLK_F3 = 284,
 SDLK_F4 = 285,
 SDLK_F5 = 286,
 SDLK_F6 = 287,
 SDLK_F7 = 288,
 SDLK_F8 = 289,
 SDLK_F9 = 290,
 SDLK_F10 = 291,
 SDLK_F11 = 292,
 SDLK_F12 = 293,
 SDLK_F13 = 294,
 SDLK_F14 = 295,
 SDLK_F15 = 296,


 SDLK_NUMLOCK = 300,
 SDLK_CAPSLOCK = 301,
 SDLK_SCROLLOCK = 302,
 SDLK_RSHIFT = 303,
 SDLK_LSHIFT = 304,
 SDLK_RCTRL = 305,
 SDLK_LCTRL = 306,
 SDLK_RALT = 307,
 SDLK_LALT = 308,
 SDLK_RMETA = 309,
 SDLK_LMETA = 310,
 SDLK_LSUPER = 311,
 SDLK_RSUPER = 312,
 SDLK_MODE = 313,
 SDLK_COMPOSE = 314,


 SDLK_HELP = 315,
 SDLK_PRINT = 316,
 SDLK_SYSREQ = 317,
 SDLK_BREAK = 318,
 SDLK_MENU = 319,
 SDLK_POWER = 320,
 SDLK_EURO = 321,
 SDLK_UNDO = 322,



 SDLK_LAST
} SDLKey;


typedef enum {
 KMOD_NONE = 0x0000,
 KMOD_LSHIFT= 0x0001,
 KMOD_RSHIFT= 0x0002,
 KMOD_LCTRL = 0x0040,
 KMOD_RCTRL = 0x0080,
 KMOD_LALT = 0x0100,
 KMOD_RALT = 0x0200,
 KMOD_LMETA = 0x0400,
 KMOD_RMETA = 0x0800,
 KMOD_NUM = 0x1000,
 KMOD_CAPS = 0x2000,
 KMOD_MODE = 0x4000,
 KMOD_RESERVED = 0x8000
} SDLMod;
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h" 2


extern "C" {
# 58 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h"
typedef struct SDL_keysym {
 Uint8 scancode;
 SDLKey sym;
 SDLMod mod;
 Uint16 unicode;
} SDL_keysym;
# 77 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h"
extern int SDL_EnableUNICODE(int enable);
# 90 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h"
extern int SDL_EnableKeyRepeat(int delay, int interval);
# 99 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h"
extern Uint8 * SDL_GetKeyState(int *numkeys);




extern SDLMod SDL_GetModState(void);





extern void SDL_SetModState(SDLMod modstate);




extern char * SDL_GetKeyName(SDLKey key);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 123 "/usr/local/pspdev/psp/include/SDL/SDL_keyboard.h" 2
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 1
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_main.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 38 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 40 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h" 2


extern "C" {
# 59 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h"
struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;


extern SDL_mutex * SDL_CreateMutex(void);



extern int SDL_mutexP(SDL_mutex *mutex);






extern int SDL_mutexV(SDL_mutex *mutex);


extern void SDL_DestroyMutex(SDL_mutex *mutex);







struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;


extern SDL_sem * SDL_CreateSemaphore(Uint32 initial_value);


extern void SDL_DestroySemaphore(SDL_sem *sem);





extern int SDL_SemWait(SDL_sem *sem);




extern int SDL_SemTryWait(SDL_sem *sem);







extern int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms);




extern int SDL_SemPost(SDL_sem *sem);


extern Uint32 SDL_SemValue(SDL_sem *sem);







struct SDL_cond;
typedef struct SDL_cond SDL_cond;


extern SDL_cond * SDL_CreateCond(void);


extern void SDL_DestroyCond(SDL_cond *cond);




extern int SDL_CondSignal(SDL_cond *cond);




extern int SDL_CondBroadcast(SDL_cond *cond);





extern int SDL_CondWait(SDL_cond *cond, SDL_mutex *mut);







extern int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);



}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 165 "/usr/local/pspdev/psp/include/SDL/SDL_mutex.h" 2
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 1
# 38 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 40 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 2


extern "C" {







typedef struct SDL_Rect {
 Sint16 x, y;
 Uint16 w, h;
} SDL_Rect;

typedef struct SDL_Color {
 Uint8 r;
 Uint8 g;
 Uint8 b;
 Uint8 unused;
} SDL_Color;


typedef struct SDL_Palette {
 int ncolors;
 SDL_Color *colors;
} SDL_Palette;


typedef struct SDL_PixelFormat {
 SDL_Palette *palette;
 Uint8 BitsPerPixel;
 Uint8 BytesPerPixel;
 Uint8 Rloss;
 Uint8 Gloss;
 Uint8 Bloss;
 Uint8 Aloss;
 Uint8 Rshift;
 Uint8 Gshift;
 Uint8 Bshift;
 Uint8 Ashift;
 Uint32 Rmask;
 Uint32 Gmask;
 Uint32 Bmask;
 Uint32 Amask;


 Uint32 colorkey;

 Uint8 alpha;
} SDL_PixelFormat;




typedef struct SDL_Surface {
 Uint32 flags;
 SDL_PixelFormat *format;
 int w, h;
 Uint16 pitch;
 void *pixels;
 int offset;


 struct private_hwdata *hwdata;


 SDL_Rect clip_rect;
 Uint32 unused1;


 Uint32 locked;


 struct SDL_BlitMap *map;


 unsigned int format_version;


 int refcount;
} SDL_Surface;
# 151 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
typedef int (*SDL_blit)(struct SDL_Surface *src, SDL_Rect *srcrect,
   struct SDL_Surface *dst, SDL_Rect *dstrect);



typedef struct SDL_VideoInfo {
 Uint32 hw_available :1;
 Uint32 wm_available :1;
 Uint32 UnusedBits1 :6;
 Uint32 UnusedBits2 :1;
 Uint32 blit_hw :1;
 Uint32 blit_hw_CC :1;
 Uint32 blit_hw_A :1;
 Uint32 blit_sw :1;
 Uint32 blit_sw_CC :1;
 Uint32 blit_sw_A :1;
 Uint32 blit_fill :1;
 Uint32 UnusedBits3 :16;
 Uint32 video_mem;
 SDL_PixelFormat *vfmt;
} SDL_VideoInfo;
# 188 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
typedef struct SDL_Overlay {
 Uint32 format;
 int w, h;
 int planes;
 Uint16 *pitches;
 Uint8 **pixels;


 struct private_yuvhwfuncs *hwfuncs;
 struct private_yuvhwdata *hwdata;


 Uint32 hw_overlay :1;
 Uint32 UnusedBits :31;
} SDL_Overlay;



typedef enum {
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES
} SDL_GLattr;
# 243 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_VideoInit(const char *driver_name, Uint32 flags);
extern void SDL_VideoQuit(void);





extern char * SDL_VideoDriverName(char *namebuf, int maxlen);







extern SDL_Surface * SDL_GetVideoSurface(void);







extern const SDL_VideoInfo * SDL_GetVideoInfo(void);
# 279 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);
# 290 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Rect ** SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);
# 350 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Surface * SDL_SetVideoMode
   (int width, int height, int bpp, Uint32 flags);







extern void SDL_UpdateRects
  (SDL_Surface *screen, int numrects, SDL_Rect *rects);
extern void SDL_UpdateRect
  (SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h);
# 374 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_Flip(SDL_Surface *screen);
# 384 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SetGamma(float red, float green, float blue);
# 398 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue);
# 409 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue);
# 426 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SetColors(SDL_Surface *surface,
   SDL_Color *colors, int firstcolor, int ncolors);
# 445 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SetPalette(SDL_Surface *surface, int flags,
       SDL_Color *colors, int firstcolor,
       int ncolors);




extern Uint32 SDL_MapRGB
   (SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b);




extern Uint32 SDL_MapRGBA(SDL_PixelFormat *format,
       Uint8 r, Uint8 g, Uint8 b, Uint8 a);




extern void SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt,
    Uint8 *r, Uint8 *g, Uint8 *b);




extern void SDL_GetRGBA(Uint32 pixel, SDL_PixelFormat *fmt,
     Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
# 508 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Surface * SDL_CreateRGBSurface
   (Uint32 flags, int width, int height, int depth,
   Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern SDL_Surface * SDL_CreateRGBSurfaceFrom(void *pixels,
   int width, int height, int depth, int pitch,
   Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern void SDL_FreeSurface(SDL_Surface *surface);
# 534 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_LockSurface(SDL_Surface *surface);
extern void SDL_UnlockSurface(SDL_Surface *surface);







extern SDL_Surface * SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);
# 553 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SaveBMP_RW
  (SDL_Surface *surface, SDL_RWops *dst, int freedst);
# 569 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SetColorKey
   (SDL_Surface *surface, Uint32 flag, Uint32 key);
# 587 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
# 601 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_bool SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect);






extern void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect);
# 622 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Surface * SDL_ConvertSurface
   (SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags);
# 699 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_UpperBlit
   (SDL_Surface *src, SDL_Rect *srcrect,
    SDL_Surface *dst, SDL_Rect *dstrect);



extern int SDL_LowerBlit
   (SDL_Surface *src, SDL_Rect *srcrect,
    SDL_Surface *dst, SDL_Rect *dstrect);
# 718 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_FillRect
  (SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
# 732 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Surface * SDL_DisplayFormat(SDL_Surface *surface);
# 746 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Surface * SDL_DisplayFormatAlpha(SDL_Surface *surface);
# 758 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern SDL_Overlay * SDL_CreateYUVOverlay(int width, int height,
    Uint32 format, SDL_Surface *display);


extern int SDL_LockYUVOverlay(SDL_Overlay *overlay);
extern void SDL_UnlockYUVOverlay(SDL_Overlay *overlay);







extern int SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect);


extern void SDL_FreeYUVOverlay(SDL_Overlay *overlay);
# 791 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_GL_LoadLibrary(const char *path);




extern void * SDL_GL_GetProcAddress(const char* proc);




extern int SDL_GL_SetAttribute(SDL_GLattr attr, int value);
# 812 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_GL_GetAttribute(SDL_GLattr attr, int* value);




extern void SDL_GL_SwapBuffers(void);





extern void SDL_GL_UpdateRects(int numrects, SDL_Rect* rects);
extern void SDL_GL_Lock(void);
extern void SDL_GL_Unlock(void);
# 834 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern void SDL_WM_SetCaption(const char *title, const char *icon);
extern void SDL_WM_GetCaption(char **title, char **icon);







extern void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);






extern int SDL_WM_IconifyWindow(void);
# 867 "/usr/local/pspdev/psp/include/SDL/SDL_video.h"
extern int SDL_WM_ToggleFullScreen(SDL_Surface *surface);





typedef enum {
 SDL_GRAB_QUERY = -1,
 SDL_GRAB_OFF = 0,
 SDL_GRAB_ON = 1,
 SDL_GRAB_FULLSCREEN
} SDL_GrabMode;





extern SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode);


extern int SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                                    SDL_Surface *dst, SDL_Rect *dstrect);



}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 895 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 2
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h" 2


extern "C" {


typedef struct WMcursor WMcursor;
typedef struct SDL_Cursor {
 SDL_Rect area;
 Sint16 hot_x, hot_y;
 Uint8 *data;
 Uint8 *mask;
 Uint8 *save[2];
 WMcursor *wm_cursor;
} SDL_Cursor;
# 59 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h"
extern Uint8 SDL_GetMouseState(int *x, int *y);







extern Uint8 SDL_GetRelativeMouseState(int *x, int *y);




extern void SDL_WarpMouse(Uint16 x, Uint16 y);
# 87 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h"
extern SDL_Cursor * SDL_CreateCursor
  (Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);






extern void SDL_SetCursor(SDL_Cursor *cursor);




extern SDL_Cursor * SDL_GetCursor(void);




extern void SDL_FreeCursor(SDL_Cursor *cursor);
# 114 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h"
extern int SDL_ShowCursor(int toggle);
# 136 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h"
}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 139 "/usr/local/pspdev/psp/include/SDL/SDL_mouse.h" 2
# 37 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_joystick.h" 1
# 38 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_quit.h" 1
# 39 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 41 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2


extern "C" {



enum { SDL_NOEVENT = 0,
       SDL_ACTIVEEVENT,
       SDL_KEYDOWN,
       SDL_KEYUP,
       SDL_MOUSEMOTION,
       SDL_MOUSEBUTTONDOWN,
       SDL_MOUSEBUTTONUP,
       SDL_JOYAXISMOTION,
       SDL_JOYBALLMOTION,
       SDL_JOYHATMOTION,
       SDL_JOYBUTTONDOWN,
       SDL_JOYBUTTONUP,
       SDL_QUIT,
       SDL_SYSWMEVENT,
       SDL_EVENT_RESERVEDA,
       SDL_EVENT_RESERVEDB,
       SDL_VIDEORESIZE,
       SDL_VIDEOEXPOSE,
       SDL_EVENT_RESERVED2,
       SDL_EVENT_RESERVED3,
       SDL_EVENT_RESERVED4,
       SDL_EVENT_RESERVED5,
       SDL_EVENT_RESERVED6,
       SDL_EVENT_RESERVED7,

       SDL_USEREVENT = 24,



       SDL_NUMEVENTS = 32
};



enum {
 SDL_ACTIVEEVENTMASK = (1<<(SDL_ACTIVEEVENT)),
 SDL_KEYDOWNMASK = (1<<(SDL_KEYDOWN)),
 SDL_KEYUPMASK = (1<<(SDL_KEYUP)),
 SDL_MOUSEMOTIONMASK = (1<<(SDL_MOUSEMOTION)),
 SDL_MOUSEBUTTONDOWNMASK = (1<<(SDL_MOUSEBUTTONDOWN)),
 SDL_MOUSEBUTTONUPMASK = (1<<(SDL_MOUSEBUTTONUP)),
 SDL_MOUSEEVENTMASK = (1<<(SDL_MOUSEMOTION))|
                           (1<<(SDL_MOUSEBUTTONDOWN))|
                           (1<<(SDL_MOUSEBUTTONUP)),
 SDL_JOYAXISMOTIONMASK = (1<<(SDL_JOYAXISMOTION)),
 SDL_JOYBALLMOTIONMASK = (1<<(SDL_JOYBALLMOTION)),
 SDL_JOYHATMOTIONMASK = (1<<(SDL_JOYHATMOTION)),
 SDL_JOYBUTTONDOWNMASK = (1<<(SDL_JOYBUTTONDOWN)),
 SDL_JOYBUTTONUPMASK = (1<<(SDL_JOYBUTTONUP)),
 SDL_JOYEVENTMASK = (1<<(SDL_JOYAXISMOTION))|
                           (1<<(SDL_JOYBALLMOTION))|
                           (1<<(SDL_JOYHATMOTION))|
                           (1<<(SDL_JOYBUTTONDOWN))|
                           (1<<(SDL_JOYBUTTONUP)),
 SDL_VIDEORESIZEMASK = (1<<(SDL_VIDEORESIZE)),
 SDL_VIDEOEXPOSEMASK = (1<<(SDL_VIDEOEXPOSE)),
 SDL_QUITMASK = (1<<(SDL_QUIT)),
 SDL_SYSWMEVENTMASK = (1<<(SDL_SYSWMEVENT))
};



typedef struct SDL_ActiveEvent {
 Uint8 type;
 Uint8 gain;
 Uint8 state;
} SDL_ActiveEvent;


typedef struct SDL_KeyboardEvent {
 Uint8 type;
 Uint8 which;
 Uint8 state;
 SDL_keysym keysym;
} SDL_KeyboardEvent;


typedef struct SDL_MouseMotionEvent {
 Uint8 type;
 Uint8 which;
 Uint8 state;
 Uint16 x, y;
 Sint16 xrel;
 Sint16 yrel;
} SDL_MouseMotionEvent;


typedef struct SDL_MouseButtonEvent {
 Uint8 type;
 Uint8 which;
 Uint8 button;
 Uint8 state;
 Uint16 x, y;
} SDL_MouseButtonEvent;


typedef struct SDL_JoyAxisEvent {
 Uint8 type;
 Uint8 which;
 Uint8 axis;
 Sint16 value;
} SDL_JoyAxisEvent;


typedef struct SDL_JoyBallEvent {
 Uint8 type;
 Uint8 which;
 Uint8 ball;
 Sint16 xrel;
 Sint16 yrel;
} SDL_JoyBallEvent;


typedef struct SDL_JoyHatEvent {
 Uint8 type;
 Uint8 which;
 Uint8 hat;
 Uint8 value;





} SDL_JoyHatEvent;


typedef struct SDL_JoyButtonEvent {
 Uint8 type;
 Uint8 which;
 Uint8 button;
 Uint8 state;
} SDL_JoyButtonEvent;





typedef struct SDL_ResizeEvent {
 Uint8 type;
 int w;
 int h;
} SDL_ResizeEvent;


typedef struct SDL_ExposeEvent {
 Uint8 type;
} SDL_ExposeEvent;


typedef struct SDL_QuitEvent {
 Uint8 type;
} SDL_QuitEvent;


typedef struct SDL_UserEvent {
 Uint8 type;
 int code;
 void *data1;
 void *data2;
} SDL_UserEvent;


struct SDL_SysWMmsg;
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
typedef struct SDL_SysWMEvent {
 Uint8 type;
 SDL_SysWMmsg *msg;
} SDL_SysWMEvent;


typedef union {
 Uint8 type;
 SDL_ActiveEvent active;
 SDL_KeyboardEvent key;
 SDL_MouseMotionEvent motion;
 SDL_MouseButtonEvent button;
 SDL_JoyAxisEvent jaxis;
 SDL_JoyBallEvent jball;
 SDL_JoyHatEvent jhat;
 SDL_JoyButtonEvent jbutton;
 SDL_ResizeEvent resize;
 SDL_ExposeEvent expose;
 SDL_QuitEvent quit;
 SDL_UserEvent user;
 SDL_SysWMEvent syswm;
} SDL_Event;
# 241 "/usr/local/pspdev/psp/include/SDL/SDL_events.h"
extern void SDL_PumpEvents(void);
# 255 "/usr/local/pspdev/psp/include/SDL/SDL_events.h"
typedef enum {
 SDL_ADDEVENT,
 SDL_PEEKEVENT,
 SDL_GETEVENT
} SDL_eventaction;

extern int SDL_PeepEvents(SDL_Event *events, int numevents,
    SDL_eventaction action, Uint32 mask);





extern int SDL_PollEvent(SDL_Event *event);





extern int SDL_WaitEvent(SDL_Event *event);





extern int SDL_PushEvent(SDL_Event *event);







typedef int ( *SDL_EventFilter)(const SDL_Event *event);
# 305 "/usr/local/pspdev/psp/include/SDL/SDL_events.h"
extern void SDL_SetEventFilter(SDL_EventFilter filter);





extern SDL_EventFilter SDL_GetEventFilter(void);
# 325 "/usr/local/pspdev/psp/include/SDL/SDL_events.h"
extern Uint8 SDL_EventState(Uint8 type, int state);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 333 "/usr/local/pspdev/psp/include/SDL/SDL_events.h" 2
# 43 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_video.h" 1
# 44 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_byteorder.h" 1
# 45 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_version.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_version.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_version.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_version.h" 2


extern "C" {
# 47 "/usr/local/pspdev/psp/include/SDL/SDL_version.h"
typedef struct SDL_version {
 Uint8 major;
 Uint8 minor;
 Uint8 patch;
} SDL_version;
# 82 "/usr/local/pspdev/psp/include/SDL/SDL_version.h"
extern const SDL_version * SDL_Linked_Version(void);



}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 89 "/usr/local/pspdev/psp/include/SDL/SDL_version.h" 2
# 46 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 48 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2


extern "C" {
# 72 "/usr/local/pspdev/psp/include/SDL/SDL.h"
extern int SDL_Init(Uint32 flags);


extern int SDL_InitSubSystem(Uint32 flags);


extern void SDL_QuitSubSystem(Uint32 flags);





extern Uint32 SDL_WasInit(Uint32 flags);




extern void SDL_Quit(void);



}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 96 "/usr/local/pspdev/psp/include/SDL/SDL.h" 2
# 35 "../Source_Files/CSeries/cseries.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_byteorder.h" 1
# 36 "../Source_Files/CSeries/cseries.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/machine/time.h" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 2 3



extern "C" {

struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

char *asctime_r (const struct tm *, char *);
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *, struct tm *);
struct tm *localtime_r (const time_t *, struct tm *);

}


extern "C" {



char *strptime (const char *, const char *, struct tm *);
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 118 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 3
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 129 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 3
}
# 180 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 3
extern "C" {

int nanosleep (const struct timespec *rqtp, struct timespec *rmtp);

}





extern "C" {
# 258 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 3
}
# 37 "../Source_Files/CSeries/cseries.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 3
       
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stringfwd.h" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stringfwd.h" 3
       
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;







}
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 1 3
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/functexcept.h" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/functexcept.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/exception_defines.h" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

}
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 1 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 3
       
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 3
# 74 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 183 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 356 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 406 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/cpp_type_traits.h" 3
}
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/type_traits.h" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/type_traits.h" 3
       
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 70 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/numeric_traits.h" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/numeric_traits.h" 3
       
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 103 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 53) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 15);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 308);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_move.h" 1 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_move.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/concept_check.h" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/concept_check.h" 3
       
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/concept_check.h" 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_move.h" 2 3
# 70 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }

}
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 103 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 3
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
# 146 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 216 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
# 262 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_pair.h" 3
}
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_types.h" 1 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_types.h" 3
       
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_types.h" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 84 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 108 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_funcs.h" 1 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_funcs.h" 3
       
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_funcs.h" 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 113 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 74 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 1 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 94 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 281 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
# 385 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 411 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 428 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 454 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 469 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 494 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 511 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 537 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 556 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 598 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 617 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 643 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 662 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 760 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 75 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/debug/debug.h" 1 3
# 52 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 77 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 119 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 159 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 186 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 208 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 250 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator,
    bool _IsNormal = __is_normal_iterator<_Iterator>::__value>
    struct __niter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __niter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _Iterator,
    bool _IsMove = __is_move_iterator<_Iterator>::__value>
    struct __miter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __miter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 332 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 370 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   __builtin_memmove(__result, __first,
       sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>
   (std::__niter_base<_II>::__b(__first),
    std::__niter_base<_II>::__b(__last),
    std::__niter_base<_OI>::__b(__result)));
    }
# 454 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base<_II>::__b(__first),
        std::__miter_base<_II>::__b(__last), __result));
    }
# 506 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 534 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 564 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base<_BI1>::__b(__first),
     std::__niter_base<_BI1>::__b(__last),
     std::__niter_base<_BI2>::__b(__result)));
    }
# 622 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base<_BI1>::__b(__first),
        std::__miter_base<_BI1>::__b(__last), __result));
    }
# 679 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 722 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base<_ForwardIterator>::__b(__first),
      std::__niter_base<_ForwardIterator>::__b(__last), __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 776 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base<_OI>::__b(__first),
     __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 942 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base<_II1>::__b(__first1),
         std::__niter_base<_II1>::__b(__last1),
         std::__niter_base<_II2>::__b(__first2));
    }
# 973 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1003 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux
 (std::__niter_base<_II1>::__b(__first1),
  std::__niter_base<_II1>::__b(__last1),
  std::__niter_base<_II2>::__b(__first2),
  std::__niter_base<_II2>::__b(__last2));
    }
# 1037 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1076 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1112 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/wchar.h" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/wchar.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/wchar.h" 2 3
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/wchar.h" 3
extern "C" {



typedef _mbstate_t mbstate_t;


wint_t btowc (int);
int wctob (wint_t);
size_t mbrlen (const char * , size_t, mbstate_t *);
size_t mbrtowc (wchar_t * , const char * , size_t, mbstate_t *);
size_t _mbrtowc_r (struct _reent *, wchar_t * , const char * , size_t, mbstate_t *);

int mbsinit (const mbstate_t *);
size_t mbsrtowcs (wchar_t * , const char ** , size_t, mbstate_t *);
size_t wcrtomb (char * , wchar_t, mbstate_t *);
size_t _wcrtomb_r (struct _reent *, char * , wchar_t, mbstate_t *);
size_t wcsrtombs (char * , const wchar_t ** , size_t, mbstate_t *);
size_t _wcsrtombs_r (struct _reent *, char * , const wchar_t ** , size_t, mbstate_t *);

wchar_t *wcscat (wchar_t * , const wchar_t *);
wchar_t *wcschr (const wchar_t *, wchar_t);
int wcscmp (const wchar_t *, const wchar_t *);
int wcscoll (const wchar_t *, const wchar_t *);
wchar_t *wcscpy (wchar_t * , const wchar_t *);
wchar_t *wcpcpy (wchar_t * , const wchar_t *);
size_t wcscspn (const wchar_t *, const wchar_t *);
size_t wcslcat (wchar_t *, const wchar_t *, size_t);
size_t wcslcpy (wchar_t *, const wchar_t *, size_t);
size_t wcslen (const wchar_t *);
wchar_t *wcsncat (wchar_t * , const wchar_t * , size_t);
int wcsncmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy (wchar_t * , const wchar_t * , size_t);
wchar_t *wcpncpy (wchar_t * , const wchar_t * , size_t);
size_t wcsnlen (const wchar_t *, size_t);
wchar_t *wcspbrk (const wchar_t *, const wchar_t *);
wchar_t *wcsrchr (const wchar_t *, wchar_t);
size_t wcsspn (const wchar_t *, const wchar_t *);
wchar_t *wcsstr (const wchar_t *, const wchar_t *);
int wcswidth (const wchar_t *, size_t);
size_t wcsxfrm (wchar_t *, const wchar_t *, size_t);
int wcwidth (const wchar_t);
wchar_t *wmemchr (const wchar_t *, wchar_t, size_t);
int wmemcmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy (wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset (wchar_t *, wchar_t, size_t);

long wcstol (const wchar_t *, wchar_t **, int);
long long wcstoll (const wchar_t *, wchar_t **, int);
unsigned long wcstoul (const wchar_t *, wchar_t **, int);
unsigned long long wcstoull (const wchar_t *, wchar_t **, int);
long _wcstol_r (struct _reent *, const wchar_t *, wchar_t **, int);
long long _wcstoll_r (struct _reent *, const wchar_t *, wchar_t **, int);
unsigned long _wcstoul_r (struct _reent *, const wchar_t *, wchar_t **, int);
unsigned long long _wcstoull_r (struct _reent *, const wchar_t *, wchar_t **, int);

}
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 2 3
# 70 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
extern "C" {
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef signed char int8_t ;
typedef unsigned char uint8_t ;




typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;




typedef signed short int16_t;
typedef unsigned short uint16_t;
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;
# 85 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef signed int int32_t;
typedef unsigned int uint32_t;
# 99 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;
# 121 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef signed long long int64_t;
typedef unsigned long long uint64_t;
# 131 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;
# 161 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
  typedef signed int int_fast8_t;
  typedef unsigned int uint_fast8_t;




  typedef signed int int_fast16_t;
  typedef unsigned int uint_fast16_t;




  typedef signed int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 215 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
  typedef int_least64_t int_fast64_t;
  typedef uint_least64_t uint_fast64_t;







  typedef long long int intmax_t;
# 233 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
  typedef long long unsigned int uintmax_t;
# 245 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 396 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdint.h" 3
}
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 3
  typedef long long streamoff;



  typedef ptrdiff_t streamsize;
# 90 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 112 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdio.h" 1 3
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 2 3
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwchar" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 229 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };
# 369 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/char_traits.h" 3
}
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/allocator.h" 1 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/allocator.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++allocator.h" 1 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++allocator.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/new_allocator.h" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/new_allocator.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/new" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/new" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/new" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/exception" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 56 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 112 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 127 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/exception" 3
  void __verbose_terminate_handler ();

}

}

#pragma GCC visibility pop
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 95 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 117 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++allocator.h" 2 3
# 54 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/localefwd.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/localefwd.h" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/localefwd.h" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++locale.h" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++locale.h" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++locale.h" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/clocale" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/clocale" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/clocale" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/locale.h" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/locale.h" 3
extern "C" {

struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
};


char *setlocale (int category, const char *locale);
struct lconv *localeconv (void);


struct _reent;
char *_setlocale_r (struct _reent *, int category, const char *locale);
struct lconv *_localeconv_r (struct _reent *);

}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/clocale" 2 3
# 57 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/clocale" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++locale.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/c++locale.h" 2 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);




    const int __ret = __builtin_vsprintf(__out, __fmt, __args);


    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }

}
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/localefwd.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iosfwd" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iosfwd" 3
       
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 132 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;
# 163 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iosfwd" 3
}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/localefwd.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/ctype.h" 1 3





extern "C" {

int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);
int isascii (int __c);
int toascii (int __c);
int _tolower (int __c);
int _toupper (int __c);
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/ctype.h" 3
extern const char *__ctype_ptr;
extern const char _ctype_[];
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/ctype.h" 3
}
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 2 3
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;



  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream_insert.h" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream_insert.h" 3
       
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream_insert.h" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cxxabi-forced.h" 1 3
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cxxabi-forced.h" 3
#pragma GCC visibility push(default)


namespace __cxxabiv1
{


  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);







}
# 52 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 102 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 136 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 260 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 341 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 410 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 515 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/binders.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 705 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_function.h" 2 3
# 56 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/atomicity.h" 1 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/atomicity.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr.h" 1 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 136 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr-single.h" 1 3
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr-single.h" 3
typedef int __gthread_mutex_t;
typedef int __gthread_recursive_mutex_t;
# 212 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr-single.h" 3
static inline int
__gthread_active_p (void)
{
  return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t * )
{
  return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t * )
{
  return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t * )
{
  return 0;
}

static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
# 137 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/gthr.h" 2 3



#pragma GCC visibility pop
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/atomicity.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/atomic_word.h" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {






    return __exchange_and_add_single(__mem, __val);

  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {






    __atomic_add_single(__mem, __val);

  }

}
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 108 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 145 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 170 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable();
   this->_M_length = __n;
   traits_type::assign(this->_M_refdata()[__n], _S_terminal);


 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 464 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 519 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 630 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 643 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 672 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 700 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 717 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 738 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 757 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }






      basic_string&
      append(const basic_string& __str);
# 817 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 849 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 860 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 899 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 915 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 927 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 943 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 955 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 972 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 987 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1003 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1025 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1048 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1066 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1089 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1106 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1130 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1146 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1166 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 ;

        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1193 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1215 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1239 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1258 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1281 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1299 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1317 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1338 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1359 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1381 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct(static_cast<size_type>(__beg), __end, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1513 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1523 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1533 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1565 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1578 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1592 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1609 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1622 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1637 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1650 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1667 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1680 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1695 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1708 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1727 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1741 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1756 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1769 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1788 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1802 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1817 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1831 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1848 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1861 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1877 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1890 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1907 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1922 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1940 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 1970 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1994 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2012 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2035 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2060 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2081 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2152 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2198 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2235 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2272 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2309 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2346 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2383 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2400 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2418 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2441 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2458 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);
# 2476 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.h" 3
}
# 59 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.tcc" 1 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.tcc" 3
       
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg)
        && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 552 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
# 1139 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_string.tcc" 3
}
# 62 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/string" 2 3
# 38 "../Source_Files/CSeries/cseries.h" 2






namespace std {};
# 72 "../Source_Files/CSeries/cseries.h"
# 1 "../Source_Files/CSeries/cstypes.h" 1
# 25 "../Source_Files/CSeries/cstypes.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include-fixed/limits.h" 1 3 4
# 26 "../Source_Files/CSeries/cstypes.h" 2

# 1 "../config.h" 1
# 28 "../Source_Files/CSeries/cstypes.h" 2




enum {
 NONE = -1,
 UNONE = 65535
};
# 58 "../Source_Files/CSeries/cstypes.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 59 "../Source_Files/CSeries/cstypes.h" 2

typedef Uint8 uint8;
typedef Sint8 int8;
typedef Uint16 uint16;
typedef Sint16 int16;
typedef Uint32 uint32;
typedef Sint32 int32;
typedef time_t TimeType;
# 86 "../Source_Files/CSeries/cstypes.h"
typedef int32 _fixed;
# 96 "../Source_Files/CSeries/cstypes.h"
const int MEG = 0x100000;
const int KILO = 0x400L;





typedef uint8 byte;
# 73 "../Source_Files/CSeries/cseries.h" 2
# 83 "../Source_Files/CSeries/cseries.h"
typedef int OSErr;
typedef unsigned char Str255[256];

struct Rect {
 int16 top, left;
 int16 bottom, right;
};

const int noErr = 0;


struct RGBColor {
 uint16 red, green, blue;
};

const int kFontIDMonaco = 4;
const int kFontIDCourier = 22;
# 129 "../Source_Files/CSeries/cseries.h"
# 1 "../Source_Files/CSeries/csmacros.h" 1
# 33 "../Source_Files/CSeries/csmacros.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/string.h" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/string.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/string.h" 2 3





extern "C" {

void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *, const void *, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);


char *strtok (char *, const char *);


size_t strxfrm (char *, const char *, size_t);


char *strtok_r (char *, const char *, char **);

int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void * memccpy (void *, const void *, int, size_t);
void * mempcpy (void *, const void *, size_t);



char *rindex (const char *, int);
char *stpcpy (char *, const char *);
char *stpncpy (char *, const char *, size_t);
int strcasecmp (const char *, const char *);
char *strcasestr (const char *, const char *);
char *strdup (const char *);
char *_strdup_r (struct _reent *, const char *);
char *strndup (const char *, size_t);
char *_strndup_r (struct _reent *, const char *, size_t);
char *strerror_r (int, char *, size_t);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
int strncasecmp (const char *, const char *, size_t);
size_t strnlen (const char *, size_t);
char *strsep (char **, const char *);
char *strlwr (char *);
char *strupr (char *);
# 102 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/string.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/string.h" 1 3
# 103 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/string.h" 2 3

}
# 34 "../Source_Files/CSeries/csmacros.h" 2
# 47 "../Source_Files/CSeries/csmacros.h"
template <typename T> void
SWAP(T& a, T& b)
{
 T t = a;
 a = b;
 b = t;
}
# 70 "../Source_Files/CSeries/csmacros.h"
static inline int NextPowerOfTwo(int n)
{
 int p = 1;
 while(p < n) {p <<= 1;}
 return p;
}
# 86 "../Source_Files/CSeries/csmacros.h"
template<class T> T* GetMemberWithBounds(T* Array, const size_t Index, const size_t Number)
{

 if (!(Index>=0 && Index<Number)) return __null;


 return (Array + Index);
}
# 104 "../Source_Files/CSeries/csmacros.h"
template<class T> void obj_copy(T& destination, const T& source)
 {memcpy(&destination, &source, sizeof(T));}

template<class T> void objlist_copy(T* destination, const T* source, size_t num_objects)
 {memcpy(destination, source, num_objects*sizeof(T));}

template<class T> void obj_set(T& object, int value)
 {memset(&object, value, sizeof(T));}

template<class T> void objlist_set(T* object_list, int value, size_t num_objects)
 {memset(object_list, value, num_objects*sizeof(T));}

template<class T> void obj_clear(T& object)
 {obj_set(object, 0);}

template<class T> void objlist_clear(T* object_list, size_t num_objects)
 {objlist_set(object_list, 0, num_objects);}
# 130 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/cscluts.h" 1
# 27 "../Source_Files/CSeries/cscluts.h"
class LoadedResource;

typedef struct rgb_color {
 uint16 red;
 uint16 green;
 uint16 blue;
} rgb_color;

typedef struct color_table {
 short color_count;
 rgb_color colors[256];
} color_table;






extern void build_color_table(
 color_table *table,
 LoadedResource &clut);

enum {
 gray15Percent,
 windowHighlight,

 NUM_SYSTEM_COLORS
};

extern RGBColor rgb_black;
extern RGBColor rgb_white;
extern RGBColor system_colors[NUM_SYSTEM_COLORS];
# 131 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/csstrings.h" 1
# 37 "../Source_Files/CSeries/csstrings.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 1 3
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 3
       
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_construct.h" 1 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      if (!__has_trivial_destructor(_Value_type))
 for (; __first != __last; ++__first)
   std::_Destroy(&*__first);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

}
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_uninitialized.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  ::new(static_cast<void*>(&*__cur)) typename
      iterator_traits<_ForwardIterator>::value_type(*__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 110 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }


  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 167 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }


  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 221 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 335 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }

}
# 70 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 1 3
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 135 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 174 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 232 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 247 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 283 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 311 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 342 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 358 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 483 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 503 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 546 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 561 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 576 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 601 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 619 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 665 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 685 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 721 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 757 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 790 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 833 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 854 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 866 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      void



      swap(vector& __x)

      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 925 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 989 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1029 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1107 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1124 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
# 1172 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_vector.h" 3
}
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_bvector.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 432 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std __attribute__ ((__visibility__ ("default"))) {
# 477 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }






    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 575 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }

    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 637 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void



    swap(vector& __x)

    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/vector.tcc" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 113 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 280 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);



   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());

       this->_M_impl.construct(__new_finish, __x);

       ++__new_finish;
       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
   catch(...)
     {
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {



   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {

       value_type __x_copy = __x;

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());



    std::__uninitialized_fill_n_a(__new_finish, __n, __x,

      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

}
# 75 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/vector" 2 3
# 38 "../Source_Files/CSeries/csstrings.h" 2

extern char temporary[256];


extern size_t countstr(
 short resid);

extern unsigned char *getpstr(
 unsigned char *string,
 short resid,
 size_t item);

extern char *getcstr(
 char *string,
 short resid,
 size_t item);


extern const std::vector<std::string> build_stringvector_from_stringset (int resid);


extern unsigned char *pstrcpy(
 unsigned char *dst,
 const unsigned char *src);


extern unsigned char* pstrncpy(
 unsigned char* dest,
 const unsigned char* source,
 size_t total_byte_count);

extern unsigned char* pstrdup(
 const unsigned char* source);

extern unsigned char* a1_c2pstr(
 char* inoutStringBuffer);

extern char* a1_p2cstr(
 unsigned char* inoutStringBuffer);


extern char *csprintf(
 char *buffer,
 const char *format,
 ...) __attribute__((format(printf,2,3)));

extern unsigned char *psprintf(
 unsigned char *buffer,
 const char *format,
 ...) __attribute__((format(printf,2,3)));

extern void dprintf(
 const char *format,
 ...) __attribute__((format(printf,1,2)));

extern void fdprintf(
 const char *format,
 ...) __attribute__((format(printf,1,2)));


extern void copy_string_to_pstring (const std::string &s, unsigned char* dst, int maxlen = 255);
extern void copy_string_to_cstring (const std::string &s, char* dst, int maxlen = 255);

extern const std::string pstring_to_string (const unsigned char* ps);

extern uint16 mac_roman_to_unicode(char c);
extern char unicode_to_mac_roman(uint16 c);
extern void mac_roman_to_unicode(const char *input, uint16 *output);
extern void mac_roman_to_unicode(const char *input, uint16 *output, int max_len);
std::string mac_roman_to_utf8(const std::string& input);
std::string utf8_to_mac_roman(const std::string& input);
# 132 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/csfonts.h" 1
# 30 "../Source_Files/CSeries/csfonts.h"
const int styleNormal = 0;
const int styleBold = 1;
const int styleItalic = 2;
const int styleUnderline = 4;

const int styleShadow = 16;

struct TextSpec {
 int16 font;

 uint16 style;
 int16 size;
 int16 adjust_height;


 std::string normal;
 std::string oblique;
 std::string bold;
 std::string bold_oblique;
};
# 133 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/cspixels.h" 1
# 28 "../Source_Files/CSeries/cspixels.h"
typedef uint8 pixel8;
typedef uint16 pixel16;
typedef uint32 pixel32;
# 134 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/csalerts.h" 1
# 32 "../Source_Files/CSeries/csalerts.h"
enum {
 infoError,
 fatalError
};

extern void alert_user(const char *message, short severity = infoError);

extern void alert_user(
 short severity,
 short resid,
 short item,
 OSErr error);

extern void pause_debug(void);
extern void vpause(
 const char *message);

extern void halt(void) __attribute__((noreturn));
extern void vhalt(
 const char *message) __attribute__((noreturn));

extern void _alephone_assert(
 const char *file,
 long line,
 const char *what) __attribute__((noreturn));
extern void _alephone_warn(
 const char *file,
 long line,
 const char *what);
# 135 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/csdialogs.h" 1
# 62 "../Source_Files/CSeries/csdialogs.h"
class dialog;

typedef dialog* DialogPtr;
typedef dialog* DialogPTR;
# 74 "../Source_Files/CSeries/csdialogs.h"
extern bool QQ_control_exists (DialogPTR dlg, int item);
extern void QQ_set_control_activity (DialogPTR dlg, int item, bool active);
extern void QQ_hide_control (DialogPTR dlg, int item);
extern void QQ_show_control (DialogPTR dlg, int item);

extern bool QQ_get_boolean_control_value (DialogPTR dlg, int item);
extern void QQ_set_boolean_control_value (DialogPTR dlg, int item, bool value);

extern int QQ_get_selector_control_value (DialogPTR dlg, int item);
extern void QQ_set_selector_control_value (DialogPTR dlg, int item, int value);
extern void QQ_set_selector_control_labels (DialogPTR dlg, int item, const std::vector<std::string> labels);
extern void QQ_set_selector_control_labels_from_stringset (DialogPTR dlg, int item, int stringset_id);

extern const std::string QQ_copy_string_from_text_control (DialogPTR dlg, int item);
extern void QQ_copy_string_to_text_control (DialogPTR dlg, int item, const std::string &s);
extern long QQ_extract_number_from_text_control (DialogPTR dlg, int item);
extern void QQ_insert_number_into_text_control (DialogPTR dlg, int item, long number);





extern long extract_number_from_text_item(
 DialogPtr dlg,
 short item);

extern void insert_number_into_text_item(
 DialogPtr dlg,
 short item,
 long number);

extern void copy_pstring_from_text_field(
        DialogPtr dialog,
        short item,
        unsigned char* pstring);

extern void copy_pstring_to_text_field(
        DialogPtr dialog,
        short item,
        const unsigned char* pstring);

extern void copy_pstring_to_static_text(DialogPtr dialog, short item, const unsigned char* pstring);
# 221 "../Source_Files/CSeries/csdialogs.h"
extern void modify_selection_control(
 DialogPtr dlg,
 short item,
 short hilite,
 short value);

extern void modify_control_enabled(
 DialogPtr dlg,
 short item,
 short hilite);

extern void modify_boolean_control(
 DialogPtr dlg,
 short item,
 short hilite,
 short value);

extern short get_selection_control_value(
        DialogPtr dialog,
        short which_control);

extern bool get_boolean_control_value(
        DialogPtr dialog,
        short which_control);






void HideDialogItem(DialogPtr dialog, short item_index);
void ShowDialogItem(DialogPtr dialog, short item_index);
# 136 "../Source_Files/CSeries/cseries.h" 2
# 1 "../Source_Files/CSeries/csmisc.h" 1
# 33 "../Source_Files/CSeries/csmisc.h"
extern uint32 machine_tick_count(void);
extern bool wait_for_click_or_keypress(
 uint32 ticks);
# 57 "../Source_Files/CSeries/csmisc.h"
extern void kill_screen_saver(void);


extern void initialize_debugger(bool on);
# 137 "../Source_Files/CSeries/cseries.h" 2
# 27 "shell.cpp" 2

# 1 "../Source_Files/GameWorld/map.h" 1
# 56 "../Source_Files/GameWorld/map.h"
# 1 "../Source_Files/CSeries/csmacros.h" 1
# 57 "../Source_Files/GameWorld/map.h" 2
# 1 "../Source_Files/GameWorld/world.h" 1
# 67 "../Source_Files/GameWorld/world.h"
typedef int16 angle;
typedef int16 world_distance;
# 92 "../Source_Files/GameWorld/world.h"
struct world_point2d
{
 world_distance x, y;
};
typedef struct world_point2d world_point2d;

struct world_point3d
{
 world_distance x, y, z;
};
typedef struct world_point3d world_point3d;

struct fixed_point3d
{
 _fixed x, y, z;
};
typedef struct fixed_point3d fixed_point3d;



struct world_vector2d
{
 world_distance i, j;
};
typedef struct world_vector2d world_vector2d;

struct world_vector3d
{
 world_distance i, j, k;
};
typedef struct world_vector3d world_vector3d;

struct fixed_vector3d
{
 _fixed i, j, k;
};
typedef struct fixed_vector3d fixed_vector3d;



struct long_point2d
{
 int32 x, y;
};
typedef struct long_point2d long_point2d;

struct long_point3d
{
 int32 x, y, z;
};
typedef struct long_point3d long_point3d;

struct long_vector2d
{
 int32 i, j;
};
typedef struct long_vector2d long_vector2d;

struct long_vector3d
{
 int32 i, j, k;
};
typedef struct long_vector3d long_vector3d;



struct world_location3d
{
 world_point3d point;
 short polygon_index;

 angle yaw, pitch;

 world_vector3d velocity;
};
typedef struct world_location3d world_location3d;



extern short *cosine_table, *sine_table;




void build_trig_tables(void);



static inline angle normalize_angle(angle theta)
{
 return ((theta)&(angle)(((short)(1<<9))-1));
}

world_point2d *rotate_point2d(world_point2d *point, world_point2d *origin, angle theta);
world_point3d *rotate_point3d(world_point3d *point, world_point3d *origin, angle theta, angle phi);

world_point2d *translate_point2d(world_point2d *point, world_distance distance, angle theta);
world_point3d *translate_point3d(world_point3d *point, world_distance distance, angle theta, angle phi);

world_point2d *transform_point2d(world_point2d *point, world_point2d *origin, angle theta);
world_point3d *transform_point3d(world_point3d *point, world_point3d *origin, angle theta, angle phi);



angle arctangent(int32 x, int32 y);

void set_random_seed(uint16 seed);
uint16 get_random_seed(void);
uint16 global_random(void);

uint16 local_random(void);

world_distance guess_distance2d(world_point2d *p0, world_point2d *p1);
world_distance distance3d(world_point3d *p0, world_point3d *p1);
world_distance distance2d(world_point2d *p0, world_point2d *p1);

int32 isqrt(register uint32 x);





void long_to_overflow_short_2d(long_vector2d& LVec, world_point2d& WVec, uint16& flags);
void overflow_short_to_long_2d(world_point2d& WVec, uint16& flags, long_vector2d& LVec);


world_point2d *transform_overflow_point2d(world_point2d *point, world_point2d *origin, angle theta, uint16 *flags);


static inline void long_to_short_2d(long_vector2d& LVec, world_vector2d&WVec)
{
 WVec.i = static_cast<short>(LVec.i);
 WVec.j = static_cast<short>(LVec.j);
}
static inline void short_to_long_2d(world_vector2d&WVec, long_vector2d& LVec)
{
 LVec.i = WVec.i;
 LVec.j = WVec.j;
}
# 58 "../Source_Files/GameWorld/map.h" 2
# 1 "../Source_Files/GameWorld/dynamic_limits.h" 1
# 34 "../Source_Files/GameWorld/dynamic_limits.h"
# 1 "../Source_Files/XML/XML_ElementParser.h" 1
# 42 "../Source_Files/XML/XML_ElementParser.h"
using namespace std;

# 1 "../Source_Files/CSeries/cstypes.h" 1
# 45 "../Source_Files/XML/XML_ElementParser.h" 2

extern bool XML_GetBooleanValue(const char *String, bool &Value);




bool StringsEqual(const char *String1, const char *String2, int MaxStrLen = 32);






size_t DeUTF8(const char *InString, size_t InLen, char *OutString, size_t OutMaxLen);




size_t DeUTF8_Pas(const char *InString, size_t InLen, Str255 OutString, size_t OutMaxLen);
size_t DeUTF8_C(const char *InString, size_t InLen, char *OutString, size_t OutMaxLen);


class XML_ElementParser
{

 char *Name;


 vector<XML_ElementParser *> Children;

protected:



 template<class T> bool ReadNumericalValue(const char *String, const char *Format,
  T& Value)
 {
  if (sscanf(String,Format,&Value) != 1)
  {
   BadNumericalValue();
   return false;
  }
  return true;
 }


 template<class T> bool ReadBoundedNumericalValue(const char *String, const char *Format,
  T& Value, const T& MinVal, const T& MaxVal)
 {
  if (ReadNumericalValue(String,Format,Value))
  {
   if (Value >= MinVal && Value <= MaxVal)
    return true;

   OutOfRange();
   return false;
  }
  return false;
 }


 template<class T> bool ReadBooleanValue(const char *String, T& Value)
 {
  bool BValue;
  if (!XML_GetBooleanValue(String,BValue))
  {
   BadBooleanValue();
   return false;
  }
  Value = T(BValue);
  return true;
 }




 bool ReadInt16Value(const char *String, int16& Value);
 bool ReadBoundedInt16Value(const char *String, int16& Value, int16 MinVal, int16 MaxVal);
 bool ReadUInt16Value(const char *String, uint16& Value);
 bool ReadBoundedUInt16Value(const char *String, uint16& Value, uint16 MinVal, uint16 MaxVal);

 bool ReadInt32Value(const char *String, int32& Value);
 bool ReadBoundedInt32Value(const char *String, int32& Value, int32 MinVal, int32 MaxVal);
 bool ReadUInt32Value(const char *String, uint32& Value);
 bool ReadBoundedUInt32Value(const char *String, uint32& Value, uint32 MinVal, uint32 MaxVal);

 bool ReadBooleanValueAsInt16(const char *String, int16& Value);
 bool ReadBooleanValueAsUInt16(const char *String, uint16& Value);
 bool ReadBooleanValueAsInt32(const char *String, int32& Value);
 bool ReadBooleanValueAsUInt32(const char *String, uint32& Value);
 bool ReadBooleanValueAsBool(const char *String, bool& Value);

 bool ReadFloatValue(const char *String, float& Value);

public:


 char *GetName() {return Name;}


 bool NameMatch(const char *_Name);






 virtual bool Start() {return true;}
 virtual bool End() {return true;}



 virtual bool HandleAttribute(const char * , const char * ) {return true;}
 virtual bool AttributesDone() {return true;}


 virtual bool HandleString(const char * , int ) {return true;}


 virtual bool ResetValues() {return true;}


 const char *ErrorString;


 void UnrecognizedTag();
 void AttribsMissing();
 void BadNumericalValue();
 void OutOfRange();
 void BadBooleanValue();


 XML_ElementParser *Parent;



 XML_ElementParser(const char *_Name);
 virtual ~XML_ElementParser();


 void AddChild(XML_ElementParser *Child);


 void ResetChildrenValues();



 XML_ElementParser *FindChild(const char *_Name);
};
# 35 "../Source_Files/GameWorld/dynamic_limits.h" 2



enum {
 _dynamic_limit_objects,
 _dynamic_limit_monsters,
 _dynamic_limit_paths,
 _dynamic_limit_projectiles,
 _dynamic_limit_effects,
 _dynamic_limit_rendered,
 _dynamic_limit_local_collision,
 _dynamic_limit_global_collision,
 NUMBER_OF_DYNAMIC_LIMITS
};



XML_ElementParser *DynamicLimits_GetParser();


uint16 get_dynamic_limit(int which);
# 59 "../Source_Files/GameWorld/map.h" 2
# 83 "../Source_Files/GameWorld/map.h"
# 1 "../Source_Files/RenderMain/shape_descriptors.h" 1
# 37 "../Source_Files/RenderMain/shape_descriptors.h"
typedef uint16 shape_descriptor;
# 49 "../Source_Files/RenderMain/shape_descriptors.h"
enum
{
 _collection_interface,
 _collection_weapons_in_hand,
 _collection_juggernaut,
 _collection_tick,
 _collection_rocket,
 _collection_hunter,
 _collection_player,
 _collection_items,
 _collection_trooper,
 _collection_fighter,
 _collection_defender,
 _collection_yeti,
 _collection_civilian,
 _collection_civilian_fusion,
 _collection_enforcer,
 _collection_hummer,
 _collection_compiler,
 _collection_walls1,
 _collection_walls2,
 _collection_walls3,
 _collection_walls4,
 _collection_walls5,
 _collection_scenery1,
 _collection_scenery2,
 _collection_scenery3,
 _collection_scenery4,
 _collection_scenery5,
 _collection_landscape1,
 _collection_landscape2,
 _collection_landscape3,
 _collection_landscape4,
 _collection_cyborg,

 NUMBER_OF_COLLECTIONS
};
# 84 "../Source_Files/GameWorld/map.h" 2



enum
{
 _damage_explosion,
 _damage_electrical_staff,
 _damage_projectile,
 _damage_absorbed,
 _damage_flame,
 _damage_hound_claws,
 _damage_alien_projectile,
 _damage_hulk_slap,
 _damage_compiler_bolt,
 _damage_fusion_bolt,
 _damage_hunter_bolt,
 _damage_fist,
 _damage_teleporter,
 _damage_defender,
 _damage_yeti_claws,
 _damage_yeti_projectile,
 _damage_crushing,
 _damage_lava,
 _damage_suffocation,
 _damage_goo,
 _damage_energy_drain,
 _damage_oxygen_drain,
 _damage_hummer_bolt,
 _damage_shotgun_projectile,
 NUMBER_OF_DAMAGE_TYPES
};

enum
{
 _alien_damage= 0x1
};

struct damage_definition
{
 int16 type, flags;

 int16 base, random;
 _fixed scale;
};
const int SIZEOF_damage_definition = 12;





enum
{
 _saved_monster,
 _saved_object,
 _saved_item,
 _saved_player,
 _saved_goal,
 _saved_sound_source
};

enum
{
 _map_object_is_invisible= 0x0001,
 _map_object_is_platform_sound= 0x0001,
 _map_object_hanging_from_ceiling= 0x0002,
 _map_object_is_blind= 0x0004,
 _map_object_is_deaf= 0x0008,
 _map_object_floats= 0x0010,
 _map_object_is_network_only= 0x0020


};




struct map_object
{
 int16 type;
 int16 index;
 int16 facing;
 int16 polygon_index;
 world_point3d location;

 uint16 flags;
};
const int SIZEOF_map_object = 16;


typedef world_point2d saved_map_pt;
typedef struct line_data saved_line;
typedef struct polygon_data saved_poly;
typedef struct map_annotation saved_annotation;
typedef struct map_object saved_object;
typedef struct static_data saved_map_data;



enum {
 _single_player_entry_point= 0x01,
 _multiplayer_cooperative_entry_point= 0x02,
 _multiplayer_carnage_entry_point= 0x04,
 _kill_the_man_with_the_ball_entry_point = 0x08,
 _king_of_hill_entry_point= 0x10,
 _defense_entry_point= 0x20,
 _rugby_entry_point= 0x40,
 _capture_the_flag_entry_point = 0x80
};

struct entry_point
{
 int16 level_number;
 char level_name[64+2];
};



struct player_start_data
{
 int16 team;
 int16 identifier;
 int16 color;
 char name[32 +1];
};

enum {
 _player_start_doesnt_auto_recenter_flag= 0x4000,
 _player_start_doesnt_auto_switch_weapons_flag= 0x8000
};

const uint16 player_start_identifier_mask=
 (uint16)~(_player_start_doesnt_auto_recenter_flag | _player_start_doesnt_auto_switch_weapons_flag);

int16 player_identifier_value(int16 identifier);
int16 player_start_identifier_value(const player_start_data * const p);
bool player_identifier_doesnt_auto_recenter(int16 identifier);
bool player_start_doesnt_auto_recenter(const player_start_data * const p);
void set_player_start_doesnt_auto_recenter_status(player_start_data * const p, bool v);
bool player_identifier_doesnt_auto_switch_weapons(int16 identifier);
bool player_start_doesnt_auto_switch_Weapons(const player_start_data * const p);
void set_player_start_doesnt_auto_switch_weapons_status(player_start_data * const p, bool v);


inline int16 player_identifier_value(int16 identifier)
{ return identifier & player_start_identifier_mask; }

inline int16 player_start_identifier_value(const player_start_data * const p)
{ return (p)->identifier & player_start_identifier_mask; }

inline bool player_identifier_doesnt_auto_recenter(int16 identifier)
{ return ((identifier)&(_player_start_doesnt_auto_recenter_flag)); }

inline bool player_start_doesnt_auto_recenter(const player_start_data * const p)
{ return ((p->identifier)&(_player_start_doesnt_auto_recenter_flag)); }

inline void set_player_start_doesnt_auto_recenter_status(player_start_data * const p, bool v)
{ ((void)((v)?((p->identifier)|=(_player_start_doesnt_auto_recenter_flag)):((p->identifier)&=~(_player_start_doesnt_auto_recenter_flag)))); }

inline bool player_identifier_doesnt_auto_switch_weapons(int16 identifier)
{ return ((identifier)&(_player_start_doesnt_auto_switch_weapons_flag)); }

inline bool player_start_doesnt_auto_switch_Weapons(const player_start_data * const p)
{ return ((p->identifier)&(_player_start_doesnt_auto_switch_weapons_flag)); }

inline void set_player_start_doesnt_auto_switch_weapons_status(player_start_data * const p, bool v)
{ ((void)((v)?((p->identifier)|=(_player_start_doesnt_auto_switch_weapons_flag)):((p->identifier)&=~(_player_start_doesnt_auto_switch_weapons_flag)))); }


struct directory_data {
 int16 mission_flags;
 int16 environment_flags;
 int32 entry_point_flags;
 char level_name[(64+2)];
};
const int SIZEOF_directory_data = 74;






struct map_annotation
{
 int16 type;

 world_point2d location;
 int16 polygon_index;

 char text[64];
};
const int SIZEOF_map_annotation = 72;

struct map_annotation *get_next_map_annotation(int16 *count);






struct ambient_sound_image_data
{
 uint16 flags;

 int16 sound_index;
 int16 volume;

 int16 unused[5];
};
const int SIZEOF_ambient_sound_image_data = 16;





enum
{
 _sound_image_is_non_directional= 0x0001
};


struct random_sound_image_data
{
 uint16 flags;

 int16 sound_index;

 int16 volume, delta_volume;
 int16 period, delta_period;
 angle direction, delta_direction;
 _fixed pitch, delta_pitch;


 int16 phase;

 int16 unused[3];
};
const int SIZEOF_random_sound_image_data = 32;
# 348 "../Source_Files/GameWorld/map.h"
enum
{
 _obj_not_animated= 0x0000,
 _obj_animated= 0x2000,
 _obj_keyframe_started= 0x1000,
 _obj_last_frame_animated= 0x0800,
 _obj_transfer_mode_finished= 0x0400
};


enum
{
 _object_is_enlarged= 0x0200,
 _object_is_tiny= 0x0100,

 OBJECT_SCALE_FLAGS_MASK= _object_is_enlarged|_object_is_tiny
};
# 384 "../Source_Files/GameWorld/map.h"
enum
{
 _object_is_normal,
 _object_is_scenery,
 _object_is_monster,
 _object_is_projectile,
 _object_is_effect,
 _object_is_item,
 _object_is_device,
 _object_is_garbage
};







enum
{
 _xfer_normal,
 _xfer_fade_out_to_black,
 _xfer_invisibility,
 _xfer_subtle_invisibility,
 _xfer_pulsate,
 _xfer_wobble,
 _xfer_fast_wobble,
 _xfer_static,
 _xfer_50percent_static,
 _xfer_landscape,
 _xfer_smear,
 _xfer_fade_out_static,
 _xfer_pulsating_static,
 _xfer_fold_in,
 _xfer_fold_out,
 _xfer_horizontal_slide,
 _xfer_fast_horizontal_slide,
 _xfer_vertical_slide,
 _xfer_fast_vertical_slide,
 _xfer_wander,
 _xfer_fast_wander,
 _xfer_big_landscape,
 NUMBER_OF_TRANSFER_MODES
};

struct object_location
{
 struct world_point3d p;
 int16 polygon_index;

 angle yaw, pitch;

 uint16 flags;
};

struct object_data
{


 world_point3d location;
 int16 polygon;

 angle facing;




 shape_descriptor shape;

 uint16 sequence;
 uint16 flags;
 int16 transfer_mode, transfer_period;
 int16 transfer_phase;
 int16 permutation;

 int16 next_object;
 int16 parasitic_object;


 _fixed sound_pitch;
};
const int SIZEOF_object_data = 32;
# 479 "../Source_Files/GameWorld/map.h"
struct endpoint_data
{
 uint16 flags;
 world_distance highest_adjacent_floor_height, lowest_adjacent_ceiling_height;

 world_point2d vertex;
 world_point2d transformed;

 int16 supporting_polygon_index;
};
const int SIZEOF_endpoint_data = 16;


const int SIZEOF_world_point2d = 4;
# 521 "../Source_Files/GameWorld/map.h"
struct line_data
{
 int16 endpoint_indexes[2];
 uint16 flags;

 world_distance length;
 world_distance highest_adjacent_floor, lowest_adjacent_ceiling;



 int16 clockwise_polygon_side_index, counterclockwise_polygon_side_index;



 int16 clockwise_polygon_owner, counterclockwise_polygon_owner;

 int16 unused[6];
};
const int SIZEOF_line_data = 32;



enum
{
 _control_panel_status= 0x0001,
 _side_is_control_panel= 0x0002,
 _side_is_repair_switch= 0x0004,
 _side_is_destructive_switch= 0x0008,
 _side_is_lighted_switch= 0x0010,
 _side_switch_can_be_destroyed= 0x0020,
 _side_switch_can_only_be_hit_by_projectiles= 0x0040,

 _editor_dirty_bit= 0x4000
};

enum
{
 _panel_is_oxygen_refuel,
 _panel_is_shield_refuel,
 _panel_is_double_shield_refuel,
 _panel_is_triple_shield_refuel,
 _panel_is_light_switch,
 _panel_is_platform_switch,
 _panel_is_tag_switch,
 _panel_is_pattern_buffer,
 _panel_is_computer_terminal,
 NUMBER_OF_CONTROL_PANELS
};
# 584 "../Source_Files/GameWorld/map.h"
enum
{
 _full_side,
 _high_side,
 _low_side,
 _composite_side,
 _split_side

};

struct side_texture_definition
{
 world_distance x0, y0;
 shape_descriptor texture;
};

struct side_exclusion_zone
{
 world_point2d e0, e1, e2, e3;
};

struct side_data
{
 int16 type;
 uint16 flags;

 struct side_texture_definition primary_texture;
 struct side_texture_definition secondary_texture;
 struct side_texture_definition transparent_texture;



 struct side_exclusion_zone exclusion_zone;

 int16 control_panel_type;
 int16 control_panel_permutation;

 int16 primary_transfer_mode;
 int16 secondary_transfer_mode;
 int16 transparent_transfer_mode;

 int16 polygon_index, line_index;

 int16 primary_lightsource_index;
 int16 secondary_lightsource_index;
 int16 transparent_lightsource_index;

 int32 ambient_delta;

 int16 unused[1];
};
const int SIZEOF_side_data = 64;






enum
{
 _polygon_is_normal,
 _polygon_is_item_impassable,
 _polygon_is_monster_impassable,
 _polygon_is_hill,
 _polygon_is_base,
 _polygon_is_platform,
 _polygon_is_light_on_trigger,
 _polygon_is_platform_on_trigger,
 _polygon_is_light_off_trigger,
 _polygon_is_platform_off_trigger,
 _polygon_is_teleporter,
 _polygon_is_zone_border,
 _polygon_is_goal,
 _polygon_is_visible_monster_trigger,
 _polygon_is_invisible_monster_trigger,
 _polygon_is_dual_monster_trigger,
 _polygon_is_item_trigger,
 _polygon_must_be_explored,
 _polygon_is_automatic_exit,
 _polygon_is_minor_ouch,
 _polygon_is_major_ouch,
 _polygon_is_glue,
 _polygon_is_glue_trigger,
 _polygon_is_superglue
};





struct horizontal_surface_data
{
 world_distance height;
 int16 lightsource_index;
 shape_descriptor texture;
 int16 transfer_mode, transfer_mode_data;

 world_point2d origin;
};

struct polygon_data
{
 int16 type;
 uint16 flags;
 int16 permutation;

 uint16 vertex_count;
 int16 endpoint_indexes[8];
 int16 line_indexes[8];

 shape_descriptor floor_texture, ceiling_texture;
 world_distance floor_height, ceiling_height;
 int16 floor_lightsource_index, ceiling_lightsource_index;

 int32 area;

 int16 first_object;




 int16 first_exclusion_zone_index;
 int16 line_exclusion_zone_count;
 int16 point_exclusion_zone_count;

 int16 floor_transfer_mode;
 int16 ceiling_transfer_mode;

 int16 adjacent_polygon_indexes[8];


 int16 first_neighbor_index;
 int16 neighbor_count;

 world_point2d center;

 int16 side_indexes[8];

 world_point2d floor_origin, ceiling_origin;

 int16 media_index;
 int16 media_lightsource_index;



 int16 sound_source_indexes;


 int16 ambient_sound_image_index;
 int16 random_sound_image_index;

 int16 unused[1];
};
const int SIZEOF_polygon_data = 128;



struct saved_lighting_function_specification
{
 int16 function;

 int16 period, delta_period;
 uint16 intensity_hi, intensity_lo, delta_intensity_hi, delta_intensity_lo;
};

struct saved_static_light_data
{
 int16 type;
 uint16 flags;

 int16 phase;

 struct saved_lighting_function_specification primary_active, secondary_active, becoming_active;
 struct saved_lighting_function_specification primary_inactive, secondary_inactive, becoming_inactive;

 int16 tag;

 int16 unused[4];
};
const int SIZEOF_saved_static_light_data = 100;



enum
{
 _wuss_level,
 _easy_level,
 _normal_level,
 _major_damage_level,
 _total_carnage_level,
 NUMBER_OF_GAME_DIFFICULTY_LEVELS
};


enum
{
 kDifficultyLevelsStringSetID = 145
};





enum
{
 _reappears_in_random_location= 0x0001
};

struct object_frequency_definition
{
 uint16 flags;

 int16 initial_count;
 int16 minimum_count;
 int16 maximum_count;

 int16 random_count;
 uint16 random_chance;
};
const int SIZEOF_object_frequency_definition = 12;



enum
{
 _mission_none= 0x0000,
 _mission_extermination= 0x0001,
 _mission_exploration= 0x0002,
 _mission_retrieval= 0x0004,
 _mission_repair= 0x0008,
 _mission_rescue= 0x0010
};

enum
{
 _environment_normal= 0x0000,
 _environment_vacuum= 0x0001,
 _environment_magnetic= 0x0002,
 _environment_rebellion= 0x0004,
 _environment_low_gravity= 0x0008,

 _environment_network= 0x2000,
 _environment_single_player= 0x4000
};


struct static_data
{
 int16 environment_code;

 int16 physics_model;
 int16 song_index;
 int16 mission_flags;
 int16 environment_flags;

 int16 unused[4];

 char level_name[(64+2)];
 uint32 entry_point_flags;
};
const unsigned int SIZEOF_static_data = 88;

enum
{
 _multiplayer_game= 0x0001,
 _ammo_replenishes= 0x0002,
 _weapons_replenish= 0x0004,
 _specials_replenish= 0x0008,
 _monsters_replenish= 0x0010,
 _motion_sensor_does_not_work= 0x00020,
 _overhead_map_is_omniscient= 0x0040,
 _burn_items_on_death= 0x0080,
 _live_network_stats= 0x0100,
 _game_has_kill_limit= 0x0200,
 _force_unique_teams= 0x0400,
 _dying_is_penalized= 0x0800,
 _suicide_is_penalized= 0x1000,
 _overhead_map_shows_items= 0x2000,
 _overhead_map_shows_monsters= 0x4000,
 _overhead_map_shows_projectiles= 0x8000
};

enum
  {
    _allow_crosshair = 0x0001,
    _allow_tunnel_vision = 0x0002,
    _allow_behindview = 0x0004,
    _disable_carnage_messages = 0x0008,
    _disable_saving_level = 0x0010
  };

enum
{
 _level_unfinished,
 _level_finished,
 _level_failed
};


enum {
 _game_of_kill_monsters,
 _game_of_cooperative_play,
 _game_of_capture_the_flag,
 _game_of_king_of_the_hill,
 _game_of_kill_man_with_ball,
 _game_of_defense,
 _game_of_rugby,
 _game_of_tag,
 _game_of_custom,
 NUMBER_OF_GAME_TYPES
};
# 906 "../Source_Files/GameWorld/map.h"
struct game_data
{



 int32 game_time_remaining;
 int16 game_type;
 int16 game_options;
        int16 cheat_flags;
 int16 kill_limit;
 int16 initial_random_seed;
 int16 difficulty_level;
 int16 parameters[2];
};

struct dynamic_data
{

 int32 tick_count;


 uint16 random_seed;



 struct game_data game_information;

 int16 player_count;
 int16 speaking_player_index;

 int16 unused;
 int16 platform_count;
 int16 endpoint_count;
 int16 line_count;
 int16 side_count;
 int16 polygon_count;
 int16 lightsource_count;
 int16 map_index_count;
 int16 ambient_sound_image_count, random_sound_image_count;


 int16 object_count;
 int16 monster_count;
 int16 projectile_count;
 int16 effect_count;
 int16 light_count;

 int16 default_annotation_count;
 int16 personal_annotation_count;

 int16 initial_objects_count;

 int16 garbage_object_count;


 int16 last_monster_index_to_get_time, last_monster_index_to_build_path;


 int16 new_monster_mangler_cookie, new_monster_vanishing_cookie;


 int16 civilians_killed_by_players;


 int16 random_monsters_left[64];
 int16 current_monster_count[64];
 int16 random_items_left[64];
 int16 current_item_count[64];

 int16 current_level_number;

 int16 current_civilian_causalties, current_civilian_count;
 int16 total_civilian_causalties, total_civilian_count;

 world_point2d game_beacon;
 int16 game_player_index;
};
const unsigned int SIZEOF_dynamic_data = 604;






extern struct static_data *static_world;
extern struct dynamic_data *dynamic_world;

extern vector<object_data> ObjectList;




extern vector<endpoint_data> EndpointList;



extern vector<line_data> LineList;



extern vector<side_data> SideList;



extern vector<polygon_data> PolygonList;
# 1019 "../Source_Files/GameWorld/map.h"
extern vector<ambient_sound_image_data> AmbientSoundImageList;



extern vector<random_sound_image_data> RandomSoundImageList;






extern vector<int16> MapIndexList;




extern vector<uint8> AutomapLineList;


extern vector<uint8> AutomapPolygonList;





extern vector<map_annotation> MapAnnotationList;



extern vector<map_object> SavedObjectList;






extern bool game_is_networked;
# 1064 "../Source_Files/GameWorld/map.h"
extern bool LandscapesLoaded;



extern short LoadedWallTexture;



void initialize_marathon(void);

void leaving_map(void);

bool entering_map(bool restoring_saved);



std::pair<bool, int16> update_world(void);


void reset_intermediate_action_queues();
void set_prediction_wanted(bool inPrediction);


void changed_polygon(short original_polygon_index, short new_polygon_index, short player_index);

short calculate_damage(struct damage_definition *damage);
void cause_polygon_damage(short polygon_index, short monster_index);

short calculate_level_completion_state(void);



void allocate_map_memory(void);
void initialize_map_for_new_game(void);
void initialize_map_for_new_level(void);

void mark_environment_collections(short environment_code, bool loading);
void mark_map_collections(bool loading);
bool collection_in_environment(short collection_code, short environment_code);

bool valid_point2d(world_point2d *p);
bool valid_point3d(world_point3d *p);

void reconnect_map_object_list(void);
short new_map_object2d(world_point2d *location, short polygon_index, shape_descriptor shape, angle facing);
short new_map_object3d(world_point3d *location, short polygon_index, shape_descriptor shape, angle facing);
short new_map_object(struct object_location *location, shape_descriptor shape);
short attach_parasitic_object(short host_index, shape_descriptor shape, angle facing);
void remove_parasitic_object(short host_index);
bool translate_map_object(short object_index, world_point3d *new_location, short new_polygon_index);
short find_new_object_polygon(world_point2d *parent_location, world_point2d *child_location, short parent_polygon_index);
void remove_map_object(short index);




extern void remove_object_from_polygon_object_list(short object_index);
extern void remove_object_from_polygon_object_list(short object_index, short polygon_index);




extern void deferred_add_object_to_polygon_object_list(short object_index, short index_to_precede);




extern void perform_deferred_polygon_object_list_manipulations();



struct shape_and_transfer_mode
{

 short collection_code, low_level_shape_index;

 short transfer_mode;
 _fixed transfer_phase;


 short Frame, NextFrame;


 short Phase, Ticks;
};

void get_object_shape_and_transfer_mode(world_point3d *camera_location, short object_index, struct shape_and_transfer_mode *data);
void set_object_shape_and_transfer_mode(short object_index, shape_descriptor shape, short transfer_mode);
void animate_object(short object_index);
bool randomize_object_sequence(short object_index, shape_descriptor shape);

void play_object_sound(short object_index, short sound_code);
void play_polygon_sound(short polygon_index, short sound_code);
void _play_side_sound(short side_index, short sound_code, _fixed pitch);
void play_world_sound(short polygon_index, world_point3d *origin, short sound_code);



void handle_random_sound_image(void);

void initialize_map_for_new_player(void);
void generate_map(short level);

short world_point_to_polygon_index(world_point2d *location);
short clockwise_endpoint_in_line(short polygon_index, short line_index, short index);

short find_adjacent_polygon(short polygon_index, short line_index);
short find_adjacent_side(short polygon_index, short line_index);
short find_shared_line(short polygon_index1, short polygon_index2);
bool line_is_landscaped(short polygon_index, short line_index, world_distance z);
short find_line_crossed_leaving_polygon(short polygon_index, world_point2d *p0, world_point2d *p1);
bool point_in_polygon(short polygon_index, world_point2d *p);
void find_center_of_polygon(short polygon_index, world_point2d *center);

int32 point_to_line_segment_distance_squared(world_point2d *p, world_point2d *a, world_point2d *b);
int32 point_to_line_distance_squared(world_point2d *p, world_point2d *a, world_point2d *b);

_fixed closest_point_on_line(world_point2d *e0, world_point2d *e1, world_point2d *p, world_point2d *closest_point);
void closest_point_on_circle(world_point2d *c, world_distance radius, world_point2d *p, world_point2d *closest_point);

_fixed find_line_intersection(world_point2d *e0, world_point2d *e1, world_point3d *p0,
 world_point3d *p1, world_point3d *intersection);
_fixed find_floor_or_ceiling_intersection(world_distance h, world_point3d *p0, world_point3d *p1, world_point3d *intersection);

void ray_to_line_segment(world_point2d *p0, world_point2d *p1, angle theta, world_distance d);

void push_out_line(world_point2d *e0, world_point2d *e1, world_distance d, world_distance line_length);
bool keep_line_segment_out_of_walls(short polygon_index, world_point3d *p0,
 world_point3d *p1, world_distance maximum_delta_height, world_distance height, world_distance *adjusted_floor_height,
 world_distance *adjusted_ceiling_height, short *supporting_polygon_index);

_fixed get_object_light_intensity(short object_index);

bool line_has_variable_height(short line_index);

void recalculate_map_counts(void);

bool change_polygon_height(short polygon_index, world_distance new_floor_height,
 world_distance new_ceiling_height, struct damage_definition *damage);

bool line_is_obstructed(short polygon_index1, world_point2d *p1, short polygon_index2, world_point2d *p2);
bool point_is_player_visible(short max_players, short polygon_index, world_point2d *p, int32 *distance);
bool point_is_monster_visible(short polygon_index, world_point2d *p, int32 *distance);

void turn_object_to_shit(short garbage_object_index);

void random_point_on_circle(world_point3d *center, short center_polygon_index,
 world_distance radius, world_point3d *random_point, short *random_polygon_index);

void calculate_line_midpoint(short line_index, world_point3d *midpoint);

void *get_map_structure_chunk(long chunk_size);
void reallocate_map_structure_memory(long size);
# 1225 "../Source_Files/GameWorld/map.h"
object_data *get_object_data(
 const short object_index);

polygon_data *get_polygon_data(
 const short polygon_index);

line_data *get_line_data(
 const short line_index);

side_data *get_side_data(
 const short side_index);

endpoint_data *get_endpoint_data(
 const short endpoint_index);

short *get_map_indexes(
 const short index,
 const short count);

ambient_sound_image_data *get_ambient_sound_image_data(
 const short ambient_sound_image_index);

random_sound_image_data *get_random_sound_image_data(
 const short random_sound_image_index);



short new_map_endpoint(world_point2d *where);
short duplicate_map_endpoint(short old_endpoint_index);
short new_map_line(short a, short b, short poly_a, short poly_b, short side_a, short side_b);
short duplicate_map_line(short old_line_index);
short new_map_polygon(short *line_indexes, short line_count, short floor_height,
 short ceiling_height, short floor_texture, short ceiling_texture, short lightsource_index);
void recalculate_side_type(short side_index);
short new_side(short polygon_index, short line_index);

void precalculate_map_indexes(void);

void touch_polygon(short polygon_index);
void recalculate_redundant_polygon_data(short polygon_index);
void recalculate_redundant_endpoint_data(short endpoint_index);
void recalculate_redundant_line_data(short line_index);
void recalculate_redundant_side_data(short side_index, short line_index);

void calculate_endpoint_polygon_owners(short endpoint_index, short *first_index, short *index_count);
void calculate_endpoint_line_owners(short endpoint_index, short *first_index, short *index_count);

void guess_side_lightsource_indexes(short side_index);

void set_map_index_buffer_size(long length);



uint8 *unpack_endpoint_data(uint8 *Stream, endpoint_data* Objects, size_t Count);
uint8 *pack_endpoint_data(uint8 *Stream, endpoint_data* Objects, size_t Count);
uint8 *unpack_line_data(uint8 *Stream, line_data* Objects, size_t Count);
uint8 *pack_line_data(uint8 *Stream, line_data* Objects, size_t Count);
uint8 *unpack_side_data(uint8 *Stream, side_data* Objects, size_t Count);
uint8 *pack_side_data(uint8 *Stream, side_data* Objects, size_t Count);
uint8 *unpack_polygon_data(uint8 *Stream, polygon_data* Objects, size_t Count);
uint8 *pack_polygon_data(uint8 *Stream, polygon_data* Objects, size_t Count);

uint8 *unpack_map_annotation(uint8 *Stream, map_annotation* Objects, size_t Count);
uint8 *pack_map_annotation(uint8 *Stream, map_annotation* Objects, size_t Count);
uint8 *unpack_map_object(uint8 *Stream, map_object* Objects, size_t Count);
uint8 *pack_map_object(uint8 *Stream, map_object* Objects, size_t Count);
uint8 *unpack_object_frequency_definition(uint8 *Stream, object_frequency_definition* Objects, size_t Count);
uint8 *pack_object_frequency_definition(uint8 *Stream, object_frequency_definition* Objects, size_t Count);
uint8 *unpack_static_data(uint8 *Stream, static_data* Objects, size_t Count);
uint8 *pack_static_data(uint8 *Stream, static_data* Objects, size_t Count);

uint8 *unpack_ambient_sound_image_data(uint8 *Stream, ambient_sound_image_data* Objects, size_t Count);
uint8 *pack_ambient_sound_image_data(uint8 *Stream, ambient_sound_image_data* Objects, size_t Count);
uint8 *unpack_random_sound_image_data(uint8 *Stream, random_sound_image_data* Objects, size_t Count);
uint8 *pack_random_sound_image_data(uint8 *Stream, random_sound_image_data* Objects, size_t Count);

uint8 *unpack_dynamic_data(uint8 *Stream, dynamic_data* Objects, size_t Count);
uint8 *pack_dynamic_data(uint8 *Stream, dynamic_data* Objects, size_t Count);
uint8 *unpack_object_data(uint8 *Stream, object_data* Objects, size_t Count);
uint8 *pack_object_data(uint8 *Stream, object_data* Objects, size_t Count);

uint8 *unpack_damage_definition(uint8 *Stream, damage_definition* Objects, size_t Count);
uint8 *pack_damage_definition(uint8 *Stream, damage_definition* Objects, size_t Count);
# 1318 "../Source_Files/GameWorld/map.h"
void load_placement_data(uint8 *_monsters, uint8 *_items);
struct object_frequency_definition *get_placement_info(void);
void place_initial_objects(void);
void recreate_objects(void);
void object_was_just_added(short object_class, short object_type);
void object_was_just_destroyed(short object_class, short object_type);
short get_random_player_starting_location_and_facing(short max_player_index, short team, struct object_location *location);

void mark_all_monster_collections(bool loading);
void load_all_monster_sounds(void);





void update_lightsources(void);
short new_lightsource_from_old(short old_source);
void entered_polygon(short index);
void left_polygon(short index);

void change_light_state(size_t lightsource_index, short state);



void mark_control_panel_shapes(bool load);
void initialize_control_panels_for_level(void);
void update_control_panels(void);

bool control_panel_in_environment(short control_panel_type, short environment_code);

void change_device_state(short device_index, bool active);
short new_device(world_point2d *location, short initial_polygon_index,
 short type, short extra_data, bool active);
void update_action_key(short player_index, bool triggered);

bool untoggled_repair_switches_on_level(void);

void assume_correct_switch_position(short switch_type, short permutation, bool new_state);

void try_and_toggle_control_panel(short polygon_index, short line_index);

bool line_side_has_control_panel(short line_index, short polygon_index, short *side_index_with_panel);



struct map_identifier {
 uint32 scenario_checksum;
 short level_index;
};

void set_to_default_map(void);



bool use_map_file(uint32 checksum);
bool load_level_from_map(short level_index);
uint32 get_current_map_checksum(void);
bool select_map_to_use(void);



short get_player_starting_location_and_facing(short team, short index,
 struct object_location *location);

void pause_game(void);
void resume_game(void);

bool get_indexed_entry_point(struct entry_point *entry_point, short *index, int32 type);
bool get_entry_points(vector<entry_point> &vec, int32 type);

bool new_game(short number_of_players, bool network,
 struct game_data *game_information,
 struct player_start_data *player_start_information,
 struct entry_point *entry_point);
bool goto_level(struct entry_point *entry, bool new_game);


XML_ElementParser *TextureLoading_GetParser();
# 29 "shell.cpp" 2
# 1 "../Source_Files/GameWorld/monsters.h" 1
# 58 "../Source_Files/GameWorld/monsters.h"
enum
{
 _pass_one_zone_border= 0x0001,
 _passed_zone_border= 0x0002,
 _activate_invisible_monsters= 0x0004,
 _activate_deaf_monsters= 0x0008,
 _pass_solid_lines= 0x0010,
 _use_activation_biases= 0x0020,
 _activation_cannot_be_avoided= 0x0040
};


enum
{
 _activate_on_player,
 _activate_on_nearest_hostile,
 _activate_on_goal,
 _activate_randomly
};
# 86 "../Source_Files/GameWorld/monsters.h"
enum
{
 _monster_marine,
 _monster_tick_energy,
 _monster_tick_oxygen,
 _monster_tick_kamakazi,
 _monster_compiler_minor,
 _monster_compiler_major,
 _monster_compiler_minor_invisible,
 _monster_compiler_major_invisible,
 _monster_fighter_minor,
 _monster_fighter_major,
 _monster_fighter_minor_projectile,
 _monster_fighter_major_projectile,
 _civilian_crew,
 _civilian_science,
 _civilian_security,
 _civilian_assimilated,
 _monster_hummer_minor,
 _monster_hummer_major,
 _monster_hummer_big_minor,
 _monster_hummer_big_major,
 _monster_hummer_possessed,
 _monster_cyborg_minor,
 _monster_cyborg_major,
 _monster_cyborg_flame_minor,
 _monster_cyborg_flame_major,
 _monster_enforcer_minor,
 _monster_enforcer_major,
 _monster_hunter_minor,
 _monster_hunter_major,
 _monster_trooper_minor,
 _monster_trooper_major,
 _monster_mother_of_all_cyborgs,
 _monster_mother_of_all_hunters,
 _monster_sewage_yeti,
 _monster_water_yeti,
 _monster_lava_yeti,
 _monster_defender_minor,
 _monster_defender_major,
 _monster_juggernaut_minor,
 _monster_juggernaut_major,
 _monster_tiny_fighter,
 _monster_tiny_bob,
 _monster_tiny_yeti,

 _civilian_fusion_crew,
 _civilian_fusion_science,
 _civilian_fusion_security,
 _civilian_fusion_assimilated,
 NUMBER_OF_MONSTER_TYPES
};
# 178 "../Source_Files/GameWorld/monsters.h"
enum
{
 _monster_is_stationary,
 _monster_is_waiting_to_attack_again,
 _monster_is_moving,
 _monster_is_attacking_close,
 _monster_is_attacking_far,
 _monster_is_being_hit,
 _monster_is_dying_hard,
 _monster_is_dying_soft,
 _monster_is_dying_flaming,
 _monster_is_teleporting,
 _monster_is_teleporting_in,
 _monster_is_teleporting_out,
 NUMBER_OF_MONSTER_ACTIONS
};



enum
{
 _monster_locked,
 _monster_losing_lock,
 _monster_lost_lock,
 _monster_unlocked,
 _monster_running,
 NUMBER_OF_MONSTER_MODES
};

enum
{
 _monster_was_promoted= 0x1,
 _monster_was_demoted= 0x2,
 _monster_has_never_been_activated= 0x4,
 _monster_is_blind= 0x8,
 _monster_is_deaf= 0x10,
 _monster_teleports_out_when_deactivated= 0x20
};

struct monster_data
{
 short type;
 short vitality;
 uint16 flags;

 short path;
 world_distance path_segment_length;
 world_distance desired_height;

 short mode, action;
 short target_index;
 world_distance external_velocity;
 world_distance vertical_velocity;
 short ticks_since_attack, attack_repetitions;
 short changes_until_lock_lost;

 world_distance elevation;

 short object_index;

 int32 ticks_since_last_activation;

 short activation_bias;

 short goal_polygon_index;


 world_point3d sound_location;
 short sound_polygon_index;

 short random_desired_height;

 short unused[7];
};
const int SIZEOF_monster_data = 64;

const int SIZEOF_monster_definition = 156;





extern vector<monster_data> MonsterList;






void initialize_monsters(void);
void initialize_monsters_for_new_level(void);

void move_monsters(void);

short new_monster(struct object_location *location, short monster_code);
void remove_monster(short monster_index);

void activate_monster(short monster_index);
void deactivate_monster(short monster_index);
short find_closest_appropriate_target(short aggressor_index, bool full_circle);

void mark_monster_collections(short type, bool loading);
void load_monster_sounds(short monster_type);

void monster_moved(short target_index, short old_polygon_index);
short legal_monster_move(short monster_index, angle facing, world_point3d *new_location);
short legal_player_move(short monster_index, world_point3d *new_location, world_distance *object_floor);


void change_monster_target(short monster_index, short target_index);
struct monster_definition *get_monster_definition_external(const short type);






bool possible_intersecting_monsters(vector<short> *IntersectedObjectsPtr, unsigned maximum_object_count, short polygon_index, bool include_scenery);


void get_monster_dimensions(short monster_index, world_distance *radius, world_distance *height);

void activate_nearby_monsters(short target_index, short caller_index, short flags);

void damage_monsters_in_radius(short primary_target_index, short aggressor_index, short aggressor_type,
 world_point3d *epicenter, short epicenter_polygon_index, world_distance radius, struct damage_definition *damage, short projectile_index);
void damage_monster(short monster_index, short aggressor_index, short aggressor_type, world_point3d *epicenter, struct damage_definition *damage, short projectile_index);

monster_data *get_monster_data(
 short monster_index);

bool bump_monster(short aggressor_index, short monster_index);

bool legal_polygon_height_change(short polygon_index, world_distance new_floor_height, world_distance new_ceiling_height, struct damage_definition *damage);
void adjust_monster_for_polygon_height_change(short monster_index, short polygon_index, world_distance new_floor_height, world_distance new_ceiling_height);
void accelerate_monster(short monster_index, angle direction, angle elevation, world_distance velocity);

void monster_died(short target_index);

short monster_placement_index(short monster_type);
short placement_index_to_monster_type(short placement_index);
void try_to_add_random_monster(short monster_type, bool activate);

short get_monster_impact_effect(short monster_index);
short get_monster_melee_impact_effect(short monster_index);

bool live_aliens_on_map(void);


void SetPlayerViewAttribs(int16 half_visual_arc, int16 half_vertical_visual_arc,
 world_distance visual_range, world_distance dark_visual_range);





uint8 *unpack_monster_data(uint8 *Stream, monster_data *Objects, size_t Count);
uint8 *pack_monster_data(uint8 *Stream, monster_data *Objects, size_t Count);
uint8 *unpack_monster_definition(uint8 *Stream, size_t Count);
uint8 *pack_monster_definition(uint8 *Stream, size_t Count);
void init_monster_definitions();

XML_ElementParser *DamageKicks_GetParser();
# 30 "shell.cpp" 2
# 1 "../Source_Files/GameWorld/player.h" 1
# 68 "../Source_Files/GameWorld/player.h"
# 1 "../Source_Files/GameWorld/map.h" 1
# 69 "../Source_Files/GameWorld/player.h" 2


# 1 "../Source_Files/GameWorld/weapons.h" 1
# 40 "../Source_Files/GameWorld/weapons.h"
enum {
 _weapon_fist,
 _weapon_pistol,
 _weapon_plasma_pistol,
 _weapon_assault_rifle,
 _weapon_missile_launcher,
 _weapon_flamethrower,
 _weapon_alien_shotgun,
 _weapon_shotgun,
 _weapon_ball,

 _weapon_smg,
 MAXIMUM_NUMBER_OF_WEAPONS,

 _weapon_doublefisted_pistols= MAXIMUM_NUMBER_OF_WEAPONS,
 _weapon_doublefisted_shotguns,
 PLAYER_TORSO_SHAPE_COUNT
};

enum {
 _shape_weapon_idle,
 _shape_weapon_charging,
 _shape_weapon_firing,
        PLAYER_TORSO_WEAPON_ACTION_COUNT
};

enum {
 _primary_weapon,
 _secondary_weapon,
 NUMBER_OF_TRIGGERS
};

enum
{
 _position_low,
 _position_center,
 _position_high

};



struct weapon_display_information
{

 short collection, shape_index, low_level_shape_index;

 _fixed vertical_position, horizontal_position;
 short vertical_positioning_mode, horizontal_positioning_mode;
 short transfer_mode;
 _fixed transfer_phase;

 bool flip_horizontal, flip_vertical;


 short Frame, NextFrame;


 short Phase, Ticks;
};



enum
{
 MAXIMUM_SHELL_CASINGS= 4
};

struct trigger_data {
short state, phase;
short rounds_loaded;
short shots_fired, shots_hit;
short ticks_since_last_shot;
short ticks_firing;
uint16 sequence;
};

struct weapon_data {
 short weapon_type;
 uint16 flags;
 uint16 unused;
 struct trigger_data triggers[NUMBER_OF_TRIGGERS];
};

struct shell_casing_data
{
 short type;
 short frame;

 uint16 flags;

 _fixed x, y;
 _fixed vx, vy;
};

struct player_weapon_data {
 short current_weapon;
 short desired_weapon;
 struct weapon_data weapons[MAXIMUM_NUMBER_OF_WEAPONS];
 struct shell_casing_data shell_casings[MAXIMUM_SHELL_CASINGS];
};


const int SIZEOF_weapon_definition = 134;

const int SIZEOF_player_weapon_data = 472;



void initialize_weapon_manager(void);


void initialize_player_weapons_for_new_game(short player_index);


void initialize_player_weapons(short player_index);


void *get_weapon_array(void);
long calculate_weapon_array_length(void);


bool get_weapon_display_information(short *count,
 struct weapon_display_information *data);


void process_new_item_for_reloading(short player_index, short item_type);


void update_player_weapons(short player_index, uint32 action_flags);


void mark_weapon_collections(bool loading);


void discharge_charged_weapons(short player_index);



void check_player_weapons_for_environment_change(void);



void player_hit_target(short player_index, short weapon_identifier);


void get_player_weapon_mode_and_type(short player_index, short *shape_weapon_type,
 short *shape_mode);


short get_player_desired_weapon(short player_index);


short get_player_weapon_ammo_count(short player_index, short which_weapon, short which_trigger);


void debug_print_weapon_status(void);





uint8 *unpack_player_weapon_data(uint8 *Stream, size_t Count);
uint8 *pack_player_weapon_data(uint8 *Stream, size_t Count);
uint8 *unpack_weapon_definition(uint8 *Stream, size_t Count);
uint8 *pack_weapon_definition(uint8 *Stream, size_t Count);
void init_weapon_definitions();


size_t get_number_of_weapon_types();


XML_ElementParser *Weapons_GetParser();
# 72 "../Source_Files/GameWorld/player.h" 2
# 81 "../Source_Files/GameWorld/player.h"
enum
{
 NUMBER_OF_ITEMS= 64
};


struct player_settings_definition {

 short InitialEnergy;
 short InitialOxygen;
 short StrippedEnergy;

 short SingleEnergy;
 short DoubleEnergy;
 short TripleEnergy;

 _fixed PlayerSelfLuminosity;

 bool CanSwim;

 bool PlayerShotsGuided;
 short PlayerHalfVisualArc;
 short PlayerHalfVertVisualArc;
 float PlayerVisualRange;
 float PlayerDarkVisualRange;




 short OxygenDepletion;
 short OxygenReplenishment;
 short OxygenChange;

 short Vulnerability;
};

extern struct player_settings_definition player_settings;


enum
{
 _editor_model,
 _earth_gravity_model,
 _low_gravity_model
};

enum
{
 _player_stationary,
 _player_walking,
 _player_running,
 _player_sliding,
 _player_airborne,
 NUMBER_OF_PLAYER_ACTIONS
};

enum
{
 _violet_team,
 _red_team,
 _tan_team,
 _light_blue_team,
 _yellow_team,
 _brown_team,
 _blue_team,
 _green_team,
 NUMBER_OF_TEAM_COLORS
};

enum
{
 kTeamColorsStringSetID = 152
};
# 179 "../Source_Files/GameWorld/player.h"
enum
{
 _absolute_yaw_mode_bit,
 _turning_left_bit,
 _turning_right_bit,
 _sidestep_dont_turn_bit,
 _looking_left_bit,
 _looking_right_bit,
 _absolute_yaw_bit0,
 _absolute_yaw_bit1,

 _absolute_pitch_mode_bit,
 _looking_up_bit,
 _looking_down_bit,
 _looking_center_bit,
 _absolute_pitch_bit0,
 _absolute_pitch_bit1,

 _absolute_position_mode_bit,
 _moving_forward_bit,
 _moving_backward_bit,
 _run_dont_walk_bit,
 _look_dont_turn_bit,
 _absolute_position_bit0,
 _absolute_position_bit1,
 _absolute_position_bit2,

 _sidestepping_left_bit,
 _sidestepping_right_bit,
 _left_trigger_state_bit,
 _right_trigger_state_bit,
 _action_trigger_state_bit,
 _cycle_weapons_forward_bit,
 _cycle_weapons_backward_bit,
 _toggle_map_bit,
 _microphone_button_bit,
 _swim_bit,

 NUMBER_OF_ACTION_FLAG_BITS
};





enum
{
 _absolute_yaw_mode= 1<<_absolute_yaw_mode_bit,
 _turning_left= 1<<_turning_left_bit,
 _turning_right= 1<<_turning_right_bit,
 _sidestep_dont_turn= 1<<_sidestep_dont_turn_bit,
 _looking_left= 1<<_looking_left_bit,
 _looking_right= 1<<_looking_right_bit,

 _absolute_pitch_mode= 1<<_absolute_pitch_mode_bit,
 _looking_up= 1<<_looking_up_bit,
 _looking_down= 1<<_looking_down_bit,
 _looking_center= 1<<_looking_center_bit,
 _look_dont_turn= 1<<_look_dont_turn_bit,

 _absolute_position_mode= 1<<_absolute_position_mode_bit,
 _moving_forward= 1<<_moving_forward_bit,
 _moving_backward= 1<<_moving_backward_bit,
 _run_dont_walk= 1<<_run_dont_walk_bit,

 _sidestepping_left= 1<<_sidestepping_left_bit,
 _sidestepping_right= 1<<_sidestepping_right_bit,
 _left_trigger_state= 1<<_left_trigger_state_bit,
 _right_trigger_state= 1<<_right_trigger_state_bit,
 _action_trigger_state= 1<<_action_trigger_state_bit,
 _cycle_weapons_forward= 1<<_cycle_weapons_forward_bit,
 _cycle_weapons_backward= 1<<_cycle_weapons_backward_bit,
 _toggle_map= 1<<_toggle_map_bit,
 _microphone_button= 1<<_microphone_button_bit,
 _swim= 1<<_swim_bit,

 _turning= _turning_left|_turning_right,
 _looking= _looking_left|_looking_right,
 _moving= _moving_forward|_moving_backward,
 _sidestepping= _sidestepping_left|_sidestepping_right,
 _looking_vertically= _looking_up|_looking_down|_looking_center
};



enum
{
 _RECENTERING_BIT= 0x8000,
 _ABOVE_GROUND_BIT= 0x4000,
 _BELOW_GROUND_BIT= 0x2000,
 _FEET_BELOW_MEDIA_BIT= 0x1000,
 _HEAD_BELOW_MEDIA_BIT= 0x0800,
 _STEP_PERIOD_BIT= 0x0400
};

struct physics_variables
{
 _fixed head_direction;
 _fixed last_direction, direction, elevation, angular_velocity, vertical_angular_velocity;
 _fixed velocity, perpendicular_velocity;
 fixed_point3d last_position, position;
 _fixed actual_height;



 _fixed adjusted_pitch, adjusted_yaw;

 fixed_vector3d external_velocity;
 _fixed external_angular_velocity;

 _fixed step_phase;

 _fixed step_amplitude;

 _fixed floor_height;
 _fixed ceiling_height;
 _fixed media_height;

 int16 action;
 uint16 old_flags, flags;
};

enum {
 _player_doesnt_auto_recenter_flag= 0x0040,
 _player_doesnt_auto_switch_weapons_flag= 0x0080,
 _player_is_interlevel_teleporting_flag= 0x0100,
 _player_has_cheated_flag= 0x0200,
 _player_is_teleporting_flag= 0x0400,
 _player_has_map_open_flag= 0x0800,
 _player_is_totally_dead_flag= 0x1000,
 _player_is_zombie_flag= 0x2000,
 _player_is_dead_flag= 0x4000,
 _player_is_pfhortran_controlled_flag= 0x8000
};
# 355 "../Source_Files/GameWorld/player.h"
struct damage_record
{
 int32 damage;
 int16 kills;
};

struct player_data
{
 int16 identifier;
 int16 flags;

 int16 color;
 int16 team;
 char name[32 +1];


 world_point3d location;
 world_point3d camera_location;
 int16 camera_polygon_index;
 angle facing, elevation;
 int16 supporting_polygon_index;
 int16 last_supporting_polygon_index;


 int16 suit_energy, suit_oxygen;

 int16 monster_index;
 int16 object_index;


 int16 weapon_intensity_decay;
 _fixed weapon_intensity;


 int16 invisibility_duration;
 int16 invincibility_duration;
 int16 infravision_duration;
 int16 extravision_duration;


 int16 delay_before_teleport;
 int16 teleporting_phase;
 int16 teleporting_destination;
 int16 interlevel_teleport_phase;


 int16 items[NUMBER_OF_ITEMS];


 int16 interface_flags;
 int16 interface_decay;

 struct physics_variables variables;

 struct damage_record total_damage_given;
 struct damage_record damage_taken[8];
 struct damage_record monster_damage_taken, monster_damage_given;

 int16 reincarnation_delay;

 int16 control_panel_side_index;

 int32 ticks_at_last_successful_save;

 int32 netgame_parameters[2];

 bool netdead;




};

const int SIZEOF_player_data = 930;

const int SIZEOF_physics_constants = 104;


struct player_shape_definitions
{
 short collection;

 short dying_hard, dying_soft;
 short dead_hard, dead_soft;
 short legs[NUMBER_OF_PLAYER_ACTIONS];
 short torsos[PLAYER_TORSO_SHAPE_COUNT];
 short charging_torsos[PLAYER_TORSO_SHAPE_COUNT];
 short firing_torsos[PLAYER_TORSO_SHAPE_COUNT];
};





enum
{
 _target_is_platform,
 _target_is_control_panel,
 _target_is_unrecognized
};

short find_action_key_target(short player_index, world_distance range, short *target_type);



extern struct player_data *players;
extern struct damage_record team_damage_given[NUMBER_OF_TEAM_COLORS];
extern struct damage_record team_damage_taken[NUMBER_OF_TEAM_COLORS];
extern struct damage_record team_monster_damage_taken[NUMBER_OF_TEAM_COLORS];
extern struct damage_record team_monster_damage_given[NUMBER_OF_TEAM_COLORS];
extern struct damage_record team_friendly_fire[NUMBER_OF_TEAM_COLORS];


extern short local_player_index, current_player_index;
extern struct player_data *local_player, *current_player;




class ActionQueues;
extern ActionQueues* GetRealActionQueues();



void initialize_players(void);
void reset_action_queues(void);
void allocate_player_memory(void);

void set_local_player_index(short player_index);
void set_current_player_index(short player_index);

short new_player(short team, short color, short player_identifier);
void delete_player(short player_number);

void recreate_players_for_new_level(void);

void team_damage_from_player_data(void);




void update_players(ActionQueues* inActionQueuesToUse, bool inPredictive);

void walk_player_list(void);

void damage_player(short monster_index, short aggressor_index, short aggressor_type,
 struct damage_definition *damage, short projectile_index);

void mark_player_collections(bool loading);


player_shape_definitions* get_player_shape_definitions();

short player_identifier_to_player_index(short player_identifier);

player_data *get_player_data(
 const size_t player_index);

short monster_index_to_player_index(short monster_index);

short get_polygon_index_supporting_player(short player_index);

bool legal_player_powerup(short player_index, short item_index);
void process_player_powerup(short player_index, short item_index);

world_distance dead_player_minimum_polygon_height(short polygon_index);

bool try_and_subtract_player_item(short player_index, short item_type);



void initialize_player_physics_variables(short player_index);
void update_player_physics_variables(short player_index, uint32 action_flags, bool predictive);

void adjust_player_for_polygon_height_change(short monster_index, short polygon_index, world_distance new_floor_height,
 world_distance new_ceiling_height);
void accelerate_player(short monster_index, world_distance vertical_velocity, angle direction, world_distance velocity);

void kill_player_physics_variables(short player_index);

uint32 mask_in_absolute_positioning_information(uint32 action_flags, _fixed yaw, _fixed pitch, _fixed velocity);
void get_absolute_pitch_range(_fixed *minimum, _fixed *maximum);

void instantiate_absolute_positioning_information(short player_index, _fixed facing, _fixed elevation);
void get_binocular_vision_origins(short player_index, world_point3d *left, short *left_polygon_index,
 angle *left_angle, world_point3d *right, short *right_polygon_index, angle *right_angle);

_fixed get_player_forward_velocity_scale(short player_index);





uint8 *unpack_player_data(uint8 *Stream, player_data *Objects, size_t Count);
uint8 *pack_player_data(uint8 *Stream, player_data *Objects, size_t Count);
uint8 *unpack_physics_constants(uint8 *Stream, size_t Count);
uint8 *pack_physics_constants(uint8 *Stream, size_t Count);


size_t get_number_of_physics_models();



int get_ticks_since_local_player_in_terminal();


XML_ElementParser *Player_GetParser();
# 31 "shell.cpp" 2
# 1 "../Source_Files/RenderMain/render.h" 1
# 42 "../Source_Files/RenderMain/render.h"
# 1 "../Source_Files/GameWorld/world.h" 1
# 43 "../Source_Files/RenderMain/render.h" 2
# 1 "../Source_Files/RenderMain/textures.h" 1
# 31 "../Source_Files/RenderMain/textures.h"
enum
{
 _COLUMN_ORDER_BIT= 0x8000,
 _TRANSPARENT_BIT= 0x4000,
 _PATCHED_BIT= 0x2000,
};

struct bitmap_definition
{
 int16 width, height;
 int16 bytes_per_row;

 int16 flags;
 int16 bit_depth;

 int16 unused[8];

 pixel8 *row_addresses[1];
};
const int SIZEOF_bitmap_definition = 30;




pixel8 *calculate_bitmap_origin(struct bitmap_definition *bitmap);


void precalculate_bitmap_row_addresses(struct bitmap_definition *texture);

void map_bytes(byte *buffer, byte *table, long size);
void remap_bitmap(struct bitmap_definition *bitmap, pixel8 *table);
# 44 "../Source_Files/RenderMain/render.h" 2

# 1 "../Source_Files/RenderOther/ViewControl.h" 1
# 45 "../Source_Files/RenderOther/ViewControl.h"
# 1 "../Source_Files/RenderOther/FontHandler.h" 1
# 43 "../Source_Files/RenderOther/FontHandler.h"
# 1 "../Source_Files/RenderOther/sdl_fonts.h" 1
# 31 "../Source_Files/RenderOther/sdl_fonts.h"
# 1 "../Source_Files/Files/FileHandler.h" 1
# 67 "../Source_Files/Files/FileHandler.h"
# 1 "../Source_Files/Files/tags.h" 1
# 71 "../Source_Files/Files/tags.h"
enum Typecode {
 _typecode_unknown= NONE,
 _typecode_creator= 0,
 _typecode_scenario,
 _typecode_savegame,
 _typecode_film,
 _typecode_physics,
 _typecode_shapes,
 _typecode_sounds,
 _typecode_patch,
 _typecode_images,
 _typecode_preferences,
 _typecode_music,
 _typecode_theme,
 _typecode_netscript,
 NUMBER_OF_TYPECODES
};



void initialize_typecodes();


uint32 get_typecode(Typecode which);
void set_typecode(Typecode which, uint32 _type);
# 68 "../Source_Files/Files/FileHandler.h" 2

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 70 "../Source_Files/Files/FileHandler.h" 2


# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 73 "../Source_Files/Files/FileHandler.h" 2
using namespace std;


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/errno.h" 1 3




typedef int error_t;



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/errno.h" 1 3




extern "C" {







extern int *__errno (void);




extern const char * const _sys_errlist[];
extern int _sys_nerr;
# 156 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/errno.h" 3
}
# 10 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/errno.h" 2 3
# 77 "../Source_Files/Files/FileHandler.h" 2



using std::string;
using std::vector;
# 97 "../Source_Files/Files/FileHandler.h"
const short RefNum_Closed = -1;






class OpenedFile
{

 friend class FileSpecifier;

public:
 bool IsOpen();
 bool Close();

 bool GetPosition(long& Position);
 bool SetPosition(long Position);

 bool GetLength(long& Length);
 bool SetLength(long Length);

 bool Read(long Count, void *Buffer);
 bool Write(long Count, void *Buffer);

 OpenedFile();
 ~OpenedFile() {Close();}
# 137 "../Source_Files/Files/FileHandler.h"
 int GetError() {return err;}
 SDL_RWops *GetRWops() {return f;}
 SDL_RWops *TakeRWops();

private:
 SDL_RWops *f;
 int err;

 bool is_forked;
 long fork_offset, fork_length;
};







class LoadedResource
{

 friend class OpenedResourceFile;

public:

 bool IsLoaded();


 void Unload();


 size_t GetLength();


 void *GetPointer(bool DoDetach = false);



 void SetData(void *data, size_t length);

 LoadedResource();
 ~LoadedResource() {Unload();}

private:


 void Detach();

public:
# 202 "../Source_Files/Files/FileHandler.h"
 void *p;
 size_t size;

};







class OpenedResourceFile
{

 friend class FileSpecifier;

public:






 bool Push();
 bool Pop();





 bool Check(uint32 Type, int16 ID);
 bool Check(uint8 t1, uint8 t2, uint8 t3, uint8 t4, int16 ID) {return Check((((uint32)(t1) << 24) | ((uint32)(t2) << 16) | ((uint32)(t3) << 8) | (uint32)(t4)), ID);}
 bool Get(uint32 Type, int16 ID, LoadedResource& Rsrc);
 bool Get(uint8 t1, uint8 t2, uint8 t3, uint8 t4, int16 ID, LoadedResource& Rsrc) {return Get((((uint32)(t1) << 24) | ((uint32)(t2) << 16) | ((uint32)(t3) << 8) | (uint32)(t4)), ID, Rsrc);}
# 246 "../Source_Files/Files/FileHandler.h"
 bool IsOpen();
 bool Close();

 OpenedResourceFile();
 ~OpenedResourceFile() {Close();}
# 268 "../Source_Files/Files/FileHandler.h"
 int GetError() {return err;}

private:
 int err;

 SDL_RWops *f, *saved_f;
};
# 325 "../Source_Files/Files/FileHandler.h"
struct dir_entry {
 dir_entry() {}
 dir_entry(const string &n, long s, bool is_dir, bool is_vol = false)
  : name(n), size(s), is_directory(is_dir), is_volume(is_vol) {}
 dir_entry(const dir_entry &other)
  : name(other.name), size(other.size), is_directory(other.is_directory), is_volume(other.is_volume) {}
 ~dir_entry() {}

 const dir_entry &operator=(const dir_entry &other)
 {
  if (this != &other) {
   name = other.name;
   size = other.size;
   is_directory = other.is_directory;
   is_volume = other.is_volume;
  }
  return *this;
 }

 bool operator<(const dir_entry &other) const
 {
  if (is_directory == other.is_directory)
   return name < other.name;
  else
   return is_directory > other.is_directory;
 }

 string name;
 long size;
 bool is_directory;
 bool is_volume;
};
# 378 "../Source_Files/Files/FileHandler.h"
class FileSpecifier
{
public:




 void GetName(char *Name) const;
# 399 "../Source_Files/Files/FileHandler.h"
 bool SetNameWithPath(const char *NameWithPath);


 void ToDirectory(FileSpecifier& Dir);
 void FromDirectory(FileSpecifier& Dir);




 bool Create(Typecode Type);


 bool Open(OpenedFile& OFile, bool Writable=false);


 bool Open(OpenedResourceFile& OFile, bool Writable=false);



 bool ReadDialog(Typecode Type, const char *Prompt=__null);
 bool WriteDialog(Typecode Type, const char *Prompt=__null, const char *DefaultName=__null);



 bool WriteDialogAsync(Typecode Type, char *Prompt=__null, char *DefaultName=__null);


 bool Exists();

 bool IsDir();



 TimeType GetDate();



 Typecode GetType();


 bool GetFreeSpace(unsigned long& FreeSpace);


 bool CopyContents(FileSpecifier& File);



 bool Exchange(FileSpecifier& File);


 bool Delete();


 const FileSpecifier &operator=(const FileSpecifier &other);


 const char *GetPath(void) const {return name.c_str();}
# 497 "../Source_Files/Files/FileHandler.h"
 FileSpecifier();
 FileSpecifier(const string &s) : name(s), err(0) {canonicalize_path();}
 FileSpecifier(const char *s) : name(s), err(0) {canonicalize_path();}
 FileSpecifier(const FileSpecifier &other) : name(other.name), err(other.err) {}

 bool operator==(const FileSpecifier &other) const {return name == other.name;}
 bool operator!=(const FileSpecifier &other) const {return name != other.name;}

 void SetToLocalDataDir();
 void SetToPreferencesDir();
 void SetToSavedGamesDir();
 void SetToRecordingsDir();
 void SetToFirstDataDir();

 void AddPart(const string &part);
 FileSpecifier &operator+=(const FileSpecifier &other) {AddPart(other.name); return *this;}
 FileSpecifier &operator+=(const string &part) {AddPart(part); return *this;}
 FileSpecifier &operator+=(const char *part) {AddPart(string(part)); return *this;}
 FileSpecifier operator+(const FileSpecifier &other) const {FileSpecifier a(name); a.AddPart(other.name); return a;}
 FileSpecifier operator+(const string &part) const {FileSpecifier a(name); a.AddPart(part); return a;}
 FileSpecifier operator+(const char *part) const {FileSpecifier a(name); a.AddPart(string(part)); return a;}

 void SplitPath(string &base, string &part) const;
 void SplitPath(FileSpecifier &base, string &part) const {string b; SplitPath(b, part); base = b;}

 bool CreateDirectory();
 bool ReadDirectory(vector<dir_entry> &vec);

 int GetError() const {return err;}

private:
 void canonicalize_path(void);

 string name;
 int err;


};
# 32 "../Source_Files/RenderOther/sdl_fonts.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 35 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h" 2



extern "C" {
# 67 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
extern const SDL_version * TTF_Linked_Version(void);
# 77 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
extern void TTF_ByteSwappedUNICODE(int swapped);


typedef struct _TTF_Font TTF_Font;


extern int TTF_Init(void);





extern TTF_Font * TTF_OpenFont(const char *file, int ptsize);
extern TTF_Font * TTF_OpenFontIndex(const char *file, int ptsize, long index);
extern TTF_Font * TTF_OpenFontRW(SDL_RWops *src, int freesrc, int ptsize);
extern TTF_Font * TTF_OpenFontIndexRW(SDL_RWops *src, int freesrc, int ptsize, long index);
# 102 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
extern int TTF_GetFontStyle(TTF_Font *font);
extern void TTF_SetFontStyle(TTF_Font *font, int style);


extern int TTF_FontHeight(TTF_Font *font);




extern int TTF_FontAscent(TTF_Font *font);




extern int TTF_FontDescent(TTF_Font *font);


extern int TTF_FontLineSkip(TTF_Font *font);


extern long TTF_FontFaces(TTF_Font *font);


extern int TTF_FontFaceIsFixedWidth(TTF_Font *font);
extern char * TTF_FontFaceFamilyName(TTF_Font *font);
extern char * TTF_FontFaceStyleName(TTF_Font *font);





extern int TTF_GlyphMetrics(TTF_Font *font, Uint16 ch,
         int *minx, int *maxx,
                                     int *miny, int *maxy, int *advance);


extern int TTF_SizeText(TTF_Font *font, const char *text, int *w, int *h);
extern int TTF_SizeUTF8(TTF_Font *font, const char *text, int *w, int *h);
extern int TTF_SizeUNICODE(TTF_Font *font, const Uint16 *text, int *w, int *h);







extern SDL_Surface * TTF_RenderText_Solid(TTF_Font *font,
    const char *text, SDL_Color fg);
extern SDL_Surface * TTF_RenderUTF8_Solid(TTF_Font *font,
    const char *text, SDL_Color fg);
extern SDL_Surface * TTF_RenderUNICODE_Solid(TTF_Font *font,
    const Uint16 *text, SDL_Color fg);
# 162 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
extern SDL_Surface * TTF_RenderGlyph_Solid(TTF_Font *font,
     Uint16 ch, SDL_Color fg);






extern SDL_Surface * TTF_RenderText_Shaded(TTF_Font *font,
    const char *text, SDL_Color fg, SDL_Color bg);
extern SDL_Surface * TTF_RenderUTF8_Shaded(TTF_Font *font,
    const char *text, SDL_Color fg, SDL_Color bg);
extern SDL_Surface * TTF_RenderUNICODE_Shaded(TTF_Font *font,
    const Uint16 *text, SDL_Color fg, SDL_Color bg);
# 184 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
extern SDL_Surface * TTF_RenderGlyph_Shaded(TTF_Font *font,
    Uint16 ch, SDL_Color fg, SDL_Color bg);





extern SDL_Surface * TTF_RenderText_Blended(TTF_Font *font,
    const char *text, SDL_Color fg);
extern SDL_Surface * TTF_RenderUTF8_Blended(TTF_Font *font,
    const char *text, SDL_Color fg);
extern SDL_Surface * TTF_RenderUNICODE_Blended(TTF_Font *font,
    const Uint16 *text, SDL_Color fg);







extern SDL_Surface * TTF_RenderGlyph_Blended(TTF_Font *font,
      Uint16 ch, SDL_Color fg);
# 216 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h"
extern void TTF_CloseFont(TTF_Font *font);


extern void TTF_Quit(void);


extern int TTF_WasInit(void);







}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 233 "/usr/local/pspdev/psp/include/SDL/SDL_ttf.h" 2
# 34 "../Source_Files/RenderOther/sdl_fonts.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 1 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/user.hpp" 1 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/select_compiler_config.hpp" 1 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/compiler/gcc.hpp" 1 3
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/select_stdlib_config.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/select_stdlib_config.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/no_tr1/utility.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/no_tr1/utility.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/utility" 1 3
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/utility" 3
       
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/utility" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_relops.h" 1 3
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  namespace rel_ops
  {
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 101 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 114 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 127 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/utility" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/no_tr1/utility.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/select_stdlib_config.hpp" 2 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/stdlib/libstdcpp3.hpp" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/select_platform_config.hpp" 1 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/suffix.hpp" 1 3
# 433 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/config.hpp" 2 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/static_assert.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/static_assert.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/workaround.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/static_assert.hpp" 2 3
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/static_assert.hpp" 3
namespace boost{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };


template<int x> struct static_assert_test{};

}
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 2 3







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/utility/addressof.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/utility/addressof.hpp" 3
namespace boost {
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/utility/addressof.hpp" 3
template <typename T> T*

addressof(T& v)
{
  return reinterpret_cast<T*>(
       &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
}
# 56 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/utility/addressof.hpp" 3
}
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool_fwd.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool_fwd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/adl_barrier.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/adl_barrier.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/adl.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/adl.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/msvc.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/intel.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/gcc.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/workaround.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/adl_barrier.hpp" 2 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/adl_barrier.hpp" 3
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool_fwd.hpp" 2 3

namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c_tag.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c_tag.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/static_constant.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c_tag.hpp" 2 3

namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bool.hpp" 2 3


namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 2 3
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 3
namespace boost
{

template<class T> class reference_wrapper
{
public:
    typedef T type;







    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}



    operator T& () const { return *t_; }

    T& get() const { return *t_; }

    T* get_pointer() const { return t_; }

private:

    T* t_;
};







template<class T> inline reference_wrapper<T> const ref(T & t)
{
    return reference_wrapper<T>(t);
}

template<class T> inline reference_wrapper<T const> const cref(T const & t)
{
    return reference_wrapper<T const>(t);
}





template<typename T>
class is_reference_wrapper
    : public mpl::false_
{
};

template<typename T>
class unwrap_reference
{
 public:
    typedef T type;
};
# 106 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 3
template<typename T> class is_reference_wrapper< reference_wrapper<T> > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> > { public: typedef T type; };

template<typename T> class is_reference_wrapper< reference_wrapper<T> const > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> volatile > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const volatile > { public: typedef T type; };
# 176 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/ref.hpp" 3
}
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_const.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_const.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 10 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int_fwd.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int_fwd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/nttp_decl.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/nttp_decl.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/nttp.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/nttp_decl.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int_fwd.hpp" 2 3

namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/static_cast.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/cat.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/cat.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/config/config.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/cat.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/int.hpp" 2 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/template_arity_fwd.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/template_arity_fwd.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/preprocessor.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/comma_if.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/comma_if.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/punctuation/comma_if.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/if.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/if.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/iif.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/if.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/logical/bool.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/if.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/facilities/empty.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/punctuation/comma.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/comma_if.hpp" 2 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repeat.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repeat.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/repeat.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/repeat.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/debug/error.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/tuple/eat.hpp" 1 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repeat.hpp" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/inc.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/inc.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/arithmetic/inc.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/inc.hpp" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/lambda.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/lambda.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/ttp.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/lambda.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/ctps.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/lambda.hpp" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/overload_resolution.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/lambda_support.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_const.hpp" 2 3

namespace boost {
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_const.hpp" 3
template< typename T > struct add_const { typedef T const type; };






template< typename T > struct add_const<T&> { typedef T& type; };


}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_const.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_volatile.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_volatile.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_volatile.hpp" 2 3

namespace boost {
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_volatile.hpp" 3
template< typename T > struct add_volatile { typedef T volatile type; };






template< typename T > struct add_volatile<T&> { typedef T& type; };


}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_volatile.hpp" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_cv.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_cv.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_cv.hpp" 2 3

namespace boost {
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_cv.hpp" 3
template< typename T > struct add_cv { typedef T const volatile type; };






template< typename T > struct add_cv<T&> { typedef T& type; };


}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_cv.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/cv_traits_impl.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/cv_traits_impl.hpp" 3
namespace boost {
namespace detail {







template <typename T> struct cv_traits_imp {};

template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
# 92 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/cv_traits_impl.hpp" 3
}
}
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_reference.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_reference.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/config.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_reference.hpp" 2 3







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/integral_constant.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/integral_constant.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c_fwd.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c_fwd.hpp" 3
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c.hpp" 2 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/integral_c.hpp" 2 3




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/integral_constant.hpp" 2 3

namespace boost{




template <class T, T val>

struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};

template<> struct integral_constant<bool,true> : public mpl::true_
{







   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{







   typedef integral_constant<bool,false> type;
};

typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;

}
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_reference.hpp" 2 3

namespace boost {



template< typename T > struct is_reference : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_reference< T& > : ::boost::integral_constant<bool,true> { };
# 111 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_reference.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 114 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_reference.hpp" 2 3
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 2 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 2 3

namespace boost {







   template< typename T > struct is_const : ::boost::integral_constant<bool,::boost::detail::cv_traits_imp<T*>::is_const> { };

template< typename T > struct is_const< T& > : ::boost::integral_constant<bool,false> { };
# 137 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 140 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_const.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_volatile.hpp" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_volatile.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_volatile.hpp" 2 3

namespace boost {







   template< typename T > struct is_volatile : ::boost::integral_constant<bool,::boost::detail::cv_traits_imp<T*>::is_volatile> { };

template< typename T > struct is_volatile< T& > : ::boost::integral_constant<bool,false> { };
# 127 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_volatile.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 130 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_volatile.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/broken_compiler_spec.hpp" 1 3
# 95 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/broken_compiler_spec.hpp" 3















# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 2 3

namespace boost {



namespace detail {

template <typename T, bool is_vol>
struct remove_const_helper
{
    typedef T type;
};

template <typename T>
struct remove_const_helper<T, true>
{
    typedef T volatile type;
};


template <typename T>
struct remove_const_impl
{
    typedef typename remove_const_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_volatile<T>::value
        >::type type;
};

}



template< typename T > struct remove_const { typedef typename boost::detail::remove_const_impl<T>::type type; };
template< typename T > struct remove_const<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_const<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_const<T const volatile[N]> { typedef T volatile type[N]; };
# 74 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 77 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_const.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_volatile.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_volatile.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_volatile.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_volatile.hpp" 2 3

namespace boost {



namespace detail {

template <typename T, bool is_const>
struct remove_volatile_helper
{
    typedef T type;
};

template <typename T>
struct remove_volatile_helper<T,true>
{
    typedef T const type;
};

template <typename T>
struct remove_volatile_impl
{
    typedef typename remove_volatile_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_const<T>::value
        >::type type;
};

}



template< typename T > struct remove_volatile { typedef typename boost::detail::remove_volatile_impl<T>::type type; };
template< typename T > struct remove_volatile<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_volatile<T volatile[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_volatile<T const volatile[N]> { typedef T const type[N]; };
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_volatile.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 76 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_volatile.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_cv.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_cv.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_cv.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_cv.hpp" 2 3

namespace boost {




template< typename T > struct remove_cv { typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type; };
template< typename T > struct remove_cv<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_cv<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { typedef T type[N]; };
# 57 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_cv.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 60 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_cv.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/cv_traits.hpp" 2 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/function_traits.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/function_traits.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/false_result.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/false_result.hpp" 3
namespace boost {
namespace type_traits {


struct false_result
{
    template <typename T> struct result_
    {
        static const bool value = false;
    };
};

}}
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 1 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 3
namespace boost {
namespace type_traits {

template <class R>
struct is_function_ptr_helper
{
    static const bool value = false;
};




template <class R >
struct is_function_ptr_helper<R (*)()> { static const bool value = true; };

template <class R >
struct is_function_ptr_helper<R (*)( ...)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0 ...)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { static const bool value = true; };
# 203 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 3
}
}
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 2 3







namespace boost {
namespace detail {


template<bool is_ref = true>
struct is_function_chooser
    : ::boost::type_traits::false_result
{
};

template <>
struct is_function_chooser<false>
{
    template< typename T > struct result_
        : ::boost::type_traits::is_function_ptr_helper<T*>
    {
    };
};

template <typename T>
struct is_function_impl
    : is_function_chooser< ::boost::is_reference<T>::value >
        ::template result_<T>
{
};
# 80 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 3
}

template< typename T > struct is_function : ::boost::integral_constant<bool,::boost::detail::is_function_impl<T>::value> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 87 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_function.hpp" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/function_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_pointer.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_reference.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_reference.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_reference.hpp" 2 3

namespace boost {



template< typename T > struct remove_reference { typedef T type; };
template< typename T > struct remove_reference<T&> { typedef T type; };
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_reference.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_reference.hpp" 2 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_pointer.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_pointer.hpp" 2 3

namespace boost {

namespace detail {
# 55 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_pointer.hpp" 3
template <typename T>
struct add_pointer_impl
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};



}

template< typename T > struct add_pointer { typedef typename boost::detail::add_pointer_impl<T>::type type; };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_pointer.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/function_traits.hpp" 2 3

namespace boost {


namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const int arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const int arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const int arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const int arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const int arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const int arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const int arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const int arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const int arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const int arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const int arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
    public detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};
# 234 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/function_traits.hpp" 3
}
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 2 3



namespace boost {
namespace tuples {


struct null_type {};


namespace detail {
  inline const null_type cnull() { return null_type(); }





template <bool If, class Then, class Else> struct IF { typedef Then RET; };

template <class Then, class Else> struct IF<false, Then, Else> {
  typedef Else RET;
};

}


template <class HT, class TT> struct cons;



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type>
class tuple;


template<class T> struct length;



namespace detail {



template<class T>
class generate_error;




template< int N >
struct get_class {
  template<class RET, class HT, class TT >
  inline static RET get(const cons<HT, TT>& t)
  {





    return get_class<N-1>::template get<RET>(t.tail);

  }
  template<class RET, class HT, class TT >
  inline static RET get(cons<HT, TT>& t)
  {



    return get_class<N-1>::template get<RET>(t.tail);

  }
};

template<>
struct get_class<0> {
  template<class RET, class HT, class TT>
  inline static RET get(const cons<HT, TT>& t)
  {
    return t.head;
  }
  template<class RET, class HT, class TT>
  inline static RET get(cons<HT, TT>& t)
  {
    return t.head;
  }
};

}
# 140 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 3
template<int N, class T>
struct element
{
private:
  typedef typename T::tail_type Next;
public:
  typedef typename element<N-1, Next>::type type;
};
template<class T>
struct element<0,T>
{
  typedef typename T::head_type type;
};

template<int N, class T>
struct element<N, const T>
{
private:
  typedef typename T::tail_type Next;
  typedef typename element<N-1, Next>::type unqualified_type;
public:



  typedef typename boost::add_const<unqualified_type>::type type;


};
template<class T>
struct element<0,const T>
{



  typedef typename boost::add_const<typename T::head_type>::type type;

};
# 233 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 3
template <class T> struct access_traits {
  typedef const T& const_type;
  typedef T& non_const_type;

  typedef const typename boost::remove_cv<T>::type& parameter_type;






};

template <class T> struct access_traits<T&> {

  typedef T& const_type;
  typedef T& non_const_type;

  typedef T& parameter_type;
};



template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::non_const_type
get(cons<HT, TT>& c ) {



  return detail::get_class<N>::template

         get<
           typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type,
           HT,TT
         >(c);
}




template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::const_type
get(const cons<HT, TT>& c ) {



  return detail::get_class<N>::template

         get<
           typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type,
           HT,TT
         >(c);
}


namespace detail {







template <class T> class non_storeable_type {
  non_storeable_type();
};

template <class T> struct wrap_non_storeable_type {
  typedef typename IF<
    ::boost::is_function<T>::value, non_storeable_type<T>, T
  >::RET type;
};
template <> struct wrap_non_storeable_type<void> {
  typedef non_storeable_type<void> type;
};

}

template <class HT, class TT>
struct cons {

  typedef HT head_type;
  typedef TT tail_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;

  stored_head_type head;
  tail_type tail;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  typename access_traits<tail_type>::non_const_type
  get_tail() { return tail; }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  typename access_traits<tail_type>::const_type
  get_tail() const { return tail; }

  cons() : head(), tail() {}







  cons(typename access_traits<stored_head_type>::parameter_type h,
       const tail_type& t)
    : head (h), tail(t) {}

  template <class T1, class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (t1),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}

  template <class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( const null_type& , T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}


  template <class HT2, class TT2>
  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u ) {
    head=u.head; tail=u.tail; return *this;
  }



  cons& operator=(const cons& u) {
    head = u.head; tail = u.tail; return *this;
  }

  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u ) {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( length<cons>::value == 2 ) >)> boost_static_assert_typedef_388;
    head = u.first; tail.head = u.second; return *this;
  }


  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }
};

template <class HT>
struct cons<HT, null_type> {

  typedef HT head_type;
  typedef null_type tail_type;
  typedef cons<HT, null_type> self_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  null_type get_tail() { return null_type(); }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  const null_type get_tail() const { return null_type(); }


  cons() : head() {}

  cons(typename access_traits<stored_head_type>::parameter_type h,
       const null_type& = null_type())
    : head (h) {}

  template<class T1>
  cons(T1& t1, const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head (t1) {}

  cons(const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head () {}

  template <class HT2>
  cons( const cons<HT2, null_type>& u ) : head(u.head) {}

  template <class HT2>
  cons& operator=(const cons<HT2, null_type>& u )
  { head = u.head; return *this; }



  cons& operator=(const cons& u) { head = u.head; return *this; }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
            >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }

};



template<class T>
struct length {
  static const int value = 1 + length<typename T::tail_type>::value;
};

template<>
struct length<tuple<> > {
  static const int value = 0;
};

template<>
struct length<null_type> {
  static const int value = 0;
};


namespace detail {


template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
struct map_tuple_to_cons
{
  typedef cons<T0,
               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
                                          T6, T7, T8, T9, null_type>::type
              > type;
};


template <>
struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
{
  typedef null_type type;
};

}



template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>

class tuple :
  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
{
public:
  typedef typename
    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
  typedef typename inherited::head_type head_type;
  typedef typename inherited::tail_type tail_type;



  tuple() {}

  tuple(typename access_traits<T0>::parameter_type t0)
    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1)
    : inherited(t0, t1, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2)
    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3)
    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4)
    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5)
    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6)
    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8,
        typename access_traits<T9>::parameter_type t9)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}


  template<class U1, class U2>
  tuple(const cons<U1, U2>& p) : inherited(p) {}

  template <class U1, class U2>
  tuple& operator=(const cons<U1, U2>& k) {
    inherited::operator=(k);
    return *this;
  }

  template <class U1, class U2>
  tuple& operator=(const std::pair<U1, U2>& k) {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( length<tuple>::value == 2 ) >)> boost_static_assert_typedef_636;
    this->head = k.first;
    this->tail.head = k.second;
    return *this;
  }

};


template <>
class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> :
  public null_type
{
public:
  typedef null_type inherited;
};



namespace detail {

struct swallow_assign {

  template<typename T>
  swallow_assign const& operator=(const T&) const {
    return *this;
  }
};

}


detail::swallow_assign const ignore = detail::swallow_assign();
# 687 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 3
template<class T>
struct make_tuple_traits {
  typedef T type;







};
# 711 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/detail/tuple_basic.hpp" 3
template<class T>
struct make_tuple_traits<T&> {
  typedef typename
     detail::generate_error<T&>::
       do_not_use_with_reference_type error;
};





template<class T, int n> struct make_tuple_traits <T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n> struct make_tuple_traits<volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T>
struct make_tuple_traits<reference_wrapper<T> >{
  typedef T& type;
};

template<class T>
struct make_tuple_traits<const reference_wrapper<T> >{
  typedef T& type;
};




namespace detail {



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type
>
struct make_tuple_mapper {
  typedef
    tuple<typename make_tuple_traits<T0>::type,
          typename make_tuple_traits<T1>::type,
          typename make_tuple_traits<T2>::type,
          typename make_tuple_traits<T3>::type,
          typename make_tuple_traits<T4>::type,
          typename make_tuple_traits<T5>::type,
          typename make_tuple_traits<T6>::type,
          typename make_tuple_traits<T7>::type,
          typename make_tuple_traits<T8>::type,
          typename make_tuple_traits<T9>::type> type;
};

}


inline tuple<> make_tuple() {
  return tuple<>();
}

template<class T0>
inline typename detail::make_tuple_mapper<T0>::type
make_tuple(const T0& t0) {
  typedef typename detail::make_tuple_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
inline typename detail::make_tuple_mapper<T0, T1>::type
make_tuple(const T0& t0, const T1& t1) {
  typedef typename detail::make_tuple_mapper<T0, T1>::type t;
  return t(t0, t1);
}

template<class T0, class T1, class T2>
inline typename detail::make_tuple_mapper<T0, T1, T2>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}

template<class T0, class T1, class T2, class T3>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}

template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8, const T9& t9) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}




template<class T1>
inline tuple<T1&> tie(T1& t1) {
  return tuple<T1&> (t1);
}

template<class T1, class T2>
inline tuple<T1&, T2&> tie(T1& t1, T2& t2) {
  return tuple<T1&, T2&> (t1, t2);
}

template<class T1, class T2, class T3>
inline tuple<T1&, T2&, T3&> tie(T1& t1, T2& t2, T3& t3) {
  return tuple<T1&, T2&, T3&> (t1, t2, t3);
}

template<class T1, class T2, class T3, class T4>
inline tuple<T1&, T2&, T3&, T4&> tie(T1& t1, T2& t2, T3& t3, T4& t4) {
  return tuple<T1&, T2&, T3&, T4&> (t1, t2, t3, t4);
}

template<class T1, class T2, class T3, class T4, class T5>
inline tuple<T1&, T2&, T3&, T4&, T5&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5) {
  return tuple<T1&, T2&, T3&, T4&, T5&> (t1, t2, t3, t4, t5);
}

template<class T1, class T2, class T3, class T4, class T5, class T6>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&> (t1, t2, t3, t4, t5, t6);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&> (t1, t2, t3, t4, t5, t6, t7);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7,
         class T8>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7, T8& t8) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&>
           (t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7,
         class T8, class T9>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7, T8& t8,
           T9& t9) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&>
            (t1, t2, t3, t4, t5, t6, t7, t8, t9);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7,
         class T8, class T9, class T10>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&, T10&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7, T8& t8,
           T9& t9, T10& t10) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&, T10&>
           (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
}

}
}
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 2 3



namespace boost {

using tuples::tuple;
using tuples::make_tuple;
using tuples::tie;

using tuples::get;
# 87 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/tuple/tuple.hpp" 3
}
# 35 "../Source_Files/RenderOther/sdl_fonts.h" 2
# 44 "../Source_Files/RenderOther/sdl_fonts.h"
class font_info {
 friend void unload_font(font_info *font);
public:
 virtual uint16 get_ascent(void) const = 0;
 virtual uint16 get_height(void) const = 0;
 virtual uint16 get_line_height(void) const = 0;
 virtual uint16 get_descent(void) const = 0;
 virtual int16 get_leading(void) const = 0;

 int draw_text(SDL_Surface *s, const char *text, size_t length, int x, int y, uint32 pixel, uint16 style, bool utf8 = false) const;
 uint16 text_width(const char *text, size_t length, uint16 style, bool utf8 = false) const;
 uint16 text_width(const char *text, uint16 style, bool utf8 = false) const;
 int trunc_text(const char *text, int max_width, uint16 style) const;
 virtual int8 char_width(uint8 c, uint16 style) const = 0;

 int draw_styled_text(SDL_Surface *s, const std::string& text, size_t length, int x, int y, uint32 pixel, uint16 initial_style, bool utf = false) const;
 int styled_text_width(const std::string& text, size_t length, uint16 initial_style, bool utf8 = false) const;
 int trunc_styled_text(const std::string& text, int max_width, uint16 style) const;
 std::string style_at(const std::string& text, std::string::const_iterator pos, uint16 style) const;

protected:
 virtual int _draw_text(SDL_Surface *s, const char *text, size_t length, int x, int y, uint32 pixel, uint16 style, bool utf8) const = 0;
 virtual uint16 _text_width(const char *text, size_t length, uint16 style, bool utf8) const = 0;
 virtual uint16 _text_width(const char *text, uint16 style, bool utf8) const = 0;
 virtual int _trunc_text(const char *text, int max_width, uint16 style) const = 0;
private:

 virtual void _unload() = 0;
};


class sdl_font_info : public font_info {
 friend sdl_font_info *load_sdl_font(const TextSpec &spec);
 friend void unload_sdl_font(sdl_font_info *font);

public:
 sdl_font_info() : first_character(0), last_character(0),
  ascent(0), descent(0), leading(0), pixmap(__null), ref_count(0) {}
 ~sdl_font_info() {if (pixmap) free(pixmap);}

 uint16 get_ascent(void) const {return ascent;}
 uint16 get_height(void) const {return ascent + descent;}
 uint16 get_line_height(void) const {return ascent + descent + leading;}
 uint16 get_descent(void) const {return descent; }
 int16 get_leading(void) const { return leading;}

 uint8 first_character, last_character;
 int16 maximum_kerning;
 int16 rect_width, rect_height;
 uint16 ascent, descent;
 int16 leading;

 uint8 *pixmap;
 int bytes_per_row;

 uint16 *location_table;
 int8 *width_table;

 int8 char_width(uint8 c, uint16 style) const;

protected:
 virtual int _draw_text(SDL_Surface *s, const char *text, size_t length, int x, int y, uint32 pixel, uint16 style, bool utf8) const;
 virtual uint16 _text_width(const char *text, size_t length, uint16 style, bool utf8) const;
 virtual uint16 _text_width(const char *text, uint16 style, bool utf8) const;
 virtual int _trunc_text(const char *text, int max_width, uint16 style) const;
private:
 virtual void _unload();
 int ref_count;
 LoadedResource rsrc;
};


typedef boost::tuple<std::string, uint16, int16> ttf_font_key_t;

class ttf_font_info : public font_info {
public:
 uint16 get_ascent() const { return TTF_FontAscent(m_styles[styleNormal]); };
 uint16 get_height() const { return TTF_FontHeight(m_styles[styleNormal]); };
 uint16 get_line_height() const { return max(TTF_FontLineSkip(m_styles[styleNormal]), TTF_FontHeight(m_styles[styleNormal])) + m_adjust_height; }
 uint16 get_descent() const { return -TTF_FontDescent(m_styles[styleNormal]); }
 int16 get_leading() const { return get_line_height() - get_ascent() - get_descent(); }

 TTF_Font* m_styles[styleUnderline];
 ttf_font_key_t m_keys[styleUnderline];
 int m_adjust_height;

 int8 char_width(uint8, uint16) const;

 ttf_font_info() {
  for (int i = 0; i < styleUnderline; i++) { m_styles[i] = 0; }
 }
protected:
 virtual int _draw_text(SDL_Surface *s, const char *text, size_t length, int x, int y, uint32 pixel, uint16 style, bool utf8) const;
 virtual uint16 _text_width(const char *text, size_t length, uint16 style, bool utf8) const;
 virtual uint16 _text_width(const char *text, uint16 style, bool utf8) const;
 virtual int _trunc_text(const char *text, int max_width, uint16 style) const;
private:
 char *process_printable(const char *src, int len) const;
 uint16 *process_macroman(const char *src, int len) const;
 TTF_Font *get_ttf(uint16 style) const { return m_styles[style & (styleBold | styleItalic)]; }
 virtual void _unload();
};







extern void initialize_fonts(void);


extern font_info *load_font(const TextSpec &spec);


extern void unload_font(font_info *font);
# 44 "../Source_Files/RenderOther/FontHandler.h" 2
# 57 "../Source_Files/RenderOther/FontHandler.h"
struct screen_rectangle;

class FontSpecifier
{
public:
 enum {

  NameSetLen = 64
 };






 char NameSet[NameSetLen];
 short Size;
 short Style;
 short AdjustLineHeight;


 char File[NameSetLen];


 short Height;
 short LineSpacing;
 short Ascent, Descent, Leading;
 short Widths[256];





 font_info *Info;




 void Init();



 void Update();
# 108 "../Source_Files/RenderOther/FontHandler.h"
 int TextWidth(const char *Text);


 int CharWidth(char c) const { return Widths[static_cast<int>(c)]; }
# 130 "../Source_Files/RenderOther/FontHandler.h"
 bool operator==(FontSpecifier& F);
 bool operator!=(FontSpecifier& F)
  {return (!((*this) == F));}
 FontSpecifier& operator=(FontSpecifier& F);






 static char *FindNextName(char *NamePtr);



 static char *FindNameEnd(char *NamePtr);
# 159 "../Source_Files/RenderOther/FontHandler.h"
};




XML_ElementParser *Font_GetParser();





void Font_SetArray(FontSpecifier *FontList, int NumColors = 0);
# 46 "../Source_Files/RenderOther/ViewControl.h" 2




bool View_MapActive();


float View_FOV_Normal();
float View_FOV_ExtraVision();
float View_FOV_TunnelVision();



bool View_AdjustFOV(float& FOV, float FOV_Target);



bool View_FOV_FixHorizontalNotVertical();


bool View_DoFoldEffect();


bool View_DoStaticEffect();


bool View_DoInterlevelTeleportInEffects();


bool View_DoInterlevelTeleportOutEffects();


FontSpecifier& GetOnScreenFont();



struct LandscapeOptions
{


 short HorizExp;


 short VertExp;




 short OGL_AspRatExp;


 bool VertRepeat;


 angle Azimuth;




 LandscapeOptions(): HorizExp(1), VertExp(1), OGL_AspRatExp(0), VertRepeat(false), Azimuth(0) {}
};

LandscapeOptions *View_GetLandscapeOptions(shape_descriptor Desc);



XML_ElementParser *View_GetParser();
XML_ElementParser *Landscapes_GetParser();
# 46 "../Source_Files/RenderMain/render.h" 2
# 57 "../Source_Files/RenderMain/render.h"
enum
{
 _render_effect_fold_in,
 _render_effect_fold_out,


 _render_effect_explosion,



};

enum
{
 _shading_normal,
 _shading_infravision
};
# 83 "../Source_Files/RenderMain/render.h"
struct point2d
{
 short x, y;
};
typedef struct point2d point2d;

struct definition_header
{
 short tag;
 short clip_left, clip_right;
};

struct view_data
{



 float field_of_view;
 float target_field_of_view;
 short standard_screen_width;
 short screen_width, screen_height;
 short horizontal_scale, vertical_scale;

 short half_screen_width, half_screen_height;
 short world_to_screen_x, world_to_screen_y;
 short dtanpitch;
 angle half_cone;
 angle half_vertical_cone;

 world_vector2d untransformed_left_edge, untransformed_right_edge;
 world_vector2d left_edge, right_edge, top_edge, bottom_edge;

 short ticks_elapsed;
 uint32 tick_count;
 short origin_polygon_index;
 angle yaw, pitch, roll;
 world_point3d origin;
 _fixed maximum_depth_intensity;

 short shading_mode;

 short effect, effect_phase;
 short real_world_to_screen_x, real_world_to_screen_y;

 bool overhead_map_active;
 short overhead_map_scale;

 bool under_media_boundary;
 short under_media_index;

 bool terminal_mode_active;



 bool show_weapons_in_hand;


 bool tunnel_vision_active;



 angle landscape_yaw;
};
# 157 "../Source_Files/RenderMain/render.h"
enum
{
 _polygon_is_visible_bit,
 _endpoint_has_been_visited_bit,
 _endpoint_is_visible_bit,
 _side_is_visible_bit,
 _line_has_clip_data_bit,
 _endpoint_has_clip_data_bit,
 _endpoint_has_been_transformed_bit,
 NUMBER_OF_RENDER_FLAGS,

 _polygon_is_visible= 1<<_polygon_is_visible_bit,
 _endpoint_has_been_visited= 1<<_endpoint_has_been_visited_bit,
 _endpoint_is_visible= 1<<_endpoint_is_visible_bit,
 _side_is_visible= 1<<_side_is_visible_bit,
 _line_has_clip_data= 1<<_line_has_clip_data_bit,
 _endpoint_has_clip_data= 1<<_endpoint_has_clip_data_bit,
 _endpoint_has_been_transformed= 1<<_endpoint_has_been_transformed_bit
};



extern vector<uint16> RenderFlagList;






void allocate_render_memory(void);

void initialize_view_data(struct view_data *view);
void render_view(struct view_data *view, struct bitmap_definition *destination);

void start_render_effect(struct view_data *view, short effect);



void render_overhead_map(struct view_data *view);
void render_computer_interface(struct view_data *view);

# 1 "../Source_Files/RenderMain/scottish_textures.h" 1
# 45 "../Source_Files/RenderMain/scottish_textures.h"
# 1 "../Source_Files/RenderMain/shape_descriptors.h" 1
# 46 "../Source_Files/RenderMain/scottish_textures.h" 2



enum
{
 _tinted_transfer,



 _solid_transfer,

 _big_landscaped_transfer,
 _textured_transfer,
 _shadeless_transfer,
 _static_transfer



};







struct tint_table8
{
 pixel8 index[256];
};

struct tint_table16
{
 pixel16 red[31 +1];
 pixel16 green[31 +1];
 pixel16 blue[31 +1];
};

struct tint_table32
{
 pixel32 red[255 +1];
 pixel32 green[255 +1];
 pixel32 blue[255 +1];
};






class OGL_ModelData;

struct rectangle_definition
{
 uint16 flags;

 struct bitmap_definition *texture;


 int16 x0, y0;
 int16 x1, y1;


 int16 clip_left, clip_right;
 int16 clip_top, clip_bottom;



 int32 depth;



 _fixed ambient_shade;


 void *shading_tables;



 int16 transfer_mode, transfer_data;


 bool flip_vertical, flip_horizontal;





 shape_descriptor ShapeDesc;
 uint16 LowLevelShape;



 int16 xc;


 float Opacity;


 _fixed ceiling_light;
 OGL_ModelData *ModelPtr;
 short ModelSequence, ModelFrame, NextModelFrame;
 float MixFrac;
 world_point3d Position;
 short ProjDistance;
 short Azimuth;
 float Scale;
 float HorizScale;
 short LiquidRelHeight;
 bool BelowLiquid;
 int LightDepth;
 float LightDirection[3];


 rectangle_definition() :
  LowLevelShape(0) {}
};

struct polygon_definition
{
 uint16 flags;

 struct bitmap_definition *texture;


 _fixed ambient_shade;



 void *shading_tables;


 int16 transfer_mode, transfer_data;


 long_point3d origin;
 world_vector3d vector;


 int16 vertex_count;
 point2d vertices[((short)16)];



 shape_descriptor ShapeDesc;


 bool VoidPresent;
};



extern short bit_depth;
extern short interface_bit_depth;

extern short number_of_shading_tables, shading_table_fractional_bits, shading_table_size;



void allocate_texture_tables(void);
# 199 "../Source_Files/RenderMain/render.h" 2




void instantiate_rectangle_transfer_mode(view_data *view,
 rectangle_definition *rectangle, short transfer_mode, _fixed transfer_phase);

void instantiate_polygon_transfer_mode(view_data *view,
 polygon_definition *polygon, short transfer_mode, bool horizontal);




void ResetOverheadMap();
# 32 "shell.cpp" 2
# 1 "shell.h" 1
# 42 "shell.h"
class FileSpecifier;







enum
{
 refSCREEN_WINDOW= 1000
};

enum
{
 refPREFERENCES_DIALOG= 8000,
 refCONFIGURE_KEYBOARD_DIALOG,
 refNETWORK_SETUP_DIALOG,
 refNETWORK_GATHER_DIALOG,
 refNETWORK_JOIN_DIALOG,
 refNETWORK_CARNAGE_DIALOG,

 LAST_DIALOG_REFCON= refNETWORK_CARNAGE_DIALOG,
 FIRST_DIALOG_REFCON= refPREFERENCES_DIALOG
};





enum {
 strPROMPTS= 131,
 _save_game_prompt= 0,
 _save_replay_prompt,
 _select_replay_prompt,
 _default_prompt
};



struct screen_mode_data
{
 short size;
 short acceleration;

 bool high_resolution;
 bool fullscreen, fill_the_screen;
 bool draw_every_other_line;

 short bit_depth;
 short gamma_level;

 short unused[8];
};
# 105 "shell.h"
enum
{
 _keyboard_or_game_pad,
 _mouse_yaw_pitch,
 _mouse_yaw_velocity,
 _cybermaxx_input,
 _input_sprocket_only
};

struct system_information_data
{
 bool has_seven;
 bool has_ten;
 bool has_apple_events;
 bool appletalk_is_available;
 bool machine_is_68k;
 bool machine_is_68040;
 bool machine_is_ppc;
 bool machine_has_network_memory;
 bool machine_is_bluebox;
 bool sdl_networking_is_available;
};



extern struct system_information_data *system_information;
# 143 "shell.h"
void global_idle_proc(void);
# 166 "shell.h"
XML_ElementParser *Cheats_GetParser();


void LoadBaseMMLScripts();



void initialize_shape_handler(void);
# 192 "shell.h"
SDL_Surface *get_shape_surface(int shape, int collection = NONE, byte** outPointerToPixelData = __null, float inIllumination = -1.0f, bool inShrinkImage = false);


void open_shapes_file(FileSpecifier& File);



void _get_player_color(size_t color_index, RGBColor *color);
void _get_interface_color(size_t color_index, RGBColor *color);

void _get_player_color(size_t color_index, SDL_Color *color);
void _get_interface_color(size_t color_index, SDL_Color *color);
# 213 "shell.h"
void update_game_window(void);



void load_environment_from_preferences(void);



void screen_printf(const char *format, ...);
# 33 "shell.cpp" 2
# 1 "../Source_Files/Misc/interface.h" 1
# 57 "../Source_Files/Misc/interface.h"
class FileSpecifier;




enum
{
 filenameSHAPES8,
 filenameSHAPES16,
 filenameSOUNDS8,
 filenameSOUNDS16,
 filenamePREFERENCES,
 filenameDEFAULT_MAP,
 filenameDEFAULT_SAVE_GAME,
 filenameMARATHON_NAME,
 filenameMARATHON_RECORDING,
 filenamePHYSICS_MODEL,
 filenameMUSIC,
 filenameIMAGES,
 filenameMOVIE,
 filenameDEFAULT_THEME
};




enum
{
 badProcessor= 0,
 badQuickDraw,
 badSystem,
 badMemory,
 badMonitor,
 badExtraFileLocations,
 badSoundChannels,
 fileError,
 copyHasBeenModified,
 copyHasExpired,
 keyIsUsedForSound,
 keyIsUsedForMapZooming,
 keyIsUsedForScrolling,
 keyIsUsedAlready,
 outOfMemory,
 warningExternalPhysicsModel,
 warningExternalMapsFile,
 badReadMapGameError,
 badReadMapSystemError,
 badWriteMap,
 badSerialNumber,
 duplicateSerialNumbers,
 networkOnlySerialNumber,
 corruptedMap,
 checkpointNotFound,
 pictureNotFound,
 networkNotSupportedForDemo,
 serverQuitInCooperativeNetGame,
 unableToGracefullyChangeLevelsNet,
 cantFindMap,
 cantFindReplayMap,
 notEnoughNetworkMemory,
 luascriptconflict,
 replayVersionTooNew,
 keyScrollWheelDoesntWork
};

enum
{
 _animated1= 1,
 _animated2to8= 2,
 _animated3to4= 3,
 _animated4= 4,
 _animated5to8= 5,
 _animated8= 8,
 _animated3to5= 9,
 _unanimated= 10,
 _animated5= 11
};

enum
{
 _darkening_table
};

enum
{
 _wall_shape,
 _floor_or_ceiling_shape,
 _object_shape,
 _other_shape
};



enum
{
 _standard_keyboard_setup,
 _left_handed_keyboard_setup,
 _powerbook_keyboard_setup,
 NUMBER_OF_KEY_SETUPS,

 _custom_keyboard_setup = NONE
};
# 172 "../Source_Files/Misc/interface.h"
struct shape_information_data
{
 uint16 flags;

 _fixed minimum_light_intensity;

 short unused[5];

 short world_left, world_right, world_top, world_bottom;
 short world_x0, world_y0;
};

struct shape_animation_data
{
 int16 number_of_views;

 int16 frames_per_view, ticks_per_frame;
 int16 key_frame;

 int16 transfer_mode;
 int16 transfer_mode_period;

 int16 first_frame_sound, key_frame_sound, last_frame_sound;

 int16 pixels_to_world;

 int16 loop_frame;

 int16 unused[14];






 int16 low_level_shape_indexes[1];
};



enum {
 _single_player,
 _network_player,
 _demo,
 _replay,
 _replay_from_file,
 NUMBER_OF_PSEUDO_PLAYERS
};

enum {
 _display_intro_screens,
 _display_main_menu,
 _display_chapter_heading,
 _display_prologue,
 _display_epilogue,
 _display_credits,
 _display_intro_screens_for_demo,
 _display_quit_screens,
 NUMBER_OF_SCREENS,
 _game_in_progress= NUMBER_OF_SCREENS,
 _quit_game,
 _close_game,
 _switch_demo,
 _revert_game,
 _change_level,
 _begin_display_of_epilogue,
 _displaying_network_game_dialogs,
 NUMBER_OF_GAME_STATES
};

bool game_window_is_full_screen(void);
void set_change_level_destination(short level_number);
bool networking_available(void);
void free_and_unlock_memory(void);



void initialize_game_state(void);
void force_game_state_change(void);
bool player_controlling_game(void);

void toggle_suppression_of_background_tasks(void);
bool suppress_background_events(void);

void set_game_state(short new_state);
short get_game_state(void);
short get_game_controller(void);
bool current_netgame_allows_microphone();
void set_change_level_destination(short level_number);
bool check_level_change(void);
void pause_game(void);
void resume_game(void);
void portable_process_screen_click(short x, short y, bool cheatkeys_down);
void draw_menu_button_for_command(short index);
void update_interface_display(void);
bool idle_game_state(uint32 ticks);
void display_main_menu(void);
void do_menu_item_command(short menu_id, short menu_item, bool cheat);
bool interface_fade_finished(void);
void stop_interface_fade(void);
bool enabled_item(short item);
void paint_window_black(void);


void do_preferences(void);
short get_level_number_from_user(void);
void toggle_menus(bool game_started);
void install_network_microphone(void);
void remove_network_microphone(void);




size_t should_restore_game_networked();

void show_movie(short index);

void exit_networking(void);

void load_main_menu_buffers(short base_id);
bool main_menu_buffers_loaded(void);
void main_menu_bit_depth_changed(short base_id);
void free_main_menu_buffers(void);
void draw_main_menu(void);
void draw_menu_button(short index, bool pressed);


void hide_cursor(void);
void show_cursor(void);
bool mouse_still_down(void);
void get_mouse_position(short *x, short *y);
void set_drawing_clip_rectangle(short top, short left, short bottom, short right);


void *get_global_shading_table(void);

short get_shape_descriptors(short shape_type, shape_descriptor *buffer);



void extended_get_shape_bitmap_and_shading_table(short collection_code, short low_level_shape_index,
 struct bitmap_definition **bitmap, void **shading_tables, short shading_mode);


struct shape_information_data *extended_get_shape_information(short collection_code, short low_level_shape_index);

void get_shape_hotpoint(shape_descriptor texture, short *x0, short *y0);
struct shape_animation_data *get_shape_animation_data(shape_descriptor texture);
void process_collection_sounds(short colleciton_code, void (*process_sound)(short sound_index));



void mark_collection(short collection_code, bool loading);
void strip_collection(short collection_code);
void load_collections(bool with_progress_bar, bool is_opengl);
int count_replacement_collections();
void load_replacement_collections();
void unload_all_collections(void);

void set_shapes_patch_data(uint8 *data, size_t length);
uint8* get_shapes_patch_data(size_t &length);



bool is_collection_present(short collection_index);

short get_number_of_collection_frames(short collection_index);

short get_number_of_collection_bitmaps(short collection_index);

short get_bitmap_index(short collection_index, short low_level_shape_index);

struct rgb_color_value *get_collection_colors(short collection_index, short clut_number, int &num_colors);


struct low_level_shape_definition *get_low_level_shape_definition(short collection_index, short low_level_shape_index);



void setup_revert_game_info(struct game_data *game_info, struct player_start_data *start, struct entry_point *entry);
bool revert_game(void);
bool load_game(bool use_last_load);
bool save_game(void);
bool save_game_full_auto(bool inOverwriteRecent);
void restart_game(void);



long get_net_map_data_length(void *data);
bool process_net_map_data(void *data);
void *get_map_for_net_transfer(struct entry_point *entry);



void set_keyboard_controller_status(bool active);
bool get_keyboard_controller_status(void);
void pause_keyboard_controller(bool active);
long get_heartbeat_count(void);
void sync_heartbeat_count(void);
void process_action_flags(short player_identifier, const uint32 *action_flags, short count);
void rewind_recording(void);
void stop_recording(void);
void stop_replay(void);
void move_replay(void);
void check_recording_replaying(void);
short find_key_setup(short *keycodes);
void set_default_keys(short *keycodes, short which_default);
void set_keys(short *keycodes);
bool has_recording_file(void);
void increment_replay_speed(void);
void decrement_replay_speed(void);
void reset_recording_and_playback_queues(void);
uint32 parse_keymap(void);



bool handle_preferences_dialog(void);
void handle_load_game(void);
void handle_save_game(void);
bool handle_start_game(void);
bool quit_without_saving(void);


void scroll_inventory(short dy);



enum {
 kNetworkJoinFailedUnjoined,
        kNetworkJoinFailedJoined,
        kNetworkJoinedNewGame,
        kNetworkJoinedResumeGame
};

bool network_gather(bool inResumingGame);
int network_join(void);



void handle_microphone(bool triggered);



void reset_absolute_positioning_device(_fixed yaw, _fixed pitch, _fixed velocity);



void init_physics_wad_data();
void import_definition_structures(void);


bool configure_key_setup(short *keycodes);


void get_default_map_spec(FileSpecifier& File);
void get_default_physics_spec(FileSpecifier& File);
void get_default_sounds_spec(FileSpecifier& File);
void get_default_shapes_spec(FileSpecifier& File);
bool get_default_theme_spec(FileSpecifier& File);


void get_default_file_specs(FileSpecifier* outMapSpec, FileSpecifier* outShapesSpec, FileSpecifier* outSoundsSpec, FileSpecifier* outPhysicsSpec);


void ResetFieldOfView();


bool dont_switch_to_new_weapon();


bool dont_auto_recenter();



void standardize_player_behavior_modifiers();
void restore_custom_player_behavior_modifiers();



bool is_player_behavior_standard();


void ReloadViewContext();


XML_ElementParser *Infravision_GetParser();


XML_ElementParser *ControlPanels_GetParser();
# 34 "shell.cpp" 2
# 1 "../Source_Files/Sound/SoundManager.h" 1
# 26 "../Source_Files/Sound/SoundManager.h"
# 1 "../Source_Files/Files/FileHandler.h" 1
# 27 "../Source_Files/Sound/SoundManager.h" 2
# 1 "../Source_Files/Sound/SoundFile.h" 1
# 26 "../Source_Files/Sound/SoundFile.h"
# 1 "../Source_Files/Files/AStream.h" 1
# 30 "../Source_Files/Files/AStream.h"
namespace AStream
{
 enum _Aiostate { _M_aiostate_end = 1L << 16 };
 static const short _S_badbit = 0x01;
 static const short _S_failbit = 0x02;

 typedef _Aiostate iostate;
 static const iostate badbit = iostate(_S_badbit);
 static const iostate failbit = iostate(_S_failbit);
 static const iostate goodbit = iostate(0);

 class failure : public std::exception
 {
  public:
   failure(const std::string& __str) throw();
   failure(const failure &f);
   ~failure() throw();
   const char*
   what() const throw();

  private:
   char * _M_name;
 };

 template <typename T>
 class basic_astream
 {
 private:
  T *_M_stream_begin;
  T *_M_stream_end;
  iostate _M_state;
  iostate _M_exception;
 protected:
  T *_M_stream_pos;
  bool
  bound_check(uint32 __delta) throw(AStream::failure);

  uint32
  tell_pos() const
  { return _M_stream_pos - _M_stream_begin; }

  uint32
  max_pos() const
  { return _M_stream_end - _M_stream_begin; }

 public:
  iostate
  rdstate() const
  { return _M_state; }

  void
  setstate(iostate __state)
  { _M_state= iostate(this->rdstate() | __state); }

  bool
  good() const
  { return this->rdstate() == 0; }

  bool
  fail() const
  { return (this->rdstate() & (badbit | failbit)) != 0; }

  bool
  bad() const
  { return (this->rdstate() & badbit) != 0; }

  iostate
  exceptions() const
  { return _M_exception; }

  void
  exceptions(iostate except)
  { _M_exception= except; }

  basic_astream(T* __stream, uint32 __length, uint32 __offset) :
   _M_stream_begin(__stream),
   _M_stream_end(__stream + __length),
   _M_state(goodbit),
   _M_exception(failbit),
   _M_stream_pos(__stream + __offset)
  { if(_M_stream_pos > _M_stream_end) { this->setstate(badbit); } }

  virtual ~basic_astream() {};
 };
}



class AIStream : public AStream::basic_astream<const uint8>
{
public:
 AIStream(const uint8* __stream, uint32 __length, uint32 __offset) :
  AStream::basic_astream<const uint8>(__stream, __length, __offset) {}

 uint32
 tellg() const
 { return this->tell_pos(); }

 uint32
 maxg() const
 { return this->max_pos(); }

 AIStream&
 operator>>(uint8 &__value) throw(AStream::failure);

 AIStream&
 operator>>(int8 &__value) throw(AStream::failure);

 virtual AIStream&
   operator>>(bool &__value) throw(AStream::failure);

 virtual AIStream&
 operator>>(uint16 &__value) throw(AStream::failure) = 0;

 virtual AIStream&
 operator>>(int16 &__value) throw(AStream::failure) = 0;

 virtual AIStream&
 operator>>(uint32 &__value) throw(AStream::failure) = 0;

 virtual AIStream&
 operator>>(int32 &__value) throw(AStream::failure) = 0;

 AIStream&
 read(char *__ptr, uint32 __count) throw(AStream::failure);

 AIStream&
 read(unsigned char * __ptr, uint32 __count) throw(AStream::failure)
 { return read((char *) __ptr, __count); }

 AIStream&
 read(signed char * __ptr, uint32 __count) throw(AStream::failure)
 { return read((char *) __ptr, __count); }

 AIStream&
 ignore(uint32 __count) throw(AStream::failure);


 template<class T>
 inline AIStream&
 read(T* __list, uint32 __count) throw(AStream::failure)
 {
  T* ValuePtr = __list;
  for (unsigned int k=0; k<__count; k++)
   *this >> *(ValuePtr++);

  return *this;
 };

};

class AIStreamBE : public AIStream
{
public:
 AIStreamBE(const uint8* __stream, uint32 __length, uint32 __offset = 0) :
  AIStream(__stream, __length, __offset) {};

 AIStream&
 operator>>(uint8 &__value) throw(AStream::failure)
  { return AIStream::operator>>(__value); }

 AIStream&
 operator>>(int8 &__value) throw(AStream::failure)
  { return AIStream::operator>>(__value); }

 AIStream&
 operator>>(uint16 &__value) throw(AStream::failure);

 AIStream&
 operator>>(int16 &__value) throw(AStream::failure);

 AIStream&
 operator>>(uint32 &__value) throw(AStream::failure);

 AIStream&
 operator>>(int32 &__value) throw(AStream::failure);
};

class AIStreamLE : public AIStream
{
public:
 AIStreamLE(const uint8* __stream, uint32 __length, uint32 __offset = 0) :
  AIStream(__stream, __length, __offset) {};

   AIStream&
 operator>>(uint8 &__value) throw(AStream::failure)
  { return AIStream::operator>>(__value); }

 AIStream&
 operator>>(int8 &__value) throw(AStream::failure)
  { return AIStream::operator>>(__value); }

 AIStream&
 operator>>(uint16 &__value) throw(AStream::failure);

 AIStream&
 operator>>(int16 &__value) throw(AStream::failure);

 AIStream&
 operator>>(uint32 &__value) throw(AStream::failure);

 AIStream&
 operator>>(int32 &__value) throw(AStream::failure);
};



class AOStream : public AStream::basic_astream<uint8>
{
public:
 AOStream(uint8* __stream, uint32 __length, uint32 __offset) :
  AStream::basic_astream<uint8>(__stream, __length, __offset) {}

 uint32
 tellp() const
 { return this->tell_pos(); }

 uint32
 maxp() const
 { return this->max_pos(); }

 AOStream&
 operator<<(uint8 __value) throw(AStream::failure);

 AOStream&
 operator<<(int8 __value) throw(AStream::failure);

 virtual AOStream&
        operator<<(bool __value) throw (AStream::failure);

 virtual AOStream&
 operator<<(uint16 __value) throw(AStream::failure) = 0;

 virtual AOStream&
 operator<<(int16 __value) throw(AStream::failure) = 0;

 virtual AOStream&
 operator<<(uint32 __value) throw(AStream::failure) = 0;

 virtual AOStream&
 operator<<(int32 __value) throw(AStream::failure) = 0;


 AOStream&
 write(char *__ptr, uint32 __count) throw(AStream::failure);

 AOStream&
 write(unsigned char * __ptr, uint32 __count) throw(AStream::failure)
 { return write((char *) __ptr, __count); }

 AOStream&
 write(signed char * __ptr, uint32 __count) throw(AStream::failure)
 { return write((char *) __ptr, __count); }

 AOStream& ignore(uint32 __count) throw(AStream::failure);


 template<class T>
 inline AOStream&
 write(T* __list, uint32 __count) throw(AStream::failure)
 {
  T* ValuePtr = __list;
  for (unsigned int k=0; k<__count; k++)
   *this << *(ValuePtr++);

  return *this;
 }
};

class AOStreamBE: public AOStream
{
public:
 AOStreamBE(uint8* __stream, uint32 __length, uint32 __offset = 0) :
  AOStream(__stream, __length, __offset) {};

 AOStream&
 operator<<(uint8 __value) throw (AStream::failure)
  { return AOStream::operator<<(__value); }

 AOStream&
 operator<<(int8 __value) throw (AStream::failure)
  { return AOStream::operator<<(__value); }

 AOStream&
 operator<<(uint16 __value) throw(AStream::failure);

 AOStream&
 operator<<(int16 __value) throw(AStream::failure);

 AOStream&
 operator<<(uint32 __value) throw(AStream::failure);

 AOStream&
 operator<<(int32 __value) throw(AStream::failure);
};

class AOStreamLE: public AOStream
{
public:
 AOStreamLE(uint8* __stream, uint32 __length, uint32 __offset = 0) :
  AOStream(__stream, __length, __offset) {}

   AOStream&
 operator<<(uint8 __value) throw (AStream::failure)
  { return AOStream::operator<<(__value); }

 AOStream&
 operator<<(int8 __value) throw (AStream::failure)
  { return AOStream::operator<<(__value); }

 AOStream&
 operator<<(uint16 __value) throw(AStream::failure);

 AOStream&
 operator<<(int16 __value) throw(AStream::failure);

 AOStream&
 operator<<(uint32 __value) throw(AStream::failure);

 AOStream&
 operator<<(int32 __value) throw(AStream::failure);
};
# 27 "../Source_Files/Sound/SoundFile.h" 2
# 1 "../Source_Files/Files/FileHandler.h" 1
# 28 "../Source_Files/Sound/SoundFile.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 1 3
# 52 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 3
       
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 3





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tempbuf.h" 1 3
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 115 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (!__is_pod(_Tp) && _M_len > 0)
     std::uninitialized_fill_n(_M_buffer, _M_len, *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 59 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_raw_storage_iter.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 60 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 2 3
# 95 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 1 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
# 89 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 115 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 127 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 138 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 155 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 173 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 183 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 213 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 227 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 242 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 263 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;

}
# 96 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/memory" 2 3
# 29 "../Source_Files/Sound/SoundFile.h" 2


class SoundHeader
{
public:
 SoundHeader();
 virtual ~SoundHeader() { };
 bool Load(OpenedFile &SoundFile);
 bool Load(const uint8* data);


 uint8* Load(int32 length) {
  Clear();
  stored_data.resize(length);
  return &stored_data.front();
 }

 bool sixteen_bit;
 bool stereo;
 bool signed_8bit;
 int bytes_per_frame;
 bool little_endian;

 const uint8* Data() const
  { return stored_data.size() ? &stored_data.front() : data; }
 int32 Length() const
  { return stored_data.size() ? stored_data.size() : length; };

 int32 loop_start;
 int32 loop_end;

 uint32 rate;

 void Clear() { stored_data.clear(); data = 0; length = 0; }

private:
 bool UnpackStandardSystem7Header(AIStreamBE &header);
 bool UnpackExtendedSystem7Header(AIStreamBE &header);

 std::vector<uint8> stored_data;
 const uint8* data;
 int32 length;

};

class SoundDefinition
{
public:
 bool Unpack(OpenedFile &SoundFile);
 bool Load(OpenedFile &SoundFile, bool LoadPermutations);
 void Unload() { sounds.clear(); }

 static const int MAXIMUM_PERMUTATIONS_PER_SOUND = 5;

 int32 LoadedSize();

private:
 static int HeaderSize() { return 64; }

public:
 int16 sound_code;
 int16 behavior_index;
 uint16 flags;

 uint16 chance;


 _fixed low_pitch, high_pitch;


 int16 permutations;
 uint16 permutations_played;

 int32 group_offset, single_length, total_length;
 std::vector<int32> sound_offsets;

 uint32 last_played;

 std::vector<SoundHeader> sounds;
};

class SoundFile
{
public:
 bool Open(FileSpecifier &SoundFile);
 void Close();
 SoundDefinition* GetSoundDefinition(int source, int sound_index);
 void Load(int source, int sound_index);


 int NewCustomSoundDefinition();


 bool AddCustomSoundSlot(int index, const char* file);

 void UnloadCustomSounds();

public:
 int32 version;
 int32 tag;

 int16 source_count;
 int16 sound_count;
 int16 real_sound_count;

 static const int v1Unused = 124;

 std::vector< std::vector<SoundDefinition> > sound_definitions;

 static int HeaderSize() { return 260; }
 std::auto_ptr<OpenedFile> opened_sound_file;
};
# 28 "../Source_Files/Sound/SoundManager.h" 2



# 1 "../Source_Files/Sound/SoundManagerEnums.h" 1
# 29 "../Source_Files/Sound/SoundManagerEnums.h"
enum
{
 _ambient_snd_water,
 _ambient_snd_sewage,
 _ambient_snd_lava,
 _ambient_snd_goo,
 _ambient_snd_under_media,
 _ambient_snd_wind,
 _ambient_snd_waterfall,
 _ambient_snd_siren,
 _ambient_snd_fan,
 _ambient_snd_spht_door,
 _ambient_snd_spht_platform,
 _ambient_snd_heavy_spht_door,
 _ambient_snd_heavy_spht_platform,
 _ambient_snd_light_machinery,
 _ambient_snd_heavy_machinery,
 _ambient_snd_transformer,
 _ambient_snd_sparking_transformer,
 _ambient_snd_machine_binder,
 _ambient_snd_machine_bookpress,
 _ambient_snd_machine_puncher,
 _ambient_snd_electric,
 _ambient_snd_alarm,
 _ambient_snd_night_wind,
 _ambient_snd_pfhor_door,
 _ambient_snd_pfhor_platform,
 _ambient_snd_alien_noise1,
 _ambient_snd_alien_noise2,

 _ambient_snd_alien_harmonics,

 NUMBER_OF_AMBIENT_SOUND_DEFINITIONS
};

enum
{
 _random_snd_water_drip,
 _random_snd_surface_explosion,
 _random_snd_underground_explosion,
 _random_snd_owl,

 _random_snd_creak,

 NUMBER_OF_RANDOM_SOUND_DEFINITIONS
};

enum
{
 _snd_startup,
 _snd_teleport_in,
 _snd_teleport_out,
 _snd_body_being_crunched,

 _snd_creak,

 _snd_absorbed,

 _snd_breathing,
 _snd_oxygen_warning,
 _snd_suffocation,

 _snd_energy_refuel,
 _snd_oxygen_refuel,
 _snd_cant_toggle_switch,
 _snd_switch_on,
 _snd_switch_off,
 _snd_puzzle_switch,
 _snd_chip_insertion,
 _snd_pattern_buffer,
 _snd_destroy_control_panel,

 _snd_adjust_volume,
 _snd_got_powerup,
 _snd_got_item,

 _snd_bullet_ricochet,
 _snd_metallic_ricochet,
 _snd_empty_gun,

 _snd_spht_door_opening,
 _snd_spht_door_closing,
 _snd_spht_door_obstructed,

 _snd_spht_platform_starting,
 _snd_spht_platform_stopping,

 _snd_owl,

 _snd_smg_firing,
 _snd_smg_reloading,



 _snd_heavy_spht_platform_starting,
 _snd_heavy_spht_platform_stopping,

 _snd_fist_hitting,

 _snd_magnum_firing,
 _snd_magnum_reloading,

 _snd_assault_rifle_firing,
 _snd_grenade_launcher_firing,
 _snd_grenade_exploding,
 _snd_grenade_flyby,

 _snd_fusion_firing,
 _snd_fusion_exploding,
 _snd_fusion_flyby,
 _snd_fusion_charging,

 _snd_rocket_exploding,
 _snd_rocket_flyby,
 _snd_rocket_firing,

 _snd_flamethrower,

 _snd_body_falling,
 _snd_body_exploding,
 _snd_bullet_hitting_flesh,

 _snd_fighter_activate,
 _snd_fighter_wail,
 _snd_fighter_scream,
 _snd_fighter_chatter,
 _snd_fighter_attack,
 _snd_fighter_projectile_hit,
 _snd_fighter_projectile_flyby,

 _snd_compiler_attack,
 _snd_compiler_death,
 _snd_compiler_hit,
 _snd_compiler_projectile_flyby,
 _snd_compiler_projectile_hit,

 _snd_cyborg_moving,
 _snd_cyborg_attack,
 _snd_cyborg_hit,
 _snd_cyborg_death,
 _snd_cyborg_projectile_bounce,
 _snd_cyborg_projectile_hit,
 _snd_cyborg_projectile_flyby,

 _snd_hummer_activate,
 _snd_hummer_start_attack,
 _snd_hummer_attack,
 _snd_hummer_dying,
 _snd_hummer_death,
 _snd_hummer_projectile_hit,
 _snd_hummer_projectile_flyby,

 _snd_human_wail,
 _snd_human_scream,
 _snd_human_hit,
 _snd_human_chatter,
 _snd_assimilated_human_chatter,
 _snd_human_trash_talk,
 _snd_human_apology,
 _snd_human_activation,
 _snd_human_clear,
 _snd_human_stop_shooting_me_you_bastard,
 _snd_human_area_secure,
 _snd_kill_the_player,

 _snd_water,
 _snd_sewage,
 _snd_lava,
 _snd_goo,
 _snd_under_media,
 _snd_wind,
 _snd_waterfall,
 _snd_siren,
 _snd_fan,
 _snd_spht_door,
 _snd_spht_platform,

 _snd_alien_harmonics,

 _snd_heavy_spht_platform,
 _snd_light_machinery,
 _snd_heavy_machinery,
 _snd_transformer,
 _snd_sparking_transformer,

 _snd_water_drip,

 _snd_walking_in_water,
 _snd_exit_water,
 _snd_enter_water,
 _snd_small_water_splash,
 _snd_medium_water_splash,
 _snd_large_water_splash,

 _snd_walking_in_lava,
 _snd_enter_lava,
 _snd_exit_lava,
 _snd_small_lava_splash,
 _snd_medium_lava_splash,
 _snd_large_lava_splash,

 _snd_walking_in_sewage,
 _snd_exit_sewage,
 _snd_enter_sewage,
 _snd_small_sewage_splash,
 _snd_medium_sewage_splash,
 _snd_large_sewage_splash,

 _snd_walking_in_goo,
 _snd_exit_goo,
 _snd_enter_goo,
 _snd_small_goo_splash,
 _snd_medium_goo_splash,
 _snd_large_goo_splash,

 _snd_major_fusion_firing,
 _snd_major_fusion_charged,

 _snd_assault_rifle_reloading,
 _snd_assault_rifle_shell_casings,

 _snd_shotgun_firing,
 _snd_shotgun_reloading,

 _snd_ball_bounce,
 _snd_you_are_it,
 _snd_got_ball,

 _snd_computer_interface_logon,
 _snd_computer_interface_logout,
 _snd_computer_interface_page,

 _snd_heavy_spht_door,
 _snd_heavy_spht_door_opening,
 _snd_heavy_spht_door_closing,
 _snd_heavy_spht_door_open,
 _snd_heavy_spht_door_closed,
 _snd_heavy_spht_door_obstructed,

 _snd_hunter_activate,
 _snd_hunter_attack,
 _snd_hunter_dying,
 _snd_hunter_landing,
 _snd_hunter_exploding,
 _snd_hunter_projectile_hit,
 _snd_hunter_projectile_flyby,

 _snd_enforcer_activate,
 _snd_enforcer_attack,
 _snd_enforcer_projectile_hit,
 _snd_enforcer_projectile_flyby,

 _snd_yeti_melee_attack,
 _snd_yeti_melee_attack_hit,
 _snd_yeti_projectile_attack,
 _snd_yeti_projectile_sewage_attack_hit,
 _snd_yeti_projectile_sewage_flyby,
 _snd_yeti_projectile_lava_attack_hit,
 _snd_yeti_projectile_lava_flyby,
 _snd_yeti_dying,

 _snd_machine_binder,
 _snd_machine_bookpress,
 _snd_machine_puncher,
 _snd_electric,
 _snd_alarm,
 _snd_night_wind,

 _snd_surface_explosion,
 _snd_underground_explosion,

 _snd_defender_attack,
 _snd_defender_hit,
 _snd_defender_flyby,
 _snd_defender_being_hit,
 _snd_defender_exploding,

 _snd_tick_chatter,
 _snd_tick_falling,
 _snd_tick_flapping,
 _snd_tick_exploding,

 _snd_ceiling_lamp_exploding,

 _snd_pfhor_platform_starting,
 _snd_pfhor_platform_stopping,
 _snd_pfhor_platform,

 _snd_pfhor_door_opening,
 _snd_pfhor_door_closing,
 _snd_pfhor_door_obstructed,
 _snd_pfhor_door,

 _snd_pfhor_switch_off,
 _snd_pfhor_switch_on,

 _snd_juggernaut_firing,
 _snd_juggernaut_warning,
 _snd_juggernaut_exploding,
 _snd_juggernaut_preparing_to_fire,

 _snd_enforcer_exploding,

 _snd_alien_noise1,
 _snd_alien_noise2,



 _snd_civilian_fusion_wail,
 _snd_civilian_fusion_scream,
 _snd_civilian_fusion_hit,
 _snd_civilian_fusion_chatter,
 _snd_assimilated_civilian_fusion_chatter,
 _snd_civilian_fusion_trash_talk,
 _snd_civilian_fusion_apology,
 _snd_civilian_fusion_activation,
 _snd_civilian_fusion_clear,
 _snd_civilian_fusion_stop_shooting_me_you_bastard,
 _snd_civilian_fusion_area_secure,
 _snd_civilian_fusion_kill_the_player,

 NUMBER_OF_SOUND_DEFINITIONS
};

enum
{
 NUMBER_OF_SOUND_VOLUME_LEVELS= 8,

 MAXIMUM_SOUND_VOLUME_BITS= 8,
 MAXIMUM_SOUND_VOLUME= 1<<MAXIMUM_SOUND_VOLUME_BITS,
};

enum
{
 _8bit_22k_source,
 _16bit_22k_source,

 NUMBER_OF_SOUND_SOURCES
};

enum
{
 _stereo_flag= 0x0001,
 _dynamic_tracking_flag= 0x0002,
 _doppler_shift_flag= 0x0004,
 _ambient_sound_flag= 0x0008,
 _16bit_sound_flag= 0x0010,
 _more_sounds_flag= 0x0020,
 _relative_volume_flag = 0x0040,
 _extra_memory_flag= 0x0100,
 _extra_extra_memory_flag= 0x0200,
 _zero_restart_delay = 0x0400
};

enum
{
 _sound_was_obstructed= 0x0001,
 _sound_was_media_obstructed= 0x0002,
 _sound_was_media_muffled= 0x0004
};

enum
{
 _lower_frequency= (1L<<16)-(1L<<16)/8,
 _normal_frequency= (1L<<16),
 _higher_frequency= (1L<<16)+(1L<<16)/8
};
# 32 "../Source_Files/Sound/SoundManager.h" 2

struct ambient_sound_data;

class SoundManager
{
public:
 static inline SoundManager* instance() {
  if (!m_instance) m_instance = new SoundManager;
  return m_instance;
 }

 struct Parameters;
 void Initialize(const Parameters&);
 void SetParameters(const Parameters&);
 void Shutdown();

 bool OpenSoundFile(FileSpecifier& File);
 void CloseSoundFile();

 bool AdjustVolumeUp(short sound_index = NONE);
 bool AdjustVolumeDown(short sound_index = NONE);
 void TestVolume(short volume, short sound_index);


 int NewCustomSoundDefinition();
 bool AddCustomSoundSlot(int index, const char* file);
 void UnloadCustomSounds();

 bool LoadSound(short sound);
 void LoadSounds(short *sounds, short count);

 void OrphanSound(short identifier);

 void UnloadAllSounds();

 void PlaySound(short sound_index, world_location3d *source, short identifier, _fixed pitch = _normal_frequency);
 void PlayLocalSound(short sound_index, _fixed pitch = _normal_frequency) { PlaySound(sound_index, 0, NONE, pitch); }
 void DirectPlaySound(short sound_index, angle direction, short volume, _fixed pitch);
 bool SoundIsPlaying(short sound_index);

 void StopSound(short identifier, short sound_index);
 void StopAllSounds() { StopSound(NONE, NONE); }

 int NumberOfSoundDefinitions();

 inline int16 GetNetmicVolumeAdjustment() {
  return (parameters.volume_while_speaking);
 }

 void Idle();

 class Pause
 {
 public:
  Pause() { instance()->SetStatus(false); }
  ~Pause() { instance()->SetStatus(true); }
 };


 void CauseAmbientSoundSourceUpdate();
 void AddOneAmbientSoundSource(ambient_sound_data *ambient_sounds, world_location3d *source, world_location3d *listener, short ambient_sound_index, short absolute_volume);


 short RandomSoundIndexToSoundIndex(short random_sound_index);

 struct Parameters
 {
  static const int DEFAULT_RATE = 44100;
  static const int DEFAULT_SAMPLES = 1024;
  int16 channel_count;
  int16 volume;
  uint16 flags;

  uint16 rate;
  uint16 samples;

  int16 music;

  int16 volume_while_speaking;
  bool mute_while_transmitting;

  Parameters();
  bool Verify();
 } parameters;

 struct Channel
 {
  uint16 flags;

  short sound_index;
  short identifier;
  struct Variables
  {
   short volume, left_volume, right_volume;
   _fixed original_pitch, pitch;

   short priority;
  } variables;

  world_location3d *dynamic_source;
  world_location3d source;

  unsigned long start_tick;

  int mixer_channel;
  short callback_count;
 };

 void IncrementChannelCallbackCount(int channel) { channels[channel].callback_count++; }

 bool IsActive() { return active; }
 bool IsInitialized() { return initialized; }

private:
 SoundManager();
 void SetStatus(bool active);

 SoundDefinition* GetSoundDefinition(short sound_index);
 void BufferSound(Channel &, short sound_index, _fixed pitch, bool ext_play_immed = true);

 Channel *BestChannel(short sound_index, Channel::Variables& variables);
 void FreeChannel(Channel &);

 void UnlockSound(short sound_index) { }
 void UnlockLockedSounds();
 short ReleaseLeastUsefulSound();
 void DisposeSound(short sound_index);

 void CalculateSoundVariables(short sound_index, world_location3d *source, Channel::Variables& variables);
 void CalculateInitialSoundVariables(short sound_index, world_location3d *source, Channel::Variables& variables, _fixed pitch);
 void InstantiateSoundVariables(Channel::Variables& variables, Channel& channel, bool first_time);

 _fixed CalculatePitchModifier(short sound_index, _fixed pitch_modifier);
 void AngleAndVolumeToStereoVolume(angle delta, short volume, short *right_volume, short *left_volume);

 short GetRandomSoundPermutation(short sound_index);

 void TrackStereoSounds();
 void UpdateAmbientSoundSources();

 static SoundManager *m_instance;

 bool initialized;
 bool active;

 short total_channel_count;
 long total_buffer_size;

 short sound_source;

 long loaded_sounds_size;

 std::vector<Channel> channels;

 SoundFile sound_file;


 static const int MINIMUM_SOUND_BUFFER_SIZE = 300*KILO;
 static const int MORE_SOUND_BUFFER_SIZE = 600*KILO;
 static const int AMBIENT_SOUND_BUFFER_SIZE = 1*MEG;
 static const int MAXIMUM_SOUND_BUFFER_SIZE = 1*MEG;


 static const int MAXIMUM_SOUND_CHANNELS = 32;
 static const int MAXIMUM_AMBIENT_SOUND_CHANNELS = 4;
 static const int MAXIMUM_PROCESSED_AMBIENT_SOUNDS = 5;



 static const int MAXIMUM_OUTPUT_SOUND_VOLUME = 2 * MAXIMUM_SOUND_VOLUME;
 static const int SOUND_VOLUME_DELTA = MAXIMUM_OUTPUT_SOUND_VOLUME / NUMBER_OF_SOUND_VOLUME_LEVELS;
 static const int MAXIMUM_AMBIENT_SOUND_VOLUME = 3 * MAXIMUM_SOUND_VOLUME / 2;
 static const int DEFAULT_SOUND_LEVEL= NUMBER_OF_SOUND_VOLUME_LEVELS/3;
 static const int DEFAULT_MUSIC_LEVEL = NUMBER_OF_SOUND_VOLUME_LEVELS/2;
 static const int DEFAULT_VOLUME_WHILE_SPEAKING = MAXIMUM_SOUND_VOLUME / 8;


 static const int MINIMUM_SOUND_PITCH= 1;
 static const int MAXIMUM_SOUND_PITCH= 256*(1L<<16);


 static const int ABORT_AMPLITUDE_THRESHHOLD= (MAXIMUM_SOUND_VOLUME/6);
 static const int MINIMUM_RESTART_TICKS= 1000/12;


 static const int _sound_is_local = 0x0001;
};



typedef void (*add_ambient_sound_source_proc_ptr)(ambient_sound_data *ambient_sounds,
 world_location3d *source, world_location3d *listener, short sound_index,
 short absolute_volume);





world_location3d *_sound_listener_proc(void);


uint16 _sound_obstructed_proc(world_location3d *source);

void _sound_add_ambient_sources_proc(void *data, add_ambient_sound_source_proc_ptr add_one_ambient_sound_source);



short Sound_TerminalLogon();
short Sound_TerminalLogoff();
short Sound_TerminalPage();

short Sound_TeleportIn();
short Sound_TeleportOut();

short Sound_GotPowerup();
short Sound_GotItem();

short Sound_Crunched();
short Sound_Exploding();

short Sound_Breathing();
short Sound_OxygenWarning();

short Sound_AdjustVolume();



short Sound_ButtonSuccess();
short Sound_ButtonFailure();
short Sound_ButtonInoperative();
short Sound_OGL_Reset();


XML_ElementParser *Sounds_GetParser();
# 35 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/fades.h" 1
# 40 "../Source_Files/RenderOther/fades.h"
enum
{
 NUMBER_OF_GAMMA_LEVELS= 8,
 DEFAULT_GAMMA_LEVEL= 2
};

enum
{
 _start_cinematic_fade_in,
 _cinematic_fade_in,
 _long_cinematic_fade_in,
 _cinematic_fade_out,
 _end_cinematic_fade_out,

 _fade_red,
 _fade_big_red,
 _fade_bonus,
 _fade_bright,
 _fade_long_bright,
 _fade_yellow,
 _fade_big_yellow,
 _fade_purple,
 _fade_cyan,
 _fade_white,
 _fade_big_white,
 _fade_orange,
 _fade_long_orange,
 _fade_green,
 _fade_long_green,
 _fade_static,
 _fade_negative,
 _fade_big_negative,
 _fade_flicker_negative,
 _fade_dodge_purple,
 _fade_burn_cyan,
 _fade_dodge_yellow,
 _fade_burn_green,

 _fade_tint_green,
 _fade_tint_blue,
 _fade_tint_orange,
 _fade_tint_gross,
 _fade_tint_jjaro,

 NUMBER_OF_FADE_TYPES
};


enum
{
 _effect_under_water,
 _effect_under_lava,
 _effect_under_sewage,
 _effect_under_jjaro,
 _effect_under_goo,
 NUMBER_OF_FADE_EFFECT_TYPES
};




enum
{
 _tint_fader_type,
 _randomize_fader_type,
 _negate_fader_type,
 _dodge_fader_type,
 _burn_fader_type,
 _soft_tint_fader_type,
 NUMBER_OF_FADER_FUNCTIONS
};




void initialize_fades(void);
bool update_fades(void);

void start_fade(short type);
void stop_fade(void);
bool fade_finished(void);

void set_fade_effect(short type);

short get_fade_period(short type);

void gamma_correct_color_table(struct color_table *uncorrected_color_table, struct color_table *corrected_color_table, short gamma_level);

void explicit_start_fade(short type, struct color_table *original_color_table, struct color_table *animated_color_table);
void full_fade(short type, struct color_table *original_color_table);




void SetFadeEffectDelay(int _FadeEffectDelay);


XML_ElementParser *Faders_GetParser();
# 36 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/screen.h" 1
# 65 "../Source_Files/RenderOther/screen.h"
enum
{
 _320_160_HUD,
 _480_240_HUD,
 _640_320_HUD,
 _640_480,
 _800_400_HUD,
 _800_600,
 _1024_512_HUD,
 _1024_768,
 _1280_640_HUD,
 _1280_1024,
 _1600_800_HUD,
 _1600_1200,
        _1024_440_HUD,
 _1024_640,
 _1280_600_HUD,
 _1280_800,
        _1280_640WS_HUD,
        _1280_854,
        _1440_700_HUD,
        _1440_900,
 _1680_840_HUD,
 _1680_1050,
 _1920_950_HUD,
 _1920_1200,
 _2560_1280_HUD,
 _2560_1600,
 _1280_768WS_HUD,
 _1280_768,
 _1280_640SD_HUD,
 _1280_960,
 _1280_720_HUD,
 _1280_720,
 NUMBER_OF_VIEW_SIZES
};

enum
{
 _50_percent,
 _75_percent,
 _100_percent,
 _full_screen,
};

enum
{
 _no_acceleration,
 _opengl_acceleration
};
# 127 "../Source_Files/RenderOther/screen.h"
extern struct color_table *world_color_table, *visible_color_table, *interface_color_table;


struct screen_mode_data;



void change_screen_clut(struct color_table *color_table);
void change_interface_clut(struct color_table *color_table);
void animate_screen_clut(struct color_table *color_table, bool full_screen);

void build_direct_color_table(struct color_table *color_table, short bit_depth);

void start_teleporting_effect(bool out);
void start_extravision_effect(bool out);

void render_screen(short ticks_elapsed);

void toggle_overhead_map_display_status(void);


bool zoom_overhead_map_out(void);
bool zoom_overhead_map_in(void);

void enter_screen(void);
void exit_screen(void);

void darken_world_window(void);
void validate_world_window(void);

void change_gamma_level(short gamma_level);

void assert_world_color_table(struct color_table *world_color_table, struct color_table *interface_color_table);


void reset_screen();


screen_mode_data *get_screen_mode(void);


short GetSizeWithHUD(short Size);
short GetSizeWithoutHUD(short Size);


void initialize_screen(struct screen_mode_data *mode, bool ShowFreqDialog);
void change_screen_mode(struct screen_mode_data *mode, bool redraw);

void toggle_fullscreen(bool fs);
void toggle_fullscreen();
void update_screen_window(void);
void clear_screen(void);

void calculate_destination_frame(short size, bool high_resolution, Rect *frame);



void dump_screen();


bool GetTunnelVision();
bool SetTunnelVision(bool TunnelVisionOn);


void RequestDrawingHUD();




short SizeWithHUD(short _size);
short SizeWithoutHUD(short _size);


void ShowMessage(char *Text);







void SetScriptHUDColor(int idx, int color);


void SetScriptHUDText(int idx, const char* text);


bool SetScriptHUDIcon(int idx, const char* icon, size_t length);

void SetScriptHUDSquare(int idx, int color);
# 37 "shell.cpp" 2
# 1 "../Source_Files/Sound/Music.h" 1
# 28 "../Source_Files/Sound/Music.h"
# 1 "../Source_Files/Sound/Decoder.h" 1
# 28 "../Source_Files/Sound/Decoder.h"
# 1 "../Source_Files/Files/FileHandler.h" 1
# 29 "../Source_Files/Sound/Decoder.h" 2

class StreamDecoder
{
public:
 virtual bool Open(FileSpecifier &File) = 0;
 virtual int32 Decode(uint8* buffer, int32 max_length) = 0;
 virtual void Rewind() = 0;
 virtual void Close() = 0;

 virtual bool IsSixteenBit() = 0;
 virtual bool IsStereo() = 0;
 virtual bool IsSigned() = 0;
 virtual int BytesPerFrame() = 0;
 virtual float Rate() = 0;
 virtual bool IsLittleEndian() = 0;

 StreamDecoder() { }
 virtual ~StreamDecoder() { }

 static StreamDecoder* Get(FileSpecifier &File);
};

class Decoder : public StreamDecoder
{
public:
 Decoder() : StreamDecoder() { }
 ~Decoder() { }


 virtual int32 Frames() = 0;

 static Decoder* Get(FileSpecifier &File);
};
# 29 "../Source_Files/Sound/Music.h" 2
# 1 "../Source_Files/Files/FileHandler.h" 1
# 30 "../Source_Files/Sound/Music.h" 2
# 1 "../Source_Files/Misc/Random.h" 1
# 17 "../Source_Files/Misc/Random.h"
struct GM_Random
{
 uint32 z, w, jsr, jcong, t[256], x, y;
 unsigned char c;

 uint32 znew() {return (z=36969*(z&65535)+(z>>16));}
 uint32 wnew() {return (w=18000*(w&65535)+(w>>16));}
 uint32 MWC() {return ((znew()<<16)+wnew());}
 uint32 SHR3() {return (jsr=(jsr=(jsr=jsr^(jsr<<17))^(jsr>>13))^(jsr<<5));}
 uint32 CONG() {return (jcong=69069*jcong+1234567);}
 uint32 KISS() {return ((MWC()^CONG())+SHR3());}
 uint32 LFIB4() {t[c]=t[c]+t[c+58]+t[c+119]+t[c+178]; return t[++c];}
 uint32 SWB() {t[c+237]=(x=t[c+15])-(y=t[c]+(x<y)); return t[++c];}
 float UNI() {return (float)(KISS()*2.328306e-10);}
 float VNI() {return (float)(((int32) KISS())*4.656613e-10);}





 void SetTable() {for (int i=0;i<256;i++) t[i]=KISS();}







 GM_Random(): z(362436069), w(521288629), jsr(123456789), jcong(380116160),
  x(0), y(0), c(0) {SetTable();}
};
# 31 "../Source_Files/Sound/Music.h" 2
# 1 "../Source_Files/Sound/SoundManager.h" 1
# 32 "../Source_Files/Sound/Music.h" 2


class Music
{
public:
 static Music *instance() {
  if (!m_instance) m_instance = new Music(); return m_instance;
 }

 bool SetupIntroMusic(FileSpecifier &File);
 void RestartIntroMusic();

 void Open(FileSpecifier *file);
 void FadeOut(short duration);
 void Close();
 void Pause();
 void Play();
 bool Playing();
 void Rewind();
 void Restart();



 bool FillBuffer();

 void Idle();

 bool Initialized() { return music_initialized; }

 void PreloadLevelMusic();
 void StopLevelMusic();
 void ClearLevelMusic() { playlist.clear(); }
 void PushBackLevelMusic(FileSpecifier& file) { playlist.push_back(file); }
 bool IsLevelMusicActive() { return (!playlist.empty()); }
 void LevelMusicRandom(bool fRandom) { random_order = fRandom; }
 void SeedLevelMusic();

 void CheckVolume();

private:
 Music();
 bool Load(FileSpecifier &file);
 static Music *m_instance;

 FileSpecifier* GetLevelMusic();
 void LoadLevelMusic();

 int16 GetVolumeLevel() { return SoundManager::instance()->parameters.music; }




 static const int MUSIC_BUFFER_SIZE = 1024;


 std::vector<uint8> music_buffer;
 StreamDecoder *decoder;

 SDL_RWops* music_rw;


 bool sixteen_bit;
 bool stereo;
 bool signed_8bit;
 int bytes_per_frame;
 _fixed rate;
 bool little_endian;

 FileSpecifier music_file;
 FileSpecifier music_intro_file;

 bool music_initialized;
 bool music_play;
 bool music_prelevel;
 bool music_level;
 bool music_fading;
 uint32 music_fade_start;
 uint32 music_fade_duration;
 bool music_intro;
# 120 "../Source_Files/Sound/Music.h"
 std::vector<FileSpecifier> playlist;
 size_t song_number;
 bool random_order;
 GM_Random randomizer;
};
# 38 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/images.h" 1
# 39 "../Source_Files/RenderOther/images.h"
# 1 "../Source_Files/Files/FileHandler.h" 1
# 40 "../Source_Files/RenderOther/images.h" 2

extern void initialize_images_manager(void);

extern bool images_picture_exists(int base_resource);
extern bool scenario_picture_exists(int base_resource);



enum
{
 CLUTSource_Images,
 CLUTSource_Scenario
};
extern struct color_table *calculate_picture_clut(int CLUTSource, int pict_resource_number);
extern struct color_table *build_8bit_system_color_table(void);

extern void set_scenario_images_file(FileSpecifier& File);

extern void draw_full_screen_pict_resource_from_images(int pict_resource_number);
extern void draw_full_screen_pict_resource_from_scenario(int pict_resource_number);

extern void scroll_full_screen_pict_resource_from_scenario(int pict_resource_number, bool text_block);



extern bool get_picture_resource_from_images(int base_resource, LoadedResource& PictRsrc);
extern bool get_picture_resource_from_scenario(int base_resource, LoadedResource& PictRsrc);

extern bool get_sound_resource_from_scenario(int resource_number, LoadedResource& SoundRsrc);
extern bool get_text_resource_from_scenario(int resource_number, LoadedResource& TextRsrc);



extern SDL_Surface *picture_to_surface(LoadedResource &rsrc);


extern SDL_Surface *rescale_surface(SDL_Surface *s, int width, int height);
extern SDL_Surface *tile_surface(SDL_Surface *s, int width, int height);
# 39 "shell.cpp" 2
# 1 "../Source_Files/Misc/vbl.h" 1
# 34 "../Source_Files/Misc/vbl.h"
# 1 "../Source_Files/Files/FileHandler.h" 1
# 35 "../Source_Files/Misc/vbl.h" 2


bool setup_for_replay_from_file(FileSpecifier& File, uint32 map_checksum);
bool setup_replay_from_random_resource(uint32 map_checksum);

void start_recording(void);

bool find_replay_to_use(bool ask_user, FileSpecifier& File);

void set_recording_header_data(short number_of_players, short level_number, uint32 map_checksum,
 short version, struct player_start_data *starts, struct game_data *game_information);
void get_recording_header_data(short *number_of_players, short *level_number, uint32 *map_checksum,
 short *version, struct player_start_data *starts, struct game_data *game_information);

bool input_controller(void);
void increment_heartbeat_count(int value = 1);


void initialize_keyboard_controller(void);


bool get_recording_filedesc(FileSpecifier& File);
void move_replay(void);
uint32 parse_keymap(void);

bool setup_replay_from_random_resource(uint32 map_checksum);
# 76 "../Source_Files/Misc/vbl.h"
XML_ElementParser *Keyboard_GetParser();
# 40 "shell.cpp" 2
# 1 "../Source_Files/Misc/preferences.h" 1
# 54 "../Source_Files/Misc/preferences.h"
# 1 "../Source_Files/Misc/interface.h" 1
# 55 "../Source_Files/Misc/preferences.h" 2
# 1 "../Source_Files/RenderOther/ChaseCam.h" 1
# 31 "../Source_Files/RenderOther/ChaseCam.h"
enum

{
 _ChaseCam_OnWhenEntering = 0x0004,
 _ChaseCam_NeverActive = 0x0002,
 _ChaseCam_ThroughWalls = 0x0001
};

struct ChaseCamData
{
 short Behind;
 short Upward;
 short Rightward;
 short Flags;
 float Damping;
 float Spring;
 float Opacity;
};




bool Configure_ChaseCam(ChaseCamData &Data);



ChaseCamData& GetChaseCamData();




bool ChaseCam_CanExist();


bool ChaseCam_IsActive();
bool ChaseCam_SetActive(bool NewState);


bool ChaseCam_Initialize();



bool ChaseCam_Reset();



bool ChaseCam_Update();



bool ChaseCam_SwitchSides();



bool ChaseCam_GetPosition(world_point3d &position,
 short &polygon_index, angle &yaw, angle &pitch);
# 56 "../Source_Files/Misc/preferences.h" 2
# 1 "../Source_Files/RenderMain/Crosshairs.h" 1
# 36 "../Source_Files/RenderMain/Crosshairs.h"
enum {
 CHShape_RealCrosshairs,
 CHShape_Circle
};

struct CrosshairData
{
     RGBColor Color;
 short Thickness;
 short FromCenter;
 short Length;
 short Shape;
 float Opacity;
 float GLColorsPreCalc[4];
 bool PreCalced;
};




bool Configure_Crosshairs(CrosshairData &Data);



CrosshairData& GetCrosshairData();


bool Crosshairs_IsActive();
bool Crosshairs_SetActive(bool NewState);
# 75 "../Source_Files/RenderMain/Crosshairs.h"
bool Crosshairs_Render(SDL_Surface *s);
# 57 "../Source_Files/Misc/preferences.h" 2
# 1 "../Source_Files/RenderMain/OGL_Setup.h" 1
# 67 "../Source_Files/RenderMain/OGL_Setup.h"
# 1 "../Source_Files/RenderMain/OGL_Subst_Texture_Def.h" 1
# 30 "../Source_Files/RenderMain/OGL_Subst_Texture_Def.h"
# 1 "../Source_Files/RenderMain/OGL_Texture_Def.h" 1
# 33 "../Source_Files/RenderMain/OGL_Texture_Def.h"
using namespace std;


# 1 "../Source_Files/RenderMain/ImageLoader.h" 1
# 31 "../Source_Files/RenderMain/ImageLoader.h"
# 1 "../Source_Files/RenderMain/DDS.h" 1
# 54 "../Source_Files/RenderMain/DDS.h"
struct DDSURFACEDESC2
{
 uint32 dwSize;
 uint32 dwFlags;
 uint32 dwHeight;
 uint32 dwWidth;
 uint32 dwPitchOrLinearSize;
 uint32 dwDepth;
 uint32 dwMipMapCount;
 uint32 dwReserved1[11];

 struct {
  uint32 dwSize;
  uint32 dwFlags;
  uint32 dwFourCC;
  uint32 dwRGBBitCount;
  uint32 dwRBitMask;
  uint32 dwGBitMask;
  uint32 dwBBitMask;
  uint32 dwRGBAlphaBitMask;
 } ddpfPixelFormat;

 struct {
  uint32 dwCaps1;
  uint32 dwCaps2;
  uint32 Reserved[2];
 } ddsCaps;

 uint32 dwReserved2;
};
# 32 "../Source_Files/RenderMain/ImageLoader.h" 2


# 1 "../Source_Files/Files/FileHandler.h" 1
# 35 "../Source_Files/RenderMain/ImageLoader.h" 2

using namespace std;


class ImageDescriptor
{
 int Width;
 int Height;

 double VScale;
 double UScale;

 uint32 *Pixels;
 int Size;

 int MipMapCount;

public:

 bool IsPresent() const {return (Pixels != __null); }
 bool IsPremultiplied() const { return (IsPresent() ? PremultipliedAlpha : false); }

 bool LoadFromFile(FileSpecifier& File, int ImgMode, int flags, int actual_width = 0, int actual_height = 0, int maxSize = 0);


 int GetWidth() const {return Width;}
 int GetHeight() const {return Height;}
 int GetNumPixels() const {return Width*Height;}

 int GetMipMapCount() const { return MipMapCount; }
 int GetTotalBytes() const { return Size; }
 int GetBufferSize() const { return Size; }
 int GetFormat() const { return Format; }

 double GetVScale() const { return VScale; }
 double GetUScale() const { return UScale; }



 uint32 *GetPixelBasePtr() {return Pixels;}
 const uint32 *GetBuffer() const { return Pixels; }
 uint32 *GetBuffer() { return Pixels; }

 uint32 *GetMipMapPtr(int Level);
 const uint32 *GetMipMapPtr(int Level) const;
 int GetMipMapSize(int level) const;


 void Resize(int _Width, int _Height);


 void Resize(int _Width, int _Height, int _TotalBytes);

 bool Minify();

 bool MakeRGBA();
 bool MakeDXTC3();

 void PremultiplyAlpha();
 bool PremultipliedAlpha;


 void Clear()
  {Width = Height = Size = 0; delete []Pixels; Pixels = __null;}

 ImageDescriptor(const ImageDescriptor &CopyFrom);

ImageDescriptor(): Width(0), Height(0), VScale(1.0), UScale(1.0), Pixels(__null), Size(0), PremultipliedAlpha(false) {}


 ImageDescriptor(int width, int height, uint32 *pixels);

 enum ImageFormat {
  RGBA8,
  DXTC1,
  DXTC3,
  DXTC5,
  Unknown
 };

 ~ImageDescriptor()
 {
  delete []Pixels;
  Pixels = __null;
 }

private:
 bool LoadDDSFromFile(FileSpecifier& File, int flags, int actual_width = 0, int actual_height = 0, int maxSize = 0);
 bool LoadMipMapFromFile(OpenedFile &File, int flags, int level, DDSURFACEDESC2 &ddsd, int skip);
 bool SkipMipMapFromFile(OpenedFile &File, int flags, int level, DDSURFACEDESC2 &ddsd);

 ImageFormat Format;
};

template <typename T>
class copy_on_edit
{
public:
 copy_on_edit() : _original(__null), _copy(__null) { };

 void set(const T* original) {
  if (_copy) {
   delete _copy;
   _copy = __null;
  }
  _original = original;
 }

 void set(T* original) {
  if (_copy) {
   delete _copy;
   _copy= __null;
  }
  _original = original;
 }


 const T* get() {
  if (_copy)
   return (const T*) _copy;
  else
   return (const T*) _original;
 }

 T* edit() {
  if (!_original) {
   return _copy;
  } else {
   if (!_copy) {
    _copy = new T(*_original);
   }
   return _copy;
  }
 }


 T* edit(T* copy) {
  if (_copy) {
   delete _copy;
  }
  _original = __null;
  _copy = copy;
 }

 ~copy_on_edit() {
  if (_copy) {
   delete _copy;
   _copy = __null;
  }
 }

private:
 T* _original;
 T* _copy;
};

typedef copy_on_edit<ImageDescriptor> ImageDescriptorManager;






enum {
 ImageLoader_Colors,
 ImageLoader_Opacity
};

enum {
 ImageLoader_ResizeToPowersOfTwo = 0x1,
 ImageLoader_CanUseDXTC = 0x2,
 ImageLoader_LoadMipMaps = 0x4,
 ImageLoader_LoadDXTC1AsDXTC3 = 0x8,
 ImageLoader_ImageIsAlreadyPremultiplied = 0x10
};



uint32 *GetMipMapPtr(uint32 *pixels, int size, int level, int width, int height, int format);
# 37 "../Source_Files/RenderMain/OGL_Texture_Def.h" 2
# 31 "../Source_Files/RenderMain/OGL_Subst_Texture_Def.h" 2
# 68 "../Source_Files/RenderMain/OGL_Setup.h" 2
# 1 "../Source_Files/RenderMain/OGL_Model_Def.h" 1
# 30 "../Source_Files/RenderMain/OGL_Model_Def.h"
# 1 "../Source_Files/ModelView/Model3D.h" 1
# 28 "../Source_Files/ModelView/Model3D.h"
using namespace std;
# 259 "../Source_Files/ModelView/Model3D.h"
struct Model3D;
# 31 "../Source_Files/RenderMain/OGL_Model_Def.h" 2
# 69 "../Source_Files/RenderMain/OGL_Setup.h" 2
# 77 "../Source_Files/RenderMain/OGL_Setup.h"
bool OGL_Initialize();


bool OGL_IsPresent();


bool OGL_IsActive();


bool OGL_CheckExtension(const std::string);

void OGL_StartProgress(int total_progress);
void OGL_ProgressCallback(int delta_progress);
void OGL_StopProgress();
# 99 "../Source_Files/RenderMain/OGL_Setup.h"
enum
{
 OGL_Txtr_Wall,
 OGL_Txtr_Landscape,
 OGL_Txtr_Inhabitant,
 OGL_Txtr_WeaponsInHand,
 OGL_NUMBER_OF_TEXTURE_TYPES
};
# 136 "../Source_Files/RenderMain/OGL_Setup.h"
struct OGL_Texture_Configure
{
 int16 NearFilter;
 int16 FarFilter;
 int16 Resolution;
 int16 ColorFormat;
 int16 MaxSize;
};


enum
{
 OGL_Flag_ZBuffer = 0x0001,
 OGL_Flag_VoidColor = 0x0002,
 OGL_Flag_FlatLand = 0x0004,
 OGL_Flag_Fog = 0x0008,
 OGL_Flag_3D_Models = 0x0010,
 OGL_Flag_2DGraphics = 0x0020,
 OGL_Flag_FlatStatic = 0x0040,
 OGL_Flag_Fader = 0x0080,
 OGL_Flag_LiqSeeThru = 0x0100,
 OGL_Flag_Map = 0x0200,
 OGL_Flag_TextureFix = 0x0400,
 OGL_Flag_HUD = 0x0800,
};

struct OGL_ConfigureData
{

 OGL_Texture_Configure TxtrConfigList[OGL_NUMBER_OF_TEXTURE_TYPES];


 OGL_Texture_Configure ModelConfig;


 uint16 Flags;


 RGBColor VoidColor;





 RGBColor LscpColors[4][2];


 float AnisotropyLevel;
 int16 Multisamples;

 bool GeForceFix;
};

OGL_ConfigureData& Get_OGL_ConfigureData();





void OGL_SetDefaults(OGL_ConfigureData& Data);



int OGL_CountModelsImages(short Collection);
void OGL_LoadModelsImages(short Collection);
void OGL_UnloadModelsImages(short Collection);



void OGL_ResetTextures();
# 323 "../Source_Files/RenderMain/OGL_Setup.h"
struct OGL_FogData
{
 rgb_color Color;
 float Depth;
 bool IsPresent;
 bool AffectsLandscapes;
};


enum
{
 OGL_Fog_AboveLiquid,
 OGL_Fog_BelowLiquid,
 OGL_NUMBER_OF_FOG_TYPES
};

OGL_FogData *OGL_GetFogData(int Type);



XML_ElementParser *OpenGL_GetParser();
# 58 "../Source_Files/Misc/preferences.h" 2
# 1 "./shell.h" 1
# 59 "../Source_Files/Misc/preferences.h" 2




const float DEFAULT_MONITOR_REFRESH_FREQUENCY = 60;

enum {
 _sw_alpha_off,
 _sw_alpha_fast,
 _sw_alpha_nice,
};

struct graphics_preferences_data
{
 struct screen_mode_data screen_mode;






 OGL_ConfigureData OGL_Configure;

 bool double_corpse_limit;

 int16 software_alpha_blending;

 bool hog_the_cpu;
};

struct serial_number_data
{
 bool network_only;
 byte long_serial_number[10];
 Str255 user_name;
 Str255 tokenized_serial_number;
};

enum {
 _network_game_protocol_ring,
 _network_game_protocol_star,
 NUMBER_OF_NETWORK_GAME_PROTOCOLS,

 _network_game_protocol_default = _network_game_protocol_star
};

struct network_preferences_data
{
 bool allow_microphone;
 bool game_is_untimed;
 int16 type;
 int16 game_type;
 int16 difficulty_level;
 uint16 game_options;
 int32 time_limit;
 int16 kill_limit;
 int16 entry_point;
 bool autogather;
 bool join_by_address;
 char join_address[256];
 uint16 game_port;
 uint16 game_protocol;
 bool use_speex_encoder;
 bool use_netscript;



 char netscript_file[256];

 uint16 cheat_flags;
 bool advertise_on_metaserver;
 bool attempt_upnp;
 bool check_for_updates;

 enum {
  kMetaserverLoginLength = 16
 };

 char metaserver_login[kMetaserverLoginLength];
 char metaserver_password[kMetaserverLoginLength];
 bool use_custom_metaserver_colors;
 rgb_color metaserver_colors[2];
 bool mute_metaserver_guests;
};

struct player_preferences_data
{
 unsigned char name[32 +1];
 int16 color;
 int16 team;
 uint32 last_time_ran;
 int16 difficulty_level;
 bool background_music_on;
 struct ChaseCamData ChaseCam;
 struct CrosshairData Crosshairs;
};




enum {
 _inputmod_interchange_run_walk = 0x0001,
 _inputmod_interchange_swim_sink = 0x0002,
 _inputmod_dont_switch_to_new_weapon = 0x0004,
 _inputmod_invert_mouse = 0x0008,
 _inputmod_use_button_sounds = 0x0010,
 _inputmod_dont_auto_recenter = 0x0020
};


enum {
 _key_inventory_left,
 _key_inventory_right,
 _key_switch_view,
 _key_volume_up,
 _key_volume_down,
 _key_zoom_in,
 _key_zoom_out,
 _key_toggle_fps,
 _key_activate_console,
 NUMBER_OF_SHELL_KEYS
};


struct input_preferences_data
{
 int16 input_device;
 int16 keycodes[21];

 uint16 modifiers;

 _fixed sens_horizontal;
 _fixed sens_vertical;

 bool mouse_acceleration;

 int16 mouse_button_actions[5];
 int16 shell_keycodes[NUMBER_OF_SHELL_KEYS];
};


enum {
 _mouse_button_does_nothing,
 _mouse_button_fires_left_trigger,
 _mouse_button_fires_right_trigger
};



struct environment_preferences_data
{






 char map_file[256];
 char physics_file[256];
 char shapes_file[256];
 char sounds_file[256];

 uint32 map_checksum;
 uint32 physics_checksum;
 TimeType shapes_mod_date;
 TimeType sounds_mod_date;
 uint32 patches[(32)];

 char theme_dir[256];



 bool group_by_directory;
 bool reduce_singletons;


 bool smooth_text;

 char solo_lua_file[256];
 bool use_solo_lua;
};


extern struct graphics_preferences_data *graphics_preferences;
extern struct serial_number_data *serial_preferences;
extern struct network_preferences_data *network_preferences;
extern struct player_preferences_data *player_preferences;
extern struct input_preferences_data *input_preferences;

extern SoundManager::Parameters *sound_preferences;
extern struct environment_preferences_data *environment_preferences;


void initialize_preferences(void);
void read_preferences();
void handle_preferences(void);
void write_preferences(void);
# 41 "shell.cpp" 2
# 1 "../Source_Files/Files/tags.h" 1
# 42 "shell.cpp" 2
# 1 "../Source_Files/Network/network_sound.h" 1
# 38 "../Source_Files/Network/network_sound.h"
OSErr open_network_speaker();


void network_speaker_idle_proc();


void close_network_speaker();


void queue_network_speaker_data(byte* inData, short inLength);


void received_network_audio_proc(void *buffer, short buffer_size, short player_index);

void quiet_network_speaker(void);

void mute_player_mic(short player_index);
void clear_player_mic_mutes();





bool is_network_microphone_implemented();


bool has_sound_input_capability(void);


OSErr open_network_microphone();


void set_network_microphone_state(bool inActive);


void network_microphone_idle_proc();


void close_network_microphone();
# 43 "shell.cpp" 2
# 1 "../Source_Files/Input/mouse.h" 1
# 30 "../Source_Files/Input/mouse.h"
void enter_mouse(short type);
void test_mouse(short type, uint32 *action_flags, _fixed *delta_yaw, _fixed *delta_pitch, _fixed *delta_velocity);
void exit_mouse(short type);
void mouse_idle(short type);
void recenter_mouse(void);



void mouse_buttons_become_keypresses(Uint8* ioKeyMap);
void mouse_scroll(bool up);
# 44 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/screen_drawing.h" 1
# 39 "../Source_Files/RenderOther/screen_drawing.h"
enum {

 _player_name_rect= 0,
 _oxygen_rect,
 _shield_rect,
 _motion_sensor_rect,
 _microphone_rect,
 _inventory_rect,
 _weapon_display_rect,


 _new_game_button_rect,
 _load_game_button_rect,
 _gather_button_rect,
 _join_button_rect,
 _prefs_button_rect,
 _replay_last_button_rect,
 _save_last_button_rect,
 _replace_saved_button_rect,
 _credits_button_rect,
 _quit_button_rect,
 _center_button_rect,
 _singleton_game_button_rect,
 NUMBER_OF_INTERFACE_RECTANGLES
};


enum {
 _energy_weapon_full_color,
 _energy_weapon_empty_color,
 _black_color,
 _inventory_text_color,
 _inventory_header_background_color,
 _inventory_background_color,
 PLAYER_COLOR_BASE_INDEX,

 _white_color= 14,
 _invalid_weapon_color,
 _computer_border_background_text_color,
 _computer_border_text_color,
 _computer_interface_text_color,
 _computer_interface_color_purple,
 _computer_interface_color_red,
 _computer_interface_color_pink,
 _computer_interface_color_aqua,
 _computer_interface_color_yellow,
 _computer_interface_color_brown,
 _computer_interface_color_blue
};

enum {
 _no_flags,
 _center_horizontal= 0x01,
 _center_vertical= 0x02,
 _right_justified= 0x04,
 _top_justified= 0x08,
 _bottom_justified= 0x10,
 _wrap_text= 0x20
};

enum {
 _interface_font,
 _weapon_name_font,
 _player_name_font,
 _interface_item_count_font,
 _computer_interface_font,
 _computer_interface_title_font,
 _net_stats_font,
 NUMBER_OF_INTERFACE_FONTS
};


struct screen_rectangle {
 short top, left;
 short bottom, right;
};
typedef struct screen_rectangle screen_rectangle;


void initialize_screen_drawing(void);

void _set_port_to_screen_window(void);
void _set_port_to_gworld(void);
void _restore_port(void);

void _set_port_to_term(void);



void _draw_screen_shape(shape_descriptor shape_id, screen_rectangle *destination,
 screen_rectangle *source);
void _draw_screen_shape_at_x_y(shape_descriptor shape, short x, short y);
void _draw_screen_shape_centered(shape_descriptor shape, screen_rectangle *rectangle,
 short flags);
void _draw_screen_text(const char *text, screen_rectangle *destination,
 short flags, short font_id, short text_color);
short _text_width(const char *buffer, short font_id);
short _text_width(const char *buffer, int start, int length, short font_id);

void _erase_screen(short color_index);

void _scroll_window(short dy, short rectangle_id, short background_color_index);

void _fill_screen_rectangle(screen_rectangle *rectangle, short color_index);

screen_rectangle *get_interface_rectangle(short index);
const rgb_color &get_interface_color(short index);
class FontSpecifier;
FontSpecifier &get_interface_font(short index);

short _get_font_line_height(short font_index);

void _fill_rect(screen_rectangle *rectangle, short color_index);

void _frame_rect(screen_rectangle *rectangle, short color_index);


void _set_port_to_HUD();


XML_ElementParser *InterfaceRectangles_GetParser();


void SetColorFontParserToScreenDrawing();


struct world_point2d;

static inline int draw_text(SDL_Surface *s, const char *text, size_t length, int x, int y, uint32 pixel, const font_info *font, uint16 style, bool utf8 = false)
{
 return font ? font->draw_text(s, text, length, x, y, pixel, style, utf8) : 0;
}

static inline int draw_text(SDL_Surface *s, const char *text, int x, int y, uint32 pixel, const font_info *font, uint16 style, bool utf8 = false)
{
 return font ? font->draw_text(s, text, strlen(text), x, y, pixel, style, utf8) : 0;
}

static inline int8 char_width(uint8 c, const font_info *font, uint16 style)
{
 return font ? font->char_width(c, style) : 0;
}

static inline uint16 text_width(const char *text, const font_info *font, uint16 style, bool utf8 = false)
{
 return font ? font->text_width(text, style, utf8) : 0;
}

static inline uint16 text_width(const char *text, size_t length, const font_info *font, uint16 style, bool utf8 = false)
{
 return font ? font->text_width(text, length, style, utf8) : 0;
}

static inline int trunc_text(const char *text, int max_width, const font_info *font, uint16 style)
{
 return font ? font->trunc_text(text, max_width, style) : 0;
}

extern void draw_polygon(SDL_Surface *s, const world_point2d *vertex_array, int vertex_count, uint32 pixel);
extern void draw_line(SDL_Surface *s, const world_point2d *v1, const world_point2d *v2, uint32 pixel, int pen_size);
extern void draw_rectangle(SDL_Surface *s, const SDL_Rect *r, uint32 pixel);
# 45 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/computer_interface.h" 1
# 80 "../Source_Files/RenderOther/computer_interface.h"
struct static_preprocessed_terminal_data {
 int16 total_length;
 int16 flags;
 int16 lines_per_page;
 int16 grouping_count;
 int16 font_changes_count;
};
const int SIZEOF_static_preprocessed_terminal_data = 10;

struct view_terminal_data {
 short top, left, bottom, right;
 short vertical_offset;
};


const int SIZEOF_player_terminal_data = 20;


void initialize_terminal_manager(void);
void initialize_player_terminal_info(short player_index);
void enter_computer_interface(short player_index, short text_number, short completion_flag);
void _render_computer_interface(struct view_terminal_data *data);
void update_player_for_terminal_mode(short player_index);
void update_player_keys_for_terminal(short player_index, uint32 action_flags);
uint32 build_terminal_action_flags(char *keymap);
void dirty_terminal_view(short player_index);
void abort_terminal_mode(short player_index);

bool player_in_terminal_mode(short player_index);







extern void unpack_map_terminal_data(uint8 *Stream, size_t Count);
extern void pack_map_terminal_data(uint8 *Stream, size_t Count);
uint8 *unpack_player_terminal_data(uint8 *Stream, size_t Count);
uint8 *pack_player_terminal_data(uint8 *Stream, size_t Count);

extern size_t calculate_packed_terminal_data_length(void);
# 46 "shell.cpp" 2
# 1 "../Source_Files/Files/game_wad.h" 1
# 36 "../Source_Files/Files/game_wad.h"
class FileSpecifier;

bool save_game_file(FileSpecifier& File);
bool export_level(FileSpecifier& File);


void pause_game(void);
void resume_game(void);
void get_current_saved_game_name(FileSpecifier& File);

void set_saved_game_name_to_default();


bool process_map_wad(struct wad_data *wad, bool restoring_game, short version);

bool match_checksum_with_map(short vRefNum, long dirID, uint32 checksum,
 FileSpecifier& File);
void set_map_file(FileSpecifier& File);


FileSpecifier& get_map_file(void);



void get_savegame_filedesc(FileSpecifier& File);

void add_finishing_touches_to_save_file(FileSpecifier& File);
# 47 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/game_window.h" 1
# 30 "../Source_Files/RenderOther/game_window.h"
void initialize_game_window(void);

void draw_interface(void);
void ensure_HUD_buffer(void);
void update_interface(short time_elapsed);
void scroll_inventory(short dy);

void OGL_DrawHUD(Rect &dest, short time_elapsed);

void mark_ammo_display_as_dirty(void);
void mark_shield_display_as_dirty(void);
void mark_oxygen_display_as_dirty(void);
void mark_weapon_display_as_dirty(void);
void mark_player_inventory_screen_as_dirty(short player_index, short screen);
void mark_player_inventory_as_dirty(short player_index, short dirty_item);
void mark_interface_collections(bool loading);
void mark_player_network_stats_as_dirty(short player_index);

void set_interface_microphone_recording_state(bool state);


class XML_ElementParser;
XML_ElementParser *Interface_GetParser();
# 48 "shell.cpp" 2
# 1 "../Source_Files/Files/extensions.h" 1
# 30 "../Source_Files/Files/extensions.h"
class FileSpecifier;







void set_physics_file(FileSpecifier& File);

void set_to_default_physics_file(void);


void import_definition_structures(void);

void *get_network_physics_buffer(long *physics_length);
void process_network_physics_model(void *data);
# 49 "shell.cpp" 2
# 1 "../Source_Files/GameWorld/items.h" 1
# 41 "../Source_Files/GameWorld/items.h"
enum
{
 _weapon,
 _ammunition,
 _powerup,
 _item,
 _weapon_powerup,
 _ball,

 NUMBER_OF_ITEM_TYPES,
 _network_statistics= NUMBER_OF_ITEM_TYPES
};

enum
{
 _i_knife,
 _i_magnum,
 _i_magnum_magazine,
 _i_plasma_pistol,
 _i_plasma_magazine,
 _i_assault_rifle,
 _i_assault_rifle_magazine,
 _i_assault_grenade_magazine,
 _i_missile_launcher,
 _i_missile_launcher_magazine,
 _i_invisibility_powerup,
 _i_invincibility_powerup,
 _i_infravision_powerup,
 _i_alien_shotgun,
 _i_alien_shotgun_magazine,
 _i_flamethrower,
 _i_flamethrower_canister,
 _i_extravision_powerup,
 _i_oxygen_powerup,
 _i_energy_powerup,
 _i_double_energy_powerup,
 _i_triple_energy_powerup,
 _i_shotgun,
 _i_shotgun_magazine,
 _i_spht_door_key,
 _i_uplink_chip,

 BALL_ITEM_BASE,
 _i_light_blue_ball= BALL_ITEM_BASE,
 _i_red_ball,
 _i_violet_ball,
 _i_yellow_ball,
 _i_brown_ball,
 _i_orange_ball,
 _i_blue_ball,
 _i_green_ball,


 _i_smg,
 _i_smg_ammo,

 NUMBER_OF_DEFINED_ITEMS
};



short new_item(struct object_location *location, short item_type);

void calculate_player_item_array(short player_index, short type, short *items, short *counts, short *array_count);
void get_header_name(char *buffer, short type);
void get_item_name(char *buffer, short item_id, bool plural);
bool new_item_in_random_location(short item_type);
short count_inventory_lines(short player_index);
void swipe_nearby_items(short player_index);

void mark_item_collections(bool loading);
short get_item_kind(short item_id);

bool unretrieved_items_on_map(void);
bool item_valid_in_current_environment(short item_type);

void trigger_nearby_items(short polygon_index);
short find_player_ball_color(short player_index);

short get_item_shape(short item_id);
bool try_and_add_player_item(short player_index, short type);


struct item_definition *get_item_definition_external(const short type);


short find_player_ball_color(short player_index);


void initialize_items(void);
void animate_items(void);


XML_ElementParser *Items_GetParser();
# 50 "shell.cpp" 2
# 1 "../Source_Files/Misc/interface_menus.h" 1
# 43 "../Source_Files/Misc/interface_menus.h"
enum {
 mGame= 128,
 iPause= 1,
 iSave,
 iRevert,
 iCloseGame,
 iQuitGame
};

enum {
 mInterface= 129,
 iNewGame= 1,
 iLoadGame,
 iGatherGame,
 iJoinGame,
 iPreferences,
 iReplayLastFilm,
 iSaveLastFilm,
 iReplaySavedFilm,
 iCredits,
 iQuit,
 iCenterButton,
 iPlaySingletonLevel
};



enum {
 mFakeEmptyMenu= 130
};
# 51 "shell.cpp" 2
# 1 "../Source_Files/GameWorld/weapons.h" 1
# 52 "shell.cpp" 2
# 1 "../Source_Files/Lua/lua_script.h" 1






# 1 "../Source_Files/Misc/ActionQueues.h" 1
# 48 "../Source_Files/Misc/ActionQueues.h"
class ActionQueues {
public:
    ActionQueues(unsigned int inNumPlayers, unsigned int inQueueSize, bool inZombiesControllable);

    void reset();
    void resetQueue(int inPlayerIndex);

    void enqueueActionFlags(int inPlayerIndex, const uint32* inFlags, int inFlagsCount);
    uint32 dequeueActionFlags(int inPlayerIndex);
    uint32 peekActionFlags(int inPlayerIndex, size_t inElementsFromHead);
    unsigned int countActionFlags(int inPlayerIndex);
    unsigned int totalCapacity(int inPlayerIndex) { return mQueueSize - 1; }
    unsigned int availableCapacity(int inPlayerIndex) { return totalCapacity(inPlayerIndex) - countActionFlags(inPlayerIndex); }
    bool zombiesControllable();
    void setZombiesControllable(bool inZombiesControllable);

    ~ActionQueues();

protected:
    struct action_queue {
     unsigned int read_index, write_index;

     uint32 *buffer;
    };

    unsigned int mNumPlayers;
    unsigned int mQueueSize;
    action_queue* mQueueHeaders;
    uint32* mFlagsBuffer;
    bool mZombiesControllable;


private:
    ActionQueues(ActionQueues&);
    ActionQueues& operator =(ActionQueues&);
};

class ModifiableActionQueues : public ActionQueues {
public:
 ModifiableActionQueues(unsigned int inNumPlayers, unsigned int inQueueSize, bool inZombiesControllable) : ActionQueues(inNumPlayers, inQueueSize, inZombiesControllable) { }


 void modifyActionFlags(int inPlayerIndex, uint32 inFlags, uint32 inFlagsMask);
};
# 8 "../Source_Files/Lua/lua_script.h" 2


void L_Error(const char *message);
void L_Call_Init(bool fRestoringSaved);
void L_Call_Cleanup();
void L_Call_Idle();
void L_Call_PostIdle();
void L_Call_Start_Refuel(short type, short player_index, short panel_side_index);
void L_Call_End_Refuel(short type, short player_index, short panel_side_index);
void L_Call_Tag_Switch(short tag, short player_index);
void L_Call_Light_Switch(short light, short player_index);
void L_Call_Platform_Switch(short platform, short player_index);
void L_Call_Terminal_Enter(short terminal_id, short player_index);
void L_Call_Terminal_Exit(short terminal_id, short player_index);
void L_Call_Pattern_Buffer(short side_index, short player_index);
void L_Call_Got_Item(short type, short player_index);
void L_Call_Light_Activated(short index);
void L_Call_Platform_Activated(short index);
void L_Call_Player_Revived(short player_index);
void L_Call_Player_Killed(short player_index, short aggressor_player_index, short action, short projectile_index);
void L_Call_Monster_Killed(short monster_index, short aggressor_player_index, short projectile_index);
void L_Call_Player_Damaged(short player_index, short aggressor_player_index, short aggressor_monster_index, int16 damage_type, short damage_amount, short projectile_index);
void L_Call_Projectile_Detonated(short type, short owner_index, short polygon, world_point3d location);
void L_Call_Item_Created(short item_index);

void L_Invalidate_Monster(short monster_index);
void L_Invalidate_Projectile(short projectile_index);
void L_Invalidate_Object(short object_index);

bool LoadLuaScript(const char *buffer, size_t len);
bool RunLuaScript();
void CloseLuaScript();

void ExecuteLuaString(const std::string&);
void LoadSoloLua();

void ToggleLuaMute();
void ResetLuaMute();

bool UseLuaCameras();

ActionQueues* GetLuaActionQueues();

void MarkLuaCollections(bool active);

void LuaTexturePaletteClear();
int LuaTexturePaletteSize();
shape_descriptor LuaTexturePaletteTexture(size_t);
int LuaTexturePaletteSelected();

bool LuaPlayerCanWieldWeapons(short player_index);


enum {
  _game_of_most_points,
  _game_of_most_time,
  _game_of_least_points,
  _game_of_least_time,
  NUMBER_OF_GAME_SCORING_MODES
};


enum {
  _game_normal_end_condition,
  _game_no_end_condition,
  _game_end_now_condition,
  NUMBER_OF_GAME_END_CONDITIONS
};

int GetLuaScoringMode();
int GetLuaGameEndCondition();


struct timed_point
{
    int polygon;
    world_point3d point;
    long delta_time;
};

struct timed_angle
{
    short yaw, pitch;
    long delta_time;
};

struct lua_path
{
    short index;
    std::vector<timed_point> path_points;
    short current_point_index;
    long last_point_time;
    std::vector<timed_angle> path_angles;
    short current_angle_index;
    long last_angle_time;
};

struct lua_camera
{
    short index;
    lua_path path;
    long time_elapsed;
    int player_active;
};
# 53 "shell.cpp" 2


# 1 "../Source_Files/RenderMain/OGL_Render.h" 1
# 37 "../Source_Files/RenderMain/OGL_Render.h"
# 1 "../Source_Files/RenderMain/OGL_Setup.h" 1
# 38 "../Source_Files/RenderMain/OGL_Render.h" 2






bool OGL_IsActive();



bool OGL_ClearScreen();






bool OGL_StartRun();



bool OGL_StopRun();




bool OGL_SetInfravisionTint(short Collection, bool IsTinted, float Red, float Green, float Blue);






bool OGL_SetWindow(Rect &ScreenBounds, Rect &ViewBounds, bool UseBackBuffer);


bool OGL_SwapBuffers();


bool OGL_SetView(view_data &View);



bool OGL_SetForeground();


bool OGL_SetForegroundView(bool HorizReflect);


bool OGL_StartMain();
bool OGL_EndMain();



bool OGL_RenderWall(polygon_definition& RenderPolygon, bool IsVertical);
bool OGL_RenderSprite(rectangle_definition& RenderRectangle);


bool OGL_RenderCrosshairs();


bool OGL_RenderText(short BaseX, short BaseY, const char *Text, unsigned char r = 0xff, unsigned char g = 0xff, unsigned char b = 0xff);


bool OGL_Get2D();
# 56 "shell.cpp" 2
# 1 "../Source_Files/XML/XML_ParseTreeRoot.h" 1
# 31 "../Source_Files/XML/XML_ParseTreeRoot.h"
# 1 "../Source_Files/XML/XML_ElementParser.h" 1
# 32 "../Source_Files/XML/XML_ParseTreeRoot.h" 2


extern XML_ElementParser RootParser;


extern void SetupParseTree();
extern void ResetAllMMLValues();
# 57 "shell.cpp" 2
# 1 "../Source_Files/Files/FileHandler.h" 1
# 58 "shell.cpp" 2

# 1 "../Source_Files/CSeries/mytm.h" 1
# 29 "../Source_Files/CSeries/mytm.h"
typedef struct myTMTask myTMTask,*myTMTaskPtr;

extern myTMTaskPtr myTMSetup(
 long time,
 bool (*func)(void));

extern myTMTaskPtr myXTMSetup(
 long time,
 bool (*func)(void));

extern myTMTaskPtr myTMRemove(
 myTMTaskPtr task);

extern void myTMReset(
 myTMTaskPtr task);



extern void myTMCleanup(bool waitForFinishers);


extern bool take_mytm_mutex();
extern bool release_mytm_mutex();


extern void mytm_initialize();
# 60 "shell.cpp" 2

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/stdlib.h" 1 3
# 62 "shell.cpp" 2

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/ctype.h" 1 3
# 64 "shell.cpp" 2

# 1 "../Source_Files/XML/XML_Loader_SDL.h" 1
# 36 "../Source_Files/XML/XML_Loader_SDL.h"
# 1 "../Source_Files/XML/XML_Configure.h" 1
# 30 "../Source_Files/XML/XML_Configure.h"
# 1 "../Source_Files/Expat/expat.h" 1
# 18 "../Source_Files/Expat/expat.h"
# 1 "../Source_Files/Expat/expat_external.h" 1
# 78 "../Source_Files/Expat/expat_external.h"
extern "C" {
# 94 "../Source_Files/Expat/expat_external.h"
typedef char XML_Char;
typedef char XML_LChar;
# 107 "../Source_Files/Expat/expat_external.h"
typedef long XML_Index;
typedef unsigned long XML_Size;



}
# 19 "../Source_Files/Expat/expat.h" 2


extern "C" {


struct XML_ParserStruct;
typedef struct XML_ParserStruct *XML_Parser;


typedef unsigned char XML_Bool;
# 45 "../Source_Files/Expat/expat.h"
enum XML_Status {
  XML_STATUS_ERROR = 0,

  XML_STATUS_OK = 1,

  XML_STATUS_SUSPENDED = 2

};

enum XML_Error {
  XML_ERROR_NONE,
  XML_ERROR_NO_MEMORY,
  XML_ERROR_SYNTAX,
  XML_ERROR_NO_ELEMENTS,
  XML_ERROR_INVALID_TOKEN,
  XML_ERROR_UNCLOSED_TOKEN,
  XML_ERROR_PARTIAL_CHAR,
  XML_ERROR_TAG_MISMATCH,
  XML_ERROR_DUPLICATE_ATTRIBUTE,
  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,
  XML_ERROR_PARAM_ENTITY_REF,
  XML_ERROR_UNDEFINED_ENTITY,
  XML_ERROR_RECURSIVE_ENTITY_REF,
  XML_ERROR_ASYNC_ENTITY,
  XML_ERROR_BAD_CHAR_REF,
  XML_ERROR_BINARY_ENTITY_REF,
  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,
  XML_ERROR_MISPLACED_XML_PI,
  XML_ERROR_UNKNOWN_ENCODING,
  XML_ERROR_INCORRECT_ENCODING,
  XML_ERROR_UNCLOSED_CDATA_SECTION,
  XML_ERROR_EXTERNAL_ENTITY_HANDLING,
  XML_ERROR_NOT_STANDALONE,
  XML_ERROR_UNEXPECTED_STATE,
  XML_ERROR_ENTITY_DECLARED_IN_PE,
  XML_ERROR_FEATURE_REQUIRES_XML_DTD,
  XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING,

  XML_ERROR_UNBOUND_PREFIX,

  XML_ERROR_UNDECLARING_PREFIX,
  XML_ERROR_INCOMPLETE_PE,
  XML_ERROR_XML_DECL,
  XML_ERROR_TEXT_DECL,
  XML_ERROR_PUBLICID,
  XML_ERROR_SUSPENDED,
  XML_ERROR_NOT_SUSPENDED,
  XML_ERROR_ABORTED,
  XML_ERROR_FINISHED,
  XML_ERROR_SUSPEND_PE,

  XML_ERROR_RESERVED_PREFIX_XML,
  XML_ERROR_RESERVED_PREFIX_XMLNS,
  XML_ERROR_RESERVED_NAMESPACE_URI
};

enum XML_Content_Type {
  XML_CTYPE_EMPTY = 1,
  XML_CTYPE_ANY,
  XML_CTYPE_MIXED,
  XML_CTYPE_NAME,
  XML_CTYPE_CHOICE,
  XML_CTYPE_SEQ
};

enum XML_Content_Quant {
  XML_CQUANT_NONE,
  XML_CQUANT_OPT,
  XML_CQUANT_REP,
  XML_CQUANT_PLUS
};
# 135 "../Source_Files/Expat/expat.h"
typedef struct XML_cp XML_Content;

struct XML_cp {
  enum XML_Content_Type type;
  enum XML_Content_Quant quant;
  XML_Char * name;
  unsigned int numchildren;
  XML_Content * children;
};






typedef void ( *XML_ElementDeclHandler) (void *userData,
                                                const XML_Char *name,
                                                XML_Content *model);

 void
XML_SetElementDeclHandler(XML_Parser parser,
                          XML_ElementDeclHandler eldecl);
# 166 "../Source_Files/Expat/expat.h"
typedef void ( *XML_AttlistDeclHandler) (
                                    void *userData,
                                    const XML_Char *elname,
                                    const XML_Char *attname,
                                    const XML_Char *att_type,
                                    const XML_Char *dflt,
                                    int isrequired);

 void
XML_SetAttlistDeclHandler(XML_Parser parser,
                          XML_AttlistDeclHandler attdecl);
# 186 "../Source_Files/Expat/expat.h"
typedef void ( *XML_XmlDeclHandler) (void *userData,
                                            const XML_Char *version,
                                            const XML_Char *encoding,
                                            int standalone);

 void
XML_SetXmlDeclHandler(XML_Parser parser,
                      XML_XmlDeclHandler xmldecl);


typedef struct {
  void *(*malloc_fcn)(size_t size);
  void *(*realloc_fcn)(void *ptr, size_t size);
  void (*free_fcn)(void *ptr);
} XML_Memory_Handling_Suite;




 XML_Parser
XML_ParserCreate(const XML_Char *encoding);
# 219 "../Source_Files/Expat/expat.h"
 XML_Parser
XML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);
# 232 "../Source_Files/Expat/expat.h"
 XML_Parser
XML_ParserCreate_MM(const XML_Char *encoding,
                    const XML_Memory_Handling_Suite *memsuite,
                    const XML_Char *namespaceSeparator);
# 246 "../Source_Files/Expat/expat.h"
 XML_Bool
XML_ParserReset(XML_Parser parser, const XML_Char *encoding);




typedef void ( *XML_StartElementHandler) (void *userData,
                                                 const XML_Char *name,
                                                 const XML_Char **atts);

typedef void ( *XML_EndElementHandler) (void *userData,
                                               const XML_Char *name);



typedef void ( *XML_CharacterDataHandler) (void *userData,
                                                  const XML_Char *s,
                                                  int len);


typedef void ( *XML_ProcessingInstructionHandler) (
                                                void *userData,
                                                const XML_Char *target,
                                                const XML_Char *data);


typedef void ( *XML_CommentHandler) (void *userData,
                                            const XML_Char *data);

typedef void ( *XML_StartCdataSectionHandler) (void *userData);
typedef void ( *XML_EndCdataSectionHandler) (void *userData);
# 291 "../Source_Files/Expat/expat.h"
typedef void ( *XML_DefaultHandler) (void *userData,
                                            const XML_Char *s,
                                            int len);




typedef void ( *XML_StartDoctypeDeclHandler) (
                                            void *userData,
                                            const XML_Char *doctypeName,
                                            const XML_Char *sysid,
                                            const XML_Char *pubid,
                                            int has_internal_subset);





typedef void ( *XML_EndDoctypeDeclHandler)(void *userData);
# 329 "../Source_Files/Expat/expat.h"
typedef void ( *XML_EntityDeclHandler) (
                              void *userData,
                              const XML_Char *entityName,
                              int is_parameter_entity,
                              const XML_Char *value,
                              int value_length,
                              const XML_Char *base,
                              const XML_Char *systemId,
                              const XML_Char *publicId,
                              const XML_Char *notationName);

 void
XML_SetEntityDeclHandler(XML_Parser parser,
                         XML_EntityDeclHandler handler);
# 353 "../Source_Files/Expat/expat.h"
typedef void ( *XML_UnparsedEntityDeclHandler) (
                                    void *userData,
                                    const XML_Char *entityName,
                                    const XML_Char *base,
                                    const XML_Char *systemId,
                                    const XML_Char *publicId,
                                    const XML_Char *notationName);





typedef void ( *XML_NotationDeclHandler) (
                                    void *userData,
                                    const XML_Char *notationName,
                                    const XML_Char *base,
                                    const XML_Char *systemId,
                                    const XML_Char *publicId);







typedef void ( *XML_StartNamespaceDeclHandler) (
                                    void *userData,
                                    const XML_Char *prefix,
                                    const XML_Char *uri);

typedef void ( *XML_EndNamespaceDeclHandler) (
                                    void *userData,
                                    const XML_Char *prefix);
# 396 "../Source_Files/Expat/expat.h"
typedef int ( *XML_NotStandaloneHandler) (void *userData);
# 432 "../Source_Files/Expat/expat.h"
typedef int ( *XML_ExternalEntityRefHandler) (
                                    XML_Parser parser,
                                    const XML_Char *context,
                                    const XML_Char *base,
                                    const XML_Char *systemId,
                                    const XML_Char *publicId);
# 449 "../Source_Files/Expat/expat.h"
typedef void ( *XML_SkippedEntityHandler) (
                                    void *userData,
                                    const XML_Char *entityName,
                                    int is_parameter_entity);
# 506 "../Source_Files/Expat/expat.h"
typedef struct {
  int map[256];
  void *data;
  int ( *convert)(void *data, const char *s);
  void ( *release)(void *data);
} XML_Encoding;
# 528 "../Source_Files/Expat/expat.h"
typedef int ( *XML_UnknownEncodingHandler) (
                                    void *encodingHandlerData,
                                    const XML_Char *name,
                                    XML_Encoding *info);

 void
XML_SetElementHandler(XML_Parser parser,
                      XML_StartElementHandler start,
                      XML_EndElementHandler end);

 void
XML_SetStartElementHandler(XML_Parser parser,
                           XML_StartElementHandler handler);

 void
XML_SetEndElementHandler(XML_Parser parser,
                         XML_EndElementHandler handler);

 void
XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler);

 void
XML_SetProcessingInstructionHandler(XML_Parser parser,
                                    XML_ProcessingInstructionHandler handler);
 void
XML_SetCommentHandler(XML_Parser parser,
                      XML_CommentHandler handler);

 void
XML_SetCdataSectionHandler(XML_Parser parser,
                           XML_StartCdataSectionHandler start,
                           XML_EndCdataSectionHandler end);

 void
XML_SetStartCdataSectionHandler(XML_Parser parser,
                                XML_StartCdataSectionHandler start);

 void
XML_SetEndCdataSectionHandler(XML_Parser parser,
                              XML_EndCdataSectionHandler end);





 void
XML_SetDefaultHandler(XML_Parser parser,
                      XML_DefaultHandler handler);





 void
XML_SetDefaultHandlerExpand(XML_Parser parser,
                            XML_DefaultHandler handler);

 void
XML_SetDoctypeDeclHandler(XML_Parser parser,
                          XML_StartDoctypeDeclHandler start,
                          XML_EndDoctypeDeclHandler end);

 void
XML_SetStartDoctypeDeclHandler(XML_Parser parser,
                               XML_StartDoctypeDeclHandler start);

 void
XML_SetEndDoctypeDeclHandler(XML_Parser parser,
                             XML_EndDoctypeDeclHandler end);

 void
XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
                                 XML_UnparsedEntityDeclHandler handler);

 void
XML_SetNotationDeclHandler(XML_Parser parser,
                           XML_NotationDeclHandler handler);

 void
XML_SetNamespaceDeclHandler(XML_Parser parser,
                            XML_StartNamespaceDeclHandler start,
                            XML_EndNamespaceDeclHandler end);

 void
XML_SetStartNamespaceDeclHandler(XML_Parser parser,
                                 XML_StartNamespaceDeclHandler start);

 void
XML_SetEndNamespaceDeclHandler(XML_Parser parser,
                               XML_EndNamespaceDeclHandler end);

 void
XML_SetNotStandaloneHandler(XML_Parser parser,
                            XML_NotStandaloneHandler handler);

 void
XML_SetExternalEntityRefHandler(XML_Parser parser,
                                XML_ExternalEntityRefHandler handler);





 void
XML_SetExternalEntityRefHandlerArg(XML_Parser parser,
                                   void *arg);

 void
XML_SetSkippedEntityHandler(XML_Parser parser,
                            XML_SkippedEntityHandler handler);

 void
XML_SetUnknownEncodingHandler(XML_Parser parser,
                              XML_UnknownEncodingHandler handler,
                              void *encodingHandlerData);





 void
XML_DefaultCurrent(XML_Parser parser);
# 666 "../Source_Files/Expat/expat.h"
 void
XML_SetReturnNSTriplet(XML_Parser parser, int do_nst);


 void
XML_SetUserData(XML_Parser parser, void *userData);
# 682 "../Source_Files/Expat/expat.h"
 enum XML_Status
XML_SetEncoding(XML_Parser parser, const XML_Char *encoding);





 void
XML_UseParserAsHandlerArg(XML_Parser parser);
# 710 "../Source_Files/Expat/expat.h"
 enum XML_Error
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);
# 722 "../Source_Files/Expat/expat.h"
 enum XML_Status
XML_SetBase(XML_Parser parser, const XML_Char *base);

 const XML_Char *
XML_GetBase(XML_Parser parser);







 int
XML_GetSpecifiedAttributeCount(XML_Parser parser);






 int
XML_GetIdAttributeIndex(XML_Parser parser);
# 754 "../Source_Files/Expat/expat.h"
 enum XML_Status
XML_Parse(XML_Parser parser, const char *s, int len, int isFinal);

 void *
XML_GetBuffer(XML_Parser parser, int len);

 enum XML_Status
XML_ParseBuffer(XML_Parser parser, int len, int isFinal);
# 794 "../Source_Files/Expat/expat.h"
 enum XML_Status
XML_StopParser(XML_Parser parser, XML_Bool resumable);
# 809 "../Source_Files/Expat/expat.h"
 enum XML_Status
XML_ResumeParser(XML_Parser parser);

enum XML_Parsing {
  XML_INITIALIZED,
  XML_PARSING,
  XML_FINISHED,
  XML_SUSPENDED
};

typedef struct {
  enum XML_Parsing parsing;
  XML_Bool finalBuffer;
} XML_ParsingStatus;






 void
XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status);
# 848 "../Source_Files/Expat/expat.h"
 XML_Parser
XML_ExternalEntityParserCreate(XML_Parser parser,
                               const XML_Char *context,
                               const XML_Char *encoding);

enum XML_ParamEntityParsing {
  XML_PARAM_ENTITY_PARSING_NEVER,
  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,
  XML_PARAM_ENTITY_PARSING_ALWAYS
};
# 882 "../Source_Files/Expat/expat.h"
 int
XML_SetParamEntityParsing(XML_Parser parser,
                          enum XML_ParamEntityParsing parsing);




 enum XML_Error
XML_GetErrorCode(XML_Parser parser);
# 908 "../Source_Files/Expat/expat.h"
 XML_Size XML_GetCurrentLineNumber(XML_Parser parser);
 XML_Size XML_GetCurrentColumnNumber(XML_Parser parser);
 XML_Index XML_GetCurrentByteIndex(XML_Parser parser);




 int
XML_GetCurrentByteCount(XML_Parser parser);
# 928 "../Source_Files/Expat/expat.h"
 const char *
XML_GetInputContext(XML_Parser parser,
                    int *offset,
                    int *size);







 void
XML_FreeContentModel(XML_Parser parser, XML_Content *model);


 void *
XML_MemMalloc(XML_Parser parser, size_t size);

 void *
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);

 void
XML_MemFree(XML_Parser parser, void *ptr);


 void
XML_ParserFree(XML_Parser parser);


 const XML_LChar *
XML_ErrorString(enum XML_Error code);


 const XML_LChar *
XML_ExpatVersion(void);

typedef struct {
  int major;
  int minor;
  int micro;
} XML_Expat_Version;




 XML_Expat_Version
XML_ExpatVersionInfo(void);


enum XML_FeatureEnum {
  XML_FEATURE_END = 0,
  XML_FEATURE_UNICODE,
  XML_FEATURE_UNICODE_WCHAR_T,
  XML_FEATURE_DTD,
  XML_FEATURE_CONTEXT_BYTES,
  XML_FEATURE_MIN_SIZE,
  XML_FEATURE_SIZEOF_XML_CHAR,
  XML_FEATURE_SIZEOF_XML_LCHAR,
  XML_FEATURE_NS,
  XML_FEATURE_LARGE_SIZE

};

typedef struct {
  enum XML_FeatureEnum feature;
  const XML_LChar *name;
  long int value;
} XML_Feature;

 const XML_Feature *
XML_GetFeatureList(void);
# 1011 "../Source_Files/Expat/expat.h"
}
# 31 "../Source_Files/XML/XML_Configure.h" 2


class XML_Configure
{
private:


 static void StaticStartElement(void *UserData, const char *Name, const char **Attributes);
 static void StaticEndElement(void *UserData, const char *Name);
 static void StaticCharacterData(void *UserData, const char *String, int Length);


 void StartElement(const char *Name, const char **Attributes);
 void EndElement(const char *Name);
 void CharacterData(const char *String, int Length);


 int NumInterpretErrors;


 XML_Parser Parser;

protected:




 virtual bool GetData()=0;



 char *Buffer;

 size_t BufLen;

 bool LastOne;


 virtual void ReportReadError() {}


 virtual void ReportParseError(const char *ErrorString, int LineNumber) {}


 virtual void ReportInterpretError(const char *ErrorString) {}


 virtual bool RequestAbort() {return false;}

public:


 bool DoParse();


 int GetNumInterpretErrors() {return NumInterpretErrors;}


 void ComposeInterpretError(const char *Format, ...);




 XML_ElementParser *CurrentElement;


 XML_Configure() {CurrentElement = __null;}
 virtual ~XML_Configure() {}
};
# 37 "../Source_Files/XML/XML_Loader_SDL.h" 2

class FileSpecifier;


class XML_Loader_SDL : public XML_Configure {



 char FileName[256];

public:
 XML_Loader_SDL() : data(__null) {FileName[0] = 0;}
 ~XML_Loader_SDL() {delete[] data; data = __null;}

 bool ParseFile(FileSpecifier &file);
 bool ParseDirectory(FileSpecifier &dir);

protected:
 virtual bool GetData();
 virtual void ReportReadError();
 virtual void ReportParseError(const char *ErrorString, int LineNumber);
 virtual void ReportInterpretError(const char *ErrorString);
 virtual bool RequestAbort();

private:
 char *data;
 long data_size;
};
# 66 "shell.cpp" 2
# 1 "../Source_Files/Files/resource_manager.h" 1
# 33 "../Source_Files/Files/resource_manager.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 34 "../Source_Files/Files/resource_manager.h" 2


using std::vector;


class FileSpecifier;
class LoadedResource;

extern void initialize_resources(void);

extern SDL_RWops *open_res_file(FileSpecifier &file);
extern void close_res_file(SDL_RWops *file);
extern SDL_RWops *open_res_file_from_rwops(SDL_RWops *file);
extern SDL_RWops *cur_res_file(void);
extern void use_res_file(SDL_RWops *file);

extern size_t count_1_resources(uint32 type);
extern size_t count_resources(uint32 type);

extern void get_1_resource_id_list(uint32 type, vector<int> &ids);
extern void get_resource_id_list(uint32 type, vector<int> &ids);

extern bool get_1_resource(uint32 type, int id, LoadedResource &rsrc);
extern bool get_resource(uint32 type, int id, LoadedResource &rsrc);

extern bool get_1_ind_resource(uint32 type, int index, LoadedResource &rsrc);
extern bool get_ind_resource(uint32 type, int index, LoadedResource &rsrc);

extern bool has_1_resource(uint32 type, int id);
extern bool has_resource(uint32 type, int id);
# 67 "shell.cpp" 2
# 1 "../Source_Files/Misc/sdl_dialogs.h" 1
# 33 "../Source_Files/Misc/sdl_dialogs.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iterate.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/iterate.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/arithmetic/dec.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/iterate.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/elem.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/elem.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/data.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/data.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/tuple/elem.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/data.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/elem.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/size.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/array/elem.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/iterate.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/slot.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/slot.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/def.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/slot.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/iterate.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iterate.hpp" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cassert" 1 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cassert" 3
       
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cassert" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/assert.h" 1 3





extern "C" {
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/assert.h" 3
void __assert (const char *, int, const char *) __attribute__ ((__noreturn__));

void __assert_func (const char *, int, const char *, const char *) __attribute__ ((__noreturn__));



}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cassert" 2 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/algorithm" 1 3
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/algorithm" 3
       
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/algorithm" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdlib" 2 3
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 1 3
# 104 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3
       
# 105 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);




  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);
# 152 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);







  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
# 222 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
# 283 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);




  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 379 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);
# 478 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter, _Generator&);

  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

}
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 1 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 152 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 201 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
# 274 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
# 347 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1, __comp);
    }
# 369 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 409 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 448 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
# 474 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }
# 568 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_heap.h" 3
}
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 2 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 87 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 121 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     

      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 281 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 366 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 603 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 648 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 684 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 720 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 759 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 801 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 840 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
# 879 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1106 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1132 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = std::__gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = (*__first);
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = (*(__p - __l));
        __p -= __l;
      }

    *__p = (*(__p + __k));
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = (*(__p + __k));
        __p += __k;
      }
    *__p = (*(__p - __l));
    __p -= __l;
  }
     }

   *__p = (__tmp);
   ++__first;
 }
    }
# 1324 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1357 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1514 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1595 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 1660 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }


  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2069 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2119 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2167 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2217 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2271 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
     
      ;
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2333 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

      ;

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2394 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     
      ;
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2427 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     

      ;

      ;


      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 2774 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 2828 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
        __first + __step_size,
        __first + __two_step,
        __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size,
       __first + __step_size, __last,
       __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
       __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3113 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3161 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3215 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3271 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3326 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3382 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3442 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3478 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3768 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 3783 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3803 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 3826 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 3854 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3892 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 3923 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 3954 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 3985 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4009 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4048 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4118 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4191 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4226 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4267 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4302 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4334 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4365 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4396 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4423 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 4458 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4496 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4527 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 4554 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 4585 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4618 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 4656 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 4693 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 4731 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 4768 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 4803 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 4843 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4905 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4964 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5005 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5050 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5116 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5182 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5238 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5295 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5355 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5412 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 5477 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5533 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 5560 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 5614 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }

}
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/algorithm" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/throw_exception.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/throw_exception.hpp" 3
namespace boost
{







template<class E> inline void throw_exception(E const & e)
{
    throw e;
}



}
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/stdexcept" 1 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/stdexcept" 3
       
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default"))) {






  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual
    ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual
    ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };

}
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/typeinfo" 1 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/typeinfo" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 85 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name; }
# 122 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }

    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/assert.hpp" 1 3
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/assert.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/assert.h" 1 3





extern "C" {
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/assert.h" 3
void __assert (const char *, int, const char *) __attribute__ ((__noreturn__));

void __assert_func (const char *, int, const char *, const char *) __attribute__ ((__noreturn__));



}
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/assert.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_integral.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_integral.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_integral.hpp" 2 3

namespace boost {




template< typename T > struct is_integral : ::boost::integral_constant<bool,false> { };

template<> struct is_integral< unsigned char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< signed char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< bool > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const volatile > : ::boost::integral_constant<bool,true> { };





template<> struct is_integral< wchar_t > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const volatile > : ::boost::integral_constant<bool,true> { };
# 60 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_integral.hpp" 3
template<> struct is_integral< ::boost::ulong_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< ::boost::long_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const volatile > : ::boost::integral_constant<bool,true> { };





}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 70 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_integral.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/composite_traits.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/composite_traits.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_array.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_array.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_array.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_array.hpp" 2 3

namespace boost {



template< typename T > struct is_array : ::boost::integral_constant<bool,false> { };

template< typename T, std::size_t N > struct is_array< T[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T volatile[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const volatile[N] > : ::boost::integral_constant<bool,true> { };

template< typename T > struct is_array< T[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T volatile[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const volatile[] > : ::boost::integral_constant<bool,true> { };
# 86 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_array.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 89 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_array.hpp" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/composite_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_reference.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_reference.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_reference.hpp" 2 3

namespace boost {

namespace detail {
# 55 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_reference.hpp" 3
template <typename T>
struct add_reference_impl
{
    typedef T& type;
};


template< typename T > struct add_reference_impl<T&> { typedef T& type; };





template<> struct add_reference_impl<void> { typedef void type; };

template<> struct add_reference_impl<void const> { typedef void const type; };
template<> struct add_reference_impl<void volatile> { typedef void volatile type; };
template<> struct add_reference_impl<void const volatile> { typedef void const volatile type; };


}

template< typename T > struct add_reference { typedef typename boost::detail::add_reference_impl<T>::type type; };







}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/add_reference.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_arithmetic.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_arithmetic.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_float.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_float.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_float.hpp" 2 3

namespace boost {


template< typename T > struct is_float : ::boost::integral_constant<bool,false> { };
template<> struct is_float< float > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< long double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const volatile > : ::boost::integral_constant<bool,true> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_float.hpp" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_arithmetic.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_or.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_or.hpp" 3
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};

template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};

}
}
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_arithmetic.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_arithmetic.hpp" 2 3

namespace boost {

namespace detail {

template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value);




};

}


template< typename T > struct is_arithmetic : ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_arithmetic.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/yes_no_type.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/yes_no_type.hpp" 3
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/ice.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/ice.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_and.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_and.hpp" 3
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};

template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};

}
}
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/ice.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_not.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_not.hpp" 3
namespace boost {
namespace type_traits {

template <bool b>
struct ice_not
{
    static const bool value = true;
};

template <>
struct ice_not<true>
{
    static const bool value = false;
};

}
}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/ice.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_eq.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/ice_eq.hpp" 3
namespace boost {
namespace type_traits {

template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};

template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};


template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;


}
}
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/ice.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_void.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_void.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_void.hpp" 2 3

namespace boost {


template< typename T > struct is_void : ::boost::integral_constant<bool,false> { };
template<> struct is_void< void > : ::boost::integral_constant<bool,true> { };


template<> struct is_void< void const > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void const volatile > : ::boost::integral_constant<bool,true> { };


}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_void.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_abstract.hpp" 1 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_abstract.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_union.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_union.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/intrinsics.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_union.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_union.hpp" 2 3

namespace boost {

namespace detail {
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_union.hpp" 3
template <typename T> struct is_union_impl
{
   static const bool value = false;
};

}

template< typename T > struct is_union : ::boost::integral_constant<bool,::boost::detail::is_union_impl<T>::value> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_union.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 2 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 2 3

namespace boost {

namespace detail {
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 3
template <class U> ::boost::type_traits::yes_type is_class_tester(void(U::*)(void));
template <class U> ::boost::type_traits::no_type is_class_tester(...);

template <typename T>
struct is_class_impl
{

    static const bool value = (::boost::type_traits::ice_and< sizeof(is_class_tester<T>(0)) == sizeof(::boost::type_traits::yes_type), ::boost::type_traits::ice_not< ::boost::is_union<T>::value >::value >::value);





};
# 115 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 3
}





template< typename T > struct is_class : ::boost::integral_constant<bool,::boost::detail::is_class_impl<T>::value> { };


}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 127 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_class.hpp" 2 3
# 54 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_abstract.hpp" 2 3





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 60 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_abstract.hpp" 2 3


namespace boost {
namespace detail{


template<class T>
struct is_abstract_imp2
{




   template<class U>
   static type_traits::no_type check_sig(U (*)[1]);
   template<class U>
   static type_traits::yes_type check_sig(...);




   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( sizeof(T) != 0 ) >)> boost_static_assert_typedef_81;




   static const unsigned s1 = sizeof(is_abstract_imp2<T>::template check_sig<T>(0));




   static const bool value = (s1 == sizeof(type_traits::yes_type));

};

template <bool v>
struct is_abstract_select
{
   template <class T>
   struct rebind
   {
      typedef is_abstract_imp2<T> type;
   };
};
template <>
struct is_abstract_select<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_abstract_imp
{
   typedef is_abstract_select< ::boost::is_class<T>::value> selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;

   static const bool value = type::value;
};


}


template< typename T > struct is_abstract : ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { };




}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 136 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_abstract.hpp" 2 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 2 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 2 3

namespace boost {
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
namespace detail {
# 113 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
struct any_conversion
{
    template <typename T> any_conversion(const volatile T&);
    template <typename T> any_conversion(T&);
};

template <typename T> struct checker
{
    static boost::type_traits::no_type _m_check(any_conversion ...);
    static boost::type_traits::yes_type _m_check(T, int);
};

template <typename From, typename To>
struct is_convertible_basic_impl
{
    static From _m_from;
    static bool const value = sizeof( detail::checker<To>::_m_check(_m_from, 0) )
        == sizeof(::boost::type_traits::yes_type);
};
# 282 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
template <typename From, typename To>
struct is_convertible_impl
{
    typedef typename add_reference<From>::type ref_type;
    static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type,To>::value, ::boost::is_void<To>::value >::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value >::value >::value);
# 297 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
};


template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};

template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};

template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{

   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,

      ::boost::is_abstract<To>::value



   > selector;



   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};

template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
# 385 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
    template<> struct is_convertible_impl< void,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const volatile > { static const bool value = (true); };
# 395 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 3
template< typename To > struct is_convertible_impl< void,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void > { static const bool value = (true); };

template< typename To > struct is_convertible_impl< void const,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void volatile,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void const volatile,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void const > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void volatile > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void const volatile > { static const bool value = (true); };



}

template< typename From, typename To > struct is_convertible : ::boost::integral_constant<bool,(::boost::detail::is_convertible_impl_dispatch<From,To>::value)> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 414 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_convertible.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 2 3
# 30 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 2 3

namespace boost {



namespace detail {



template <typename T>
struct is_class_or_union
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_class<T>::value , ::boost::is_union<T>::value >::value);




};
# 75 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 3
struct int_convertible
{
    int_convertible(int);
};



template <bool is_typename_arithmetic_or_reference = true>
struct is_enum_helper
{
    template <typename T> struct type
    {
        static const bool value = false;
    };
};

template <>
struct is_enum_helper<false>
{
    template <typename T> struct type
       : ::boost::is_convertible<typename boost::add_reference<T>::type,::boost::detail::int_convertible>
    {
    };
};

template <typename T> struct is_enum_impl
{
# 112 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 3
   static const bool selector = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value , ::boost::is_reference<T>::value , ::boost::is_function<T>::value , is_class_or_union<T>::value , is_array<T>::value >::value);
# 149 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 3
    typedef ::boost::detail::is_enum_helper<selector> se_t;


    typedef typename se_t::template type<T> helper;
    static const bool value = helper::value;
};


template<> struct is_enum_impl< void > { static const bool value = (false); };

template<> struct is_enum_impl< void const > { static const bool value = (false); };
template<> struct is_enum_impl< void volatile > { static const bool value = (false); };
template<> struct is_enum_impl< void const volatile > { static const bool value = (false); };


}

template< typename T > struct is_enum : ::boost::integral_constant<bool,::boost::detail::is_enum_impl<T>::value> { };
# 176 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 179 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_enum.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/composite_traits.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3
namespace boost {
namespace type_traits {

template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};





template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };



template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };


template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };



template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
# 776 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3
}
}
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 2 3
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 2 3

namespace boost {



template< typename T > struct is_member_function_pointer : ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<T>::value> { };
# 122 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 125 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_function_pointer.hpp" 2 3
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 2 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 2 3

namespace boost {






template< typename T > struct is_member_pointer : ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { };
template< typename T, typename U > struct is_member_pointer< U T::* > : ::boost::integral_constant<bool,true> { };
# 104 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 107 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_member_pointer.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/composite_traits.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pointer.hpp" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pointer.hpp" 2 3

namespace boost {



namespace detail {

template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pointer.hpp" 3
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };
template< typename T > struct is_pointer_helper<T* const> { static const bool value = true; };
template< typename T > struct is_pointer_helper<T* volatile> { static const bool value = true; };
template< typename T > struct is_pointer_helper<T* const volatile> { static const bool value = true; };



template< typename T >
struct is_pointer_impl
{
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<T>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value);







};

}

template< typename T > struct is_pointer : ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { };
# 145 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pointer.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 148 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pointer.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/composite_traits.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/if.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/if.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/value_wknd.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/value_wknd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/integral.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/eti.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/value_wknd.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/value_wknd.hpp" 3
}}}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/if.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_spec.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_spec.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda_fwd.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda_fwd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/void_fwd.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/void_fwd.hpp" 3
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda_fwd.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_fwd.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_fwd.hpp" 3
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na.hpp" 2 3



namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na.hpp" 3
}}
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda_fwd.hpp" 2 3





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/lambda_arity_param.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda_fwd.hpp" 2 3


namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_spec.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/arity.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/arity.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/dtp.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/arity.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_spec.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/enum.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/limits/arity.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/logical/and.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/logical/and.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/logical/bitand.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/logical/and.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/identity.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/identity.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/facilities/identity.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/identity.hpp" 2 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/empty.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/arithmetic/add.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/arithmetic/add.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_left.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_left.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_left.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_left.hpp" 2 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_left.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_left.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_left.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/expr_iif.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/adt.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/adt.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/is_binary.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/is_binary.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/check.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/is_binary.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/adt.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/logical/compl.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/adt.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_left.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_right.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_right.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_right.hpp" 2 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_right.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_right.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_right.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/reverse.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/detail/fold_right.hpp" 2 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/list/fold_right.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/detail/while.hpp" 1 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/control/while.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/arithmetic/add.hpp" 2 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/arithmetic/sub.hpp" 1 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/if.hpp" 2 3





namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;

   
};
# 131 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/if.hpp" 3
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/size_t_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/size_t_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t_fwd.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t_fwd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t_fwd.hpp" 2 3

namespace mpl_ {

template< std::size_t N > struct size_t;

}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t.hpp" 2 3





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;





    typedef size_t type;

    typedef std::size_t value_type;
    typedef integral_c_tag tag;
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;






    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};


template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;


}
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/size_t.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 3
namespace boost {

template <typename T> struct alignment_of;


namespace detail {

template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};


template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{
    static const std::size_t value = (::boost::detail::alignment_logic< sizeof(::boost::detail::alignment_of_hack<T>) - sizeof(T), sizeof(T) >::value);




};

}

template< typename T > struct alignment_of : ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { };




template <typename T>
struct alignment_of<T&>
    : alignment_of<T*>
{
};
# 81 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 3
template<> struct alignment_of<void> : ::boost::integral_constant<std::size_t,0> { };

template<> struct alignment_of<void const> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void volatile> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void const volatile> : ::boost::integral_constant<std::size_t,0> { };


}
# 97 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1 3
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/alignment_of.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/utility/enable_if.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/utility/enable_if.hpp" 3
namespace boost
{

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function_equal.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function_equal.hpp" 3
namespace boost {

template<typename F, typename G>
  bool function_equal_impl(const F& f, const G& g, long)
  { return f == g; }




template<typename F, typename G>
  bool function_equal(const F& f, const G& g)
  { return function_equal_impl(f, g, 0); }

}
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstring" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstring" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstring" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstring" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/string.h" 1 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstring" 2 3
# 78 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstring" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }

}
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 2 3
# 81 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 3
namespace boost {
# 91 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 3
template<typename Signature, typename Allocator = std::allocator<void> >
class function;


template<typename Signature, typename Allocator>
inline void swap(function<Signature, Allocator>& f1,
                 function<Signature, Allocator>& f2)
{
  f1.swap(f2);
}

}


namespace boost {
  namespace detail {
    namespace function {
      class X;







      union function_buffer
      {

        void* obj_ptr;



        const void* const_obj_ptr;


        mutable void (*func_ptr)();


        struct bound_memfunc_ptr_t {
          void (X::*memfunc_ptr)(int);
          void* obj_ptr;
        } bound_memfunc_ptr;


        mutable char data;
      };







      struct unusable
      {
        unusable() {}
        template<typename T> unusable(const T&) {}
      };





      template<typename T> struct function_return_type { typedef T type; };

      template<>
      struct function_return_type<void>
      {
        typedef unusable type;
      };


      enum functor_manager_operation_type {
        clone_functor_tag,
        destroy_functor_tag,
        check_functor_type_tag,
        get_functor_type_tag
      };


      struct function_ptr_tag {};
      struct function_obj_tag {};
      struct member_ptr_tag {};
      struct function_obj_ref_tag {};

      template<typename F>
      class get_function_tag
      {
        typedef typename mpl::if_c<(is_pointer<F>::value),
                                   function_ptr_tag,
                                   function_obj_tag>::type ptr_or_obj_tag;

        typedef typename mpl::if_c<(is_member_pointer<F>::value),
                                   member_ptr_tag,
                                   ptr_or_obj_tag>::type ptr_or_obj_or_mem_tag;

        typedef typename mpl::if_c<(is_reference_wrapper<F>::value),
                                   function_obj_ref_tag,
                                   ptr_or_obj_or_mem_tag>::type or_ref_tag;

      public:
        typedef or_ref_tag type;
      };



      template<typename F>
      struct reference_manager
      {
        static inline void
        get(const function_buffer& in_buffer, function_buffer& out_buffer,
            functor_manager_operation_type op)
        {
          switch (op) {
          case clone_functor_tag:
            out_buffer.obj_ptr = in_buffer.obj_ptr;
            return;

          case destroy_functor_tag:
            out_buffer.obj_ptr = 0;
            return;

          case check_functor_type_tag:
            {



              const std::type_info& check_type =
                *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
              if ((std::strcmp((check_type).name(),(typeid(F)).name()) == 0))
                out_buffer.obj_ptr = in_buffer.obj_ptr;
              else
                out_buffer.obj_ptr = 0;
            }
            return;

          case get_functor_type_tag:
            out_buffer.const_obj_ptr = &typeid(F);
            return;
          }
        }
      };





      template<typename F>
      struct function_allows_small_object_optimization
      {
        static const bool value = ((sizeof(F) <= sizeof(function_buffer) && (alignment_of<function_buffer>::value % alignment_of<F>::value == 0)));




      };





      template<typename Functor, typename Allocator>
      struct functor_manager
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          if (op == clone_functor_tag)
            out_buffer.func_ptr = in_buffer.func_ptr;
          else if (op == destroy_functor_tag)
            out_buffer.func_ptr = 0;
          else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = &in_buffer.func_ptr;
            else
              out_buffer.obj_ptr = 0;
          }
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::true_)
        {
          if (op == clone_functor_tag) {
            const functor_type* in_functor =
              reinterpret_cast<const functor_type*>(&in_buffer.data);
            new ((void*)&out_buffer.data) functor_type(*in_functor);
          } else if (op == destroy_functor_tag) {

            reinterpret_cast<functor_type*>(&out_buffer.data)->~Functor();
          } else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = &in_buffer.data;
            else
              out_buffer.obj_ptr = 0;
          }
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::false_)
        {

          typedef typename Allocator::template rebind<functor_type>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;





          allocator_type allocator;


          if (op == clone_functor_tag) {


            const functor_type* f =
              (const functor_type*)(in_buffer.obj_ptr);



            pointer_type copy = allocator.allocate(1);
            allocator.construct(copy, *f);


            functor_type* new_f = static_cast<functor_type*>(copy);



            out_buffer.obj_ptr = new_f;
          } else if (op == destroy_functor_tag) {

            functor_type* f =
              static_cast<functor_type*>(out_buffer.obj_ptr);




            pointer_type victim = static_cast<pointer_type>(f);


            allocator.destroy(victim);
            allocator.deallocate(victim, 1);



            out_buffer.obj_ptr = 0;
          } else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = in_buffer.obj_ptr;
            else
              out_buffer.obj_ptr = 0;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.const_obj_ptr = &typeid(functor_type);
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };


      struct useless_clear_type {};
# 457 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 3
      struct vtable_base
      {
        vtable_base() : manager(0) { }
        void (*manager)(const function_buffer& in_buffer,
                        function_buffer& out_buffer,
                        functor_manager_operation_type op);
      };
    }
  }







class function_base
{
public:
  function_base() : vtable(0) { }


  bool empty() const { return !vtable; }



  const std::type_info& target_type() const
  {
    if (!vtable) return typeid(void);

    detail::function::function_buffer type;
    vtable->manager(functor, type, detail::function::get_functor_type_tag);
    return *static_cast<const std::type_info*>(type.const_obj_ptr);
  }

  template<typename Functor>
    Functor* target()
    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.const_obj_ptr = &typeid(Functor);
      vtable->manager(functor, type_result,
                      detail::function::check_functor_type_tag);
      return static_cast<Functor*>(type_result.obj_ptr);
    }

  template<typename Functor>



    const Functor* target() const

    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.const_obj_ptr = &typeid(Functor);
      vtable->manager(functor, type_result,
                      detail::function::check_functor_type_tag);


      return (const Functor*)(type_result.obj_ptr);
    }

  template<typename F>
    bool contains(const F& f) const
    {



      if (const F* fp = this->template target<F>())

      {
        return function_equal(*fp, f);
      } else {
        return false;
      }
    }
# 560 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 3
public:
  detail::function::vtable_base* vtable;
  mutable detail::function::function_buffer functor;
};





class bad_function_call : public std::runtime_error
{
public:
  bad_function_call() : std::runtime_error("call to empty boost::function") {}
};


inline bool operator==(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return f.empty();
}

inline bool operator!=(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return !f.empty();
}

inline bool operator==(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return f.empty();
}

inline bool operator!=(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return !f.empty();
}
# 636 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_base.hpp" 3
template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(*fp, g);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(g, *fp);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(*fp, g);
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(g, *fp);
    else return true;
  }


template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp == g.get_pointer();
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() == fp;
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp != g.get_pointer();
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() != fp;
    else return true;
  }



namespace detail {
  namespace function {
    inline bool has_empty_target(const function_base* f)
    {
      return f->empty();
    }







    inline bool has_empty_target(...)
    {
      return false;
    }

  }
}
}
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/get_pointer.hpp" 1 3
# 10 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/get_pointer.hpp" 3
namespace boost {



template<class T> T * get_pointer(T * p)
{
    return p;
}



template<class T> T * get_pointer(std::auto_ptr<T> const& p)
{
    return p.get();
}


}
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 2 3


namespace boost
{
# 207 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 3
namespace _mfi
{






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/mem_fn_template.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/mem_fn_template.hpp" 3
template<class R, class T > class mf0
{
public:

    typedef R result_type;
    typedef T * argument_type;

private:

    typedef R ( T::*F) ();
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit mf0(F f): f_(f) {}

    R operator()(T * p) const
    {
        return (p->*f_)();
    }

    template<class U> R operator()(U & u) const
    {
        return call(u, &u);
    }



    template<class U> R operator()(U const & u) const
    {
        return call(u, &u);
    }



    R operator()(T & t) const
    {
        return (t.*f_)();
    }

    bool operator==(mf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T > class cmf0
{
public:

    typedef R result_type;
    typedef T const * argument_type;

private:

    typedef R ( T::*F) () const;
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit cmf0(F f): f_(f) {}

    template<class U> R operator()(U const & u) const
    {
        return call(u, &u);
    }

    R operator()(T const & t) const
    {
        return (t.*f_)();
    }

    bool operator==(cmf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class mf1
{
public:

    typedef R result_type;
    typedef T * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1);
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit mf1(F f): f_(f) {}

    R operator()(T * p, A1 a1) const
    {
        return (p->*f_)(a1);
    }

    template<class U> R operator()(U & u, A1 a1) const
    {
        return call(u, &u, a1);
    }



    template<class U> R operator()(U const & u, A1 a1) const
    {
        return call(u, &u, a1);
    }



    R operator()(T & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(mf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class cmf1
{
public:

    typedef R result_type;
    typedef T const * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1) const;
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit cmf1(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1) const
    {
        return call(u, &u, a1);
    }

    R operator()(T const & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(cmf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class mf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2);
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit mf2(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2) const
    {
        return (p->*f_)(a1, a2);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2) const
    {
        return call(u, &u, a1, a2);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        return call(u, &u, a1, a2);
    }



    R operator()(T & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(mf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class cmf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2) const;
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit cmf2(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        return call(u, &u, a1, a2);
    }

    R operator()(T const & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(cmf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class mf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3);
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit mf3(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3) const
    {
        return (p->*f_)(a1, a2, a3);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3) const
    {
        return call(u, &u, a1, a2, a3);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        return call(u, &u, a1, a2, a3);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(mf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class cmf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3) const;
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit cmf3(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        return call(u, &u, a1, a2, a3);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(cmf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class mf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4);
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit mf4(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (p->*f_)(a1, a2, a3, a4);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return call(u, &u, a1, a2, a3, a4);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return call(u, &u, a1, a2, a3, a4);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(mf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class cmf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit cmf4(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return call(u, &u, a1, a2, a3, a4);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(cmf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class mf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit mf5(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return call(u, &u, a1, a2, a3, a4, a5);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return call(u, &u, a1, a2, a3, a4, a5);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(mf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class cmf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit cmf5(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return call(u, &u, a1, a2, a3, a4, a5);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(cmf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class mf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit mf6(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(mf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class cmf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit cmf6(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(cmf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class mf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit mf7(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(mf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class cmf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit cmf7(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(cmf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class mf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit mf8(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(mf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class cmf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit cmf8(F f): f_(f) {}

    R operator()(T const * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(cmf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};
# 216 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 2 3
# 258 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 3
}
# 268 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/mem_fn_cc.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/mem_fn_cc.hpp" 3
template<class R, class T> _mfi::mf0<R, T> mem_fn(R ( T::*f) ())
{
    return _mfi::mf0<R, T>(f);
}

template<class R, class T> _mfi::cmf0<R, T> mem_fn(R ( T::*f) () const)
{
    return _mfi::cmf0<R, T>(f);
}

template<class R, class T, class A1> _mfi::mf1<R, T, A1> mem_fn(R ( T::*f) (A1))
{
    return _mfi::mf1<R, T, A1>(f);
}

template<class R, class T, class A1> _mfi::cmf1<R, T, A1> mem_fn(R ( T::*f) (A1) const)
{
    return _mfi::cmf1<R, T, A1>(f);
}

template<class R, class T, class A1, class A2> _mfi::mf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2))
{
    return _mfi::mf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2> _mfi::cmf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2) const)
{
    return _mfi::cmf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::mf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3))
{
    return _mfi::mf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::cmf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3) const)
{
    return _mfi::cmf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::mf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4))
{
    return _mfi::mf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::cmf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4) const)
{
    return _mfi::cmf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::mf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5))
{
    return _mfi::mf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::cmf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5) const)
{
    return _mfi::cmf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6))
{
    return _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6) const)
{
    return _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7))
{
    return _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7) const)
{
    return _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8))
{
    return _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8) const)
{
    return _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}
# 269 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 2 3
# 311 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mem_fn.hpp" 3
namespace _mfi
{

template<class R, class T> class dm
{
public:

    typedef R const & result_type;
    typedef T const * argument_type;

private:

    typedef R (T::*F);
    F f_;

    template<class U> R const & call(U & u, T const *) const
    {
        return (u.*f_);
    }

    template<class U> R const & call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_);
    }

public:

    explicit dm(F f): f_(f) {}

    R & operator()(T * p) const
    {
        return (p->*f_);
    }

    R const & operator()(T const * p) const
    {
        return (p->*f_);
    }

    template<class U> R const & operator()(U const & u) const
    {
        return call(u, &u);
    }



    R & operator()(T & t) const
    {
        return (t.*f_);
    }

    R const & operator()(T const & t) const
    {
        return (t.*f_);
    }



    bool operator==(dm const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(dm const & rhs) const
    {
        return f_ != rhs.f_;
    }
};

}

template<class R, class T> _mfi::dm<R, T> mem_fn(R T::*f)
{
    return _mfi::dm<R, T>(f);
}

}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/enum.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/enum.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/enum.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/enum.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/enum.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/tuple/rem.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/enum.hpp" 2 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/enum_params.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/enum_params.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/repetition/enum_params.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/enum_params.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/prologue.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 2 3
# 62 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R
       
        >
      struct function_invoker0
      {
        static R invoke(function_buffer& function_ptr
                        )
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f();
        }
      };

      template<
        typename FunctionPtr,
        typename R
       
        >
      struct void_function_invoker0
      {
        static void
        invoke(function_buffer& function_ptr
               )

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_obj_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_obj_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_ref_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_ref_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)();
        }
      };

      template<
        typename FunctionPtr,
        typename R
       
      >
      struct get_function_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker0<
                            FunctionPtr,
                            R
                           
                          >,
                          function_invoker0<
                            FunctionPtr,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_obj_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_ref_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };




      template<typename R ,
               typename Allocator>
      struct basic_vtable0 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                           
                                            );

        template<typename F>
        basic_vtable0(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
# 358 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R
    ,
    typename Allocator = std::allocator<function_base>
  >
  class function0 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable0<
              R , Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 0;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 0;
   

    typedef Allocator allocator_type;
    typedef function0 self_type;

    function0() : function_base() { }



    template<typename Functor>
    function0(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function0(clear_type*) : function_base() { }







    function0(const function0& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function0() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()() const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function0&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function0& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function0& operator=(const function0& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function0& other)
    {
      if (&other == this)
        return;

      function0 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function0& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R ,
           typename Allocator>
  inline void swap(function0<
                     R
                     ,
                     Allocator
                   >& f1,
                   function0<
                     R
                     ,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R ,
           typename Allocator>
  typename function0<
      R ,
      Allocator>::result_type
   function0<R ,

                           Allocator>
  ::operator()() const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor );
  }



template<typename R ,
         typename Allocator>
  void operator==(const function0<
                          R
                          ,
                          Allocator>&,
                  const function0<
                          R
                          ,
                  Allocator>&);
template<typename R ,
         typename Allocator>
  void operator!=(const function0<
                          R
                          ,
                          Allocator>&,
                  const function0<
                          R
                          ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R
         ,
         typename Allocator>
class function<R (void), Allocator>
  : public function0<R,
                                   Allocator>
{
  typedef function0<R,
                                  Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0
        >
      struct function_invoker1
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0
        >
      struct void_function_invoker1
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct function_obj_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct void_function_obj_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct function_ref_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct void_function_ref_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0
      >
      struct get_function_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker1<
                            FunctionPtr,
                            R ,
                            T0
                          >,
                          function_invoker1<
                            FunctionPtr,
                            R ,
                            T0
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
       >
      struct get_function_obj_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >,
                          function_obj_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
       >
      struct get_function_ref_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >,
                          function_ref_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >
                       >::type type;
      };




      template<typename R , typename T0,
               typename Allocator>
      struct basic_vtable1 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0);

        template<typename F>
        basic_vtable1(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker1<
                             FunctionPtr,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0,
    typename Allocator = std::allocator<function_base>
  >
  class function1 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable1<
              R , T0, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 1;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };


    typedef T0 argument_type;





    static const int arity = 1;
    typedef T0 arg1_type;

    typedef Allocator allocator_type;
    typedef function1 self_type;

    function1() : function_base() { }



    template<typename Functor>
    function1(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function1(clear_type*) : function_base() { }







    function1(const function1& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function1() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function1&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function1& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function1& operator=(const function1& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function1& other)
    {
      if (&other == this)
        return;

      function1 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function1& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 ,
           typename Allocator>
  inline void swap(function1<
                     R ,
                     T0 ,
                     Allocator
                   >& f1,
                   function1<
                     R ,
                     T0,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0,
           typename Allocator>
  typename function1<
      R , T0,
      Allocator>::result_type
   function1<R , T0,

                           Allocator>
  ::operator()( T0 a0) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0);
  }



template<typename R , typename T0 ,
         typename Allocator>
  void operator==(const function1<
                          R ,
                          T0 ,
                          Allocator>&,
                  const function1<
                          R ,
                          T0 ,
                  Allocator>&);
template<typename R , typename T0 ,
         typename Allocator>
  void operator!=(const function1<
                          R ,
                          T0 ,
                          Allocator>&,
                  const function1<
                          R ,
                          T0 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0,
         typename Allocator>
class function<R ( T0), Allocator>
  : public function1<R, T0
                                   , Allocator>
{
  typedef function1<R, T0
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct function_invoker2
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct void_function_invoker2
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_obj_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_obj_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_ref_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_ref_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct get_function_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >,
                          function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_obj_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_ref_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1,
               typename Allocator>
      struct basic_vtable2 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1);

        template<typename F>
        basic_vtable2(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1,
    typename Allocator = std::allocator<function_base>
  >
  class function2 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable2<
              R , T0 , T1, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 2;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };




    typedef T0 first_argument_type;
    typedef T1 second_argument_type;


    static const int arity = 2;
    typedef T0 arg1_type; typedef T1 arg2_type;

    typedef Allocator allocator_type;
    typedef function2 self_type;

    function2() : function_base() { }



    template<typename Functor>
    function2(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function2(clear_type*) : function_base() { }







    function2(const function2& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function2() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function2&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function2& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function2& operator=(const function2& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function2& other)
    {
      if (&other == this)
        return;

      function2 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function2& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 ,
           typename Allocator>
  inline void swap(function2<
                     R ,
                     T0 , T1 ,
                     Allocator
                   >& f1,
                   function2<
                     R ,
                     T0 , T1,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1,
           typename Allocator>
  typename function2<
      R , T0 , T1,
      Allocator>::result_type
   function2<R , T0 , T1,

                           Allocator>
  ::operator()( T0 a0 , T1 a1) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1);
  }



template<typename R , typename T0 , typename T1 ,
         typename Allocator>
  void operator==(const function2<
                          R ,
                          T0 , T1 ,
                          Allocator>&,
                  const function2<
                          R ,
                          T0 , T1 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 ,
         typename Allocator>
  void operator!=(const function2<
                          R ,
                          T0 , T1 ,
                          Allocator>&,
                  const function2<
                          R ,
                          T0 , T1 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1,
         typename Allocator>
class function<R ( T0 , T1), Allocator>
  : public function2<R, T0 , T1
                                   , Allocator>
{
  typedef function2<R, T0 , T1
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
        >
      struct function_invoker3
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
        >
      struct void_function_invoker3
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_obj_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct void_function_obj_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_ref_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct void_function_ref_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct get_function_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker3<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_invoker3<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_function_obj_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_obj_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_function_ref_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_ref_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2,
               typename Allocator>
      struct basic_vtable3 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2);

        template<typename F>
        basic_vtable3(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker3<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2,
    typename Allocator = std::allocator<function_base>
  >
  class function3 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable3<
              R , T0 , T1 , T2, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 3;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 3;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type;

    typedef Allocator allocator_type;
    typedef function3 self_type;

    function3() : function_base() { }



    template<typename Functor>
    function3(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function3(clear_type*) : function_base() { }







    function3(const function3& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function3() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function3&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function3& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function3& operator=(const function3& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function3& other)
    {
      if (&other == this)
        return;

      function3 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function3& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 ,
           typename Allocator>
  inline void swap(function3<
                     R ,
                     T0 , T1 , T2 ,
                     Allocator
                   >& f1,
                   function3<
                     R ,
                     T0 , T1 , T2,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2,
           typename Allocator>
  typename function3<
      R , T0 , T1 , T2,
      Allocator>::result_type
   function3<R , T0 , T1 , T2,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2);
  }



template<typename R , typename T0 , typename T1 , typename T2 ,
         typename Allocator>
  void operator==(const function3<
                          R ,
                          T0 , T1 , T2 ,
                          Allocator>&,
                  const function3<
                          R ,
                          T0 , T1 , T2 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 ,
         typename Allocator>
  void operator!=(const function3<
                          R ,
                          T0 , T1 , T2 ,
                          Allocator>&,
                  const function3<
                          R ,
                          T0 , T1 , T2 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2,
         typename Allocator>
class function<R ( T0 , T1 , T2), Allocator>
  : public function3<R, T0 , T1 , T2
                                   , Allocator>
{
  typedef function3<R, T0 , T1 , T2
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
        >
      struct function_invoker4
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
        >
      struct void_function_invoker4
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_obj_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct void_function_obj_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_ref_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct void_function_ref_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct get_function_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker4<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_invoker4<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_function_obj_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_obj_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_function_ref_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_ref_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3,
               typename Allocator>
      struct basic_vtable4 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3);

        template<typename F>
        basic_vtable4(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker4<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3,
    typename Allocator = std::allocator<function_base>
  >
  class function4 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable4<
              R , T0 , T1 , T2 , T3, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 4;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 4;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type;

    typedef Allocator allocator_type;
    typedef function4 self_type;

    function4() : function_base() { }



    template<typename Functor>
    function4(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function4(clear_type*) : function_base() { }







    function4(const function4& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function4() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function4&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function4& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function4& operator=(const function4& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function4& other)
    {
      if (&other == this)
        return;

      function4 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function4& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 ,
           typename Allocator>
  inline void swap(function4<
                     R ,
                     T0 , T1 , T2 , T3 ,
                     Allocator
                   >& f1,
                   function4<
                     R ,
                     T0 , T1 , T2 , T3,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3,
           typename Allocator>
  typename function4<
      R , T0 , T1 , T2 , T3,
      Allocator>::result_type
   function4<R , T0 , T1 , T2 , T3,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 ,
         typename Allocator>
  void operator==(const function4<
                          R ,
                          T0 , T1 , T2 , T3 ,
                          Allocator>&,
                  const function4<
                          R ,
                          T0 , T1 , T2 , T3 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 ,
         typename Allocator>
  void operator!=(const function4<
                          R ,
                          T0 , T1 , T2 , T3 ,
                          Allocator>&,
                  const function4<
                          R ,
                          T0 , T1 , T2 , T3 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3), Allocator>
  : public function4<R, T0 , T1 , T2 , T3
                                   , Allocator>
{
  typedef function4<R, T0 , T1 , T2 , T3
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
        >
      struct function_invoker5
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
        >
      struct void_function_invoker5
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_obj_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct void_function_obj_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_ref_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct void_function_ref_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct get_function_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker5<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_invoker5<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_function_obj_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_obj_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_function_ref_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_ref_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
               typename Allocator>
      struct basic_vtable5 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4);

        template<typename F>
        basic_vtable5(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker5<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
    typename Allocator = std::allocator<function_base>
  >
  class function5 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable5<
              R , T0 , T1 , T2 , T3 , T4, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 5;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 5;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type;

    typedef Allocator allocator_type;
    typedef function5 self_type;

    function5() : function_base() { }



    template<typename Functor>
    function5(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function5(clear_type*) : function_base() { }







    function5(const function5& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function5() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function5&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function5& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function5& operator=(const function5& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function5& other)
    {
      if (&other == this)
        return;

      function5 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function5& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 ,
           typename Allocator>
  inline void swap(function5<
                     R ,
                     T0 , T1 , T2 , T3 , T4 ,
                     Allocator
                   >& f1,
                   function5<
                     R ,
                     T0 , T1 , T2 , T3 , T4,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
           typename Allocator>
  typename function5<
      R , T0 , T1 , T2 , T3 , T4,
      Allocator>::result_type
   function5<R , T0 , T1 , T2 , T3 , T4,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 ,
         typename Allocator>
  void operator==(const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4 ,
                          Allocator>&,
                  const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 ,
         typename Allocator>
  void operator!=(const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4 ,
                          Allocator>&,
                  const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3 , T4), Allocator>
  : public function5<R, T0 , T1 , T2 , T3 , T4
                                   , Allocator>
{
  typedef function5<R, T0 , T1 , T2 , T3 , T4
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
        >
      struct function_invoker6
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
        >
      struct void_function_invoker6
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_obj_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct void_function_obj_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_ref_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct void_function_ref_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct get_function_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker6<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_invoker6<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_function_obj_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_obj_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_function_ref_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_ref_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
               typename Allocator>
      struct basic_vtable6 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5);

        template<typename F>
        basic_vtable6(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker6<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
    typename Allocator = std::allocator<function_base>
  >
  class function6 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable6<
              R , T0 , T1 , T2 , T3 , T4 , T5, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 6;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 6;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type;

    typedef Allocator allocator_type;
    typedef function6 self_type;

    function6() : function_base() { }



    template<typename Functor>
    function6(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function6(clear_type*) : function_base() { }







    function6(const function6& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function6() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function6&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function6& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function6& operator=(const function6& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function6& other)
    {
      if (&other == this)
        return;

      function6 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function6& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 ,
           typename Allocator>
  inline void swap(function6<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 ,
                     Allocator
                   >& f1,
                   function6<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
           typename Allocator>
  typename function6<
      R , T0 , T1 , T2 , T3 , T4 , T5,
      Allocator>::result_type
   function6<R , T0 , T1 , T2 , T3 , T4 , T5,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 ,
         typename Allocator>
  void operator==(const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 ,
                          Allocator>&,
                  const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 ,
         typename Allocator>
  void operator!=(const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 ,
                          Allocator>&,
                  const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5), Allocator>
  : public function6<R, T0 , T1 , T2 , T3 , T4 , T5
                                   , Allocator>
{
  typedef function6<R, T0 , T1 , T2 , T3 , T4 , T5
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 78 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
        >
      struct function_invoker7
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
        >
      struct void_function_invoker7
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_obj_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct void_function_obj_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_ref_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct void_function_ref_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct get_function_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker7<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_invoker7<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_function_obj_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_obj_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_function_ref_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_ref_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
               typename Allocator>
      struct basic_vtable7 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6);

        template<typename F>
        basic_vtable7(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker7<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
    typename Allocator = std::allocator<function_base>
  >
  class function7 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable7<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 7;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 7;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type;

    typedef Allocator allocator_type;
    typedef function7 self_type;

    function7() : function_base() { }



    template<typename Functor>
    function7(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function7(clear_type*) : function_base() { }







    function7(const function7& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function7() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function7&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function7& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function7& operator=(const function7& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function7& other)
    {
      if (&other == this)
        return;

      function7 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function7& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 ,
           typename Allocator>
  inline void swap(function7<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 ,
                     Allocator
                   >& f1,
                   function7<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
           typename Allocator>
  typename function7<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6,
      Allocator>::result_type
   function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 ,
         typename Allocator>
  void operator==(const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 ,
                          Allocator>&,
                  const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 ,
         typename Allocator>
  void operator!=(const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 ,
                          Allocator>&,
                  const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6), Allocator>
  : public function7<R, T0 , T1 , T2 , T3 , T4 , T5 , T6
                                   , Allocator>
{
  typedef function7<R, T0 , T1 , T2 , T3 , T4 , T5 , T6
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
        >
      struct function_invoker8
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
        >
      struct void_function_invoker8
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_obj_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct void_function_obj_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_ref_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct void_function_ref_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct get_function_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker8<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_invoker8<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_function_obj_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_obj_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_function_ref_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_ref_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
               typename Allocator>
      struct basic_vtable8 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7);

        template<typename F>
        basic_vtable8(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker8<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
    typename Allocator = std::allocator<function_base>
  >
  class function8 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable8<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 8;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 8;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type;

    typedef Allocator allocator_type;
    typedef function8 self_type;

    function8() : function_base() { }



    template<typename Functor>
    function8(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function8(clear_type*) : function_base() { }







    function8(const function8& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function8() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function8&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function8& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function8& operator=(const function8& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function8& other)
    {
      if (&other == this)
        return;

      function8 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function8& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 ,
           typename Allocator>
  inline void swap(function8<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ,
                     Allocator
                   >& f1,
                   function8<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
           typename Allocator>
  typename function8<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7,
      Allocator>::result_type
   function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 ,
         typename Allocator>
  void operator==(const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ,
                          Allocator>&,
                  const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 ,
         typename Allocator>
  void operator!=(const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ,
                          Allocator>&,
                  const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7), Allocator>
  : public function8<R, T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                                   , Allocator>
{
  typedef function8<R, T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 54 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
        >
      struct function_invoker9
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
        >
      struct void_function_invoker9
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_obj_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct void_function_obj_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_ref_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct void_function_ref_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct get_function_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker9<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_invoker9<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_function_obj_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_obj_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_function_ref_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_ref_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
               typename Allocator>
      struct basic_vtable9 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8);

        template<typename F>
        basic_vtable9(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker9<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
    typename Allocator = std::allocator<function_base>
  >
  class function9 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable9<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 9;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 9;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type; typedef T8 arg9_type;

    typedef Allocator allocator_type;
    typedef function9 self_type;

    function9() : function_base() { }



    template<typename Functor>
    function9(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function9(clear_type*) : function_base() { }







    function9(const function9& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function9() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function9&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function9& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function9& operator=(const function9& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function9& other)
    {
      if (&other == this)
        return;

      function9 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function9& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 ,
           typename Allocator>
  inline void swap(function9<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ,
                     Allocator
                   >& f1,
                   function9<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
           typename Allocator>
  typename function9<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8,
      Allocator>::result_type
   function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 ,
         typename Allocator>
  void operator==(const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ,
                          Allocator>&,
                  const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 ,
         typename Allocator>
  void operator!=(const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ,
                          Allocator>&,
                  const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8), Allocator>
  : public function9<R, T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                                   , Allocator>
{
  typedef function9<R, T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 59 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 93 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 1 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
        >
      struct function_invoker10
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
        >
      struct void_function_invoker10
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_obj_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct void_function_obj_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_ref_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct void_function_ref_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct get_function_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker10<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_invoker10<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_function_obj_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_obj_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_function_ref_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_ref_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
               typename Allocator>
      struct basic_vtable10 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9);

        template<typename F>
        basic_vtable10(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker10<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {

          typedef typename Allocator::template rebind<FunctionObj>::other
            allocator_type;
          typedef typename allocator_type::pointer pointer_type;

          allocator_type allocator;
          pointer_type copy = allocator.allocate(1);
          allocator.construct(copy, f);


          functor.obj_ptr = static_cast<FunctionObj*>(copy);



        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
    typename Allocator = std::allocator<function_base>
  >
  class function10 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable10<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9, Allocator>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 10;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    static const int arity = 10;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type; typedef T8 arg9_type; typedef T9 arg10_type;

    typedef Allocator allocator_type;
    typedef function10 self_type;

    function10() : function_base() { }



    template<typename Functor>
    function10(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }


    function10(clear_type*) : function_base() { }







    function10(const function10& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function10() { clear(); }
# 544 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function10&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }


    function10& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 589 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
    function10& operator=(const function10& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function10& other)
    {
      if (&other == this)
        return;

      function10 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function10& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 ,
           typename Allocator>
  inline void swap(function10<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ,
                     Allocator
                   >& f1,
                   function10<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9,
                     Allocator
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
           typename Allocator>
  typename function10<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9,
      Allocator>::result_type
   function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9,

                           Allocator>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 ,
         typename Allocator>
  void operator==(const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ,
                          Allocator>&,
                  const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ,
                  Allocator>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 ,
         typename Allocator>
  void operator!=(const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ,
                          Allocator>&,
                  const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ,
                  Allocator>&);
# 726 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
         typename Allocator>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9), Allocator>
  : public function10<R, T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                                   , Allocator>
{
  typedef function10<R, T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                                  , Allocator> base_type;
  typedef function self_type;

  struct clear_type {};

public:
  typedef typename base_type::allocator_type allocator_type;

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};
# 808 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/function_template.hpp" 3
}
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 2 3
# 34 "../Source_Files/Misc/sdl_dialogs.h" 2


using std::vector;


class widget;
struct SDL_Surface;
class font_info;
class FileSpecifier;
# 56 "../Source_Files/Misc/sdl_dialogs.h"
class dialog;

class placeable {
public:
 enum placement_flags
 {
  kDefault = 0x0,
  kAlignLeft = 0x1,
  kAlignCenter = 0x2,
  kAlignRight = 0x4,
  kFill = 0x8,
 };

 placeable() : m_visible(true) { }
 virtual ~placeable() { }

 virtual void place(const SDL_Rect &r, placement_flags flags = kDefault) = 0;
 virtual int min_height() = 0;
 virtual int min_width() = 0;

 virtual bool visible() { return m_visible; }
 virtual void visible(bool visible) { m_visible = visible; }

private:
 bool m_visible;
};

class widget_placer : public placeable
{
public:
 widget_placer() : placeable() { }
 ~widget_placer();

 void place(const SDL_Rect &r, placement_flags flags = kDefault) = 0;
 int min_height() = 0;
 int min_width() = 0;

protected:
 void assume_ownership(placeable *p) { m_owned.push_back(p); }

private:
 std::vector<placeable *> m_owned;
};

class tab_placer : public widget_placer
{
public:
 tab_placer() : widget_placer(), m_tab(0) { }
 void add(placeable *p, bool assume_ownership = false);
 void dual_add(widget *w, dialog& d);
 int min_height();
 int min_width();
 int tabs() { return m_tabs.size(); };
 void choose_tab(int new_tab);
 void place(const SDL_Rect &r, placement_flags flags = kDefault);
 bool visible() { return widget_placer::visible(); }
 void visible(bool visible);
private:
 int m_tab;
 std::vector<placeable *> m_tabs;
};

class table_placer : public widget_placer
{
public:
 enum { kSpace = 4 };
 table_placer(int columns, int space = kSpace, bool balance_widths = false) : widget_placer(), m_add(0), m_columns(columns), m_space(space), m_balance_widths(balance_widths) { m_col_flags.resize(m_columns); m_col_min_widths.resize(m_columns);}
 void add(placeable *p, bool assume_ownership = false);
 void add_row(placeable *p, bool assume_ownership = false);
 void col_flags(int col, placement_flags flags = kDefault) { m_col_flags[col] = flags; }
 void col_min_width(int col, int min_width) { m_col_min_widths[col] = min_width; }
 void dual_add(widget *w, dialog& d);
 void dual_add_row(widget *w, dialog& d);
 int min_height();
 int min_width();
 void place(const SDL_Rect &r, placement_flags flags = kDefault);
 void visible(bool visible);
 int col_width(int column);
private:
 int row_height(int row);
 int m_add;
 int m_columns;
 int m_space;
 bool m_balance_widths;
 std::vector<std::vector<placeable *> > m_table;
 std::vector<placement_flags> m_col_flags;
 std::vector<int> m_col_min_widths;
};


class vertical_placer : public widget_placer
{
public:
 enum { kSpace = 0 };
 vertical_placer(int space = kSpace) : m_space(space), widget_placer(), m_min_width(0), m_add_flags(kDefault) { }

 void add(placeable *p, bool assume_ownership = false);
 void add_flags(placement_flags flags = kDefault) { m_add_flags = flags; }
 void dual_add(widget *w, dialog& d);
 int min_height();
 int min_width();
 void min_width(int w) { m_min_width = w; }

 void place(const SDL_Rect &r, placement_flags flags = kDefault);
 void visible(bool visible);

private:
 std::vector<placeable *> m_widgets;
 std::vector<int> m_widget_heights;
 std::vector<placement_flags> m_placement_flags;
 int m_min_width;
 placement_flags m_add_flags;
 int m_space;
};

class horizontal_placer : public widget_placer
{
public:
 enum { kSpace = 4 };
 horizontal_placer(int space = kSpace, bool balance_widths = false) : widget_placer(), m_space(space), m_add_flags(kDefault), m_balance_widths(balance_widths) { }

 void add(placeable *p, bool assume_ownership = false);
 void add_flags(placement_flags flags = kDefault) { m_add_flags = flags; }

 void dual_add(widget *w, dialog& d);
 int min_height();
 int min_width();

 void place(const SDL_Rect &r, placement_flags flags = kDefault);
 void visible(bool visible);

private:
 std::vector<placeable *> m_widgets;
 std::vector<int> m_widget_widths;
 std::vector<placement_flags> m_placement_flags;
 int m_space;
 placement_flags m_add_flags;
 bool m_balance_widths;
};



class dialog {
public:
 typedef boost::function<void (dialog* d)> Callback;

 dialog();
 ~dialog();


 void add(widget *w);


 int run(bool intro_exit_sounds = true);


 void start(bool play_sound = true);


 bool process_events();


 int finish(bool play_sound = true);


 void quit(int result);


 void draw(void);





        void draw_dirty_widgets() const;


 widget *get_widget_by_id(short inID) const;


 void set_processing_function(Callback func) { processing_function = func; }


 void activate_next_widget(void);



 void layout(void);


 void set_widget_placer(widget_placer *w) { placer = w; }

 void activate_widget(widget *w, bool draw = false);

private:
 SDL_Surface *get_surface(void) const;
 void update(SDL_Rect r) const;
 void draw_widget(widget *w, bool do_update = true) const;
 void deactivate_currently_active_widget(bool draw = true);
 void activate_first_widget(void);
 void activate_widget(size_t num, bool draw = true);
 void activate_prev_widget(void);
 int find_widget(int x, int y);
 void event(SDL_Event &e);

 void new_layout(void);

 SDL_Rect rect;

 vector<widget *> widgets;

 widget *active_widget;
 widget *mouse_widget;
 size_t active_widget_num;

 int result;
 bool done;
 bool cursor_was_visible;
 int saved_unicode_state;
 bool saved_keyrepeat_state;
 static bool sKeyRepeatActive;

 dialog *parent_dialog;

 Callback processing_function;


 SDL_Surface *frame_tl, *frame_t, *frame_tr, *frame_l, *frame_r, *frame_bl, *frame_b, *frame_br;

 widget_placer *placer;
 bool layout_for_fullscreen;
};


extern dialog *top_dialog;
# 307 "../Source_Files/Misc/sdl_dialogs.h"
extern void initialize_dialogs(FileSpecifier &theme);

extern bool load_theme(FileSpecifier &theme);

extern uint32 get_dialog_player_color(size_t colorIndex);
extern void play_dialog_sound(int which);




enum {
 DEFAULT_STATE,
 DISABLED_STATE,
 ACTIVE_STATE,
 CURSOR_STATE,
 PRESSED_STATE
};


enum {
 DEFAULT_WIDGET,
 DIALOG_FRAME,
 TITLE_WIDGET,
 LABEL_WIDGET,
 MESSAGE_WIDGET,
 ITEM_WIDGET,
 TEXT_ENTRY_WIDGET,
 SPACER_WIDGET,
 BUTTON_WIDGET,
 SLIDER_WIDGET,
 SLIDER_THUMB,
 LIST_WIDGET,
 LIST_THUMB,
 CHAT_ENTRY,
 TINY_BUTTON,
 CHECKBOX,
 TAB_WIDGET,
 METASERVER_WIDGETS,
 METASERVER_PLAYERS,
 METASERVER_GAMES,
};

enum {
 FOREGROUND_COLOR,
 BACKGROUND_COLOR,
 FRAME_COLOR
};

enum {
 TL_IMAGE,
 T_IMAGE,
 TR_IMAGE,
 L_IMAGE,
 R_IMAGE,
 BL_IMAGE,
 B_IMAGE,
 BR_IMAGE
};

enum {
 BUTTON_L_IMAGE,
 BUTTON_C_IMAGE,
 BUTTON_R_IMAGE
};

enum {
 SLIDER_L_IMAGE,
 SLIDER_C_IMAGE,
 SLIDER_R_IMAGE,
};

enum {
 SLIDER_T_SPACE,
 SLIDER_L_SPACE,
 SLIDER_R_SPACE
};

enum {
 T_SPACE,
 L_SPACE,
 R_SPACE,
 B_SPACE
};

enum {
 BUTTON_T_SPACE,
 BUTTON_L_SPACE,
 BUTTON_R_SPACE,
 BUTTON_HEIGHT,
};

enum {
 TAB_LC_SPACE = BUTTON_HEIGHT + 1,
 TAB_RC_SPACE
};

enum {
 TAB_L_IMAGE,
 TAB_LC_IMAGE,
 TAB_C_IMAGE,
 TAB_RC_IMAGE,
 TAB_R_IMAGE
};

enum {
 TROUGH_T_SPACE = B_SPACE + 1,
 TROUGH_R_SPACE,
 TROUGH_B_SPACE,
 TROUGH_WIDTH
};

enum {
 THUMB_T_IMAGE,
 THUMB_TC_IMAGE,
 THUMB_C_IMAGE,
 THUMB_BC_IMAGE,
 THUMB_B_IMAGE
};

extern font_info *get_theme_font(int widget_type, uint16 &style);

extern uint32 get_theme_color(int widget_type, int state, int which = 0);
extern SDL_Surface* get_theme_image(int widget_type, int state, int which, int width = 0, int height = 0);
extern bool use_theme_images(int widget_type);
extern bool use_theme_color(int widget_type, int which);
extern uint16 get_theme_space(int widget_type, int which = 0);

extern void dialog_ok(void *arg);
extern void dialog_cancel(void *arg);


class w_text_entry;
extern void dialog_try_ok(w_text_entry* text_entry);
extern void dialog_disable_ok_if_empty(w_text_entry* inTextEntry);


class XML_ElementParser;
XML_ElementParser *Theme_GetParser();
# 68 "shell.cpp" 2
# 1 "../Source_Files/RenderOther/sdl_fonts.h" 1
# 69 "shell.cpp" 2
# 1 "../Source_Files/Misc/sdl_widgets.h" 1
# 45 "../Source_Files/Misc/sdl_widgets.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 46 "../Source_Files/Misc/sdl_widgets.h" 2


# 1 "../Source_Files/Misc/sdl_dialogs.h" 1
# 49 "../Source_Files/Misc/sdl_widgets.h" 2





# 1 "../Source_Files/Files/FileHandler.h" 1
# 55 "../Source_Files/Misc/sdl_widgets.h" 2


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/set" 1 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/set" 3
       
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/set" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tree.h" 1 3
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 90 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }

      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return get_allocator().max_size(); }

      void



      swap(_Rb_tree& __t);



      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 820 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)

    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else

 return iterator(static_cast<_Link_type>
   (const_cast<_Base_ptr>(__position._M_node)));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/set" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 1 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 90 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 163 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 179 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 215 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 243 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 330 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 355 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      void



      swap(set& __x)

      { _M_t.swap(__x._M_t); }
# 377 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 404 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 416 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 430 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 445 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 460 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 484 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 502 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 523 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 539 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 564 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 593 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 610 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 662 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_set.h" 3
}
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/set" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 1 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 87 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 156 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 172 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 186 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 208 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 236 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 323 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 348 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      void



      swap(multiset& __x)

      { _M_t.swap(__x._M_t); }
# 368 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 392 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 404 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 419 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 434 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 449 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 470 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 488 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 509 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 525 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 550 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 580 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 597 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 652 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multiset.h" 3
}
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/set" 2 3
# 58 "../Source_Files/Misc/sdl_widgets.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 1 3
# 62 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 78 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 93 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 2 3
# 59 "../Source_Files/Misc/sdl_widgets.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 1 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type.hpp" 1 3
# 9 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type.hpp" 3
namespace boost {



  template <class T>
  struct type {};

}
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/arg.hpp" 1 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/arg.hpp" 3
namespace boost
{

template<int I> class arg
{
};

template<int I> bool operator==(arg<I> const &, arg<I> const &)
{
    return true;
}

}
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/visit_each.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/visit_each.hpp" 3
namespace boost {
  template<typename Visitor, typename T>
  inline void visit_each(Visitor& visitor, const T& t, long)
  {
    visitor(t);
  }

  template<typename Visitor, typename T>
  inline void visit_each(Visitor& visitor, const T& t)
  {
    visit_each(visitor, t, 0);
  }
}
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/storage.hpp" 1 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/storage.hpp" 3
namespace boost
{

namespace _bi
{



template<class A1> struct storage1
{
    explicit storage1( A1 a1 ): a1_( a1 ) {}

    template<class V> void accept(V & v) const
    {
        visit_each(v, a1_, 0);
    }

    A1 a1_;
};



template<int I> struct storage1< boost::arg<I> >
{
    explicit storage1( boost::arg<I> ) {}

    template<class V> void accept(V &) const { }

    static boost::arg<I> a1_() { return boost::arg<I>(); }
};

template<int I> struct storage1< boost::arg<I> (*) () >
{
    explicit storage1( boost::arg<I> (*) () ) {}

    template<class V> void accept(V &) const { }

    static boost::arg<I> a1_() { return boost::arg<I>(); }
};





template<class A1, class A2> struct storage2: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, A2 a2 ): storage1<A1>( a1 ), a2_( a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a2_, 0);
    }

    A2 a2_;
};



template<class A1, int I> struct storage2< A1, boost::arg<I> >: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, boost::arg<I> ): storage1<A1>( a1 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a2_() { return boost::arg<I>(); }
};

template<class A1, int I> struct storage2< A1, boost::arg<I> (*) () >: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, boost::arg<I> (*) () ): storage1<A1>( a1 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a2_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3> struct storage3: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, A3 a3 ): storage2<A1, A2>( a1, a2 ), a3_( a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a3_, 0);
    }

    A3 a3_;
};



template<class A1, class A2, int I> struct storage3< A1, A2, boost::arg<I> >: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, boost::arg<I> ): storage2<A1, A2>( a1, a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a3_() { return boost::arg<I>(); }
};

template<class A1, class A2, int I> struct storage3< A1, A2, boost::arg<I> (*) () >: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, boost::arg<I> (*) () ): storage2<A1, A2>( a1, a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a3_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4> struct storage4: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, A4 a4 ): storage3<A1, A2, A3>( a1, a2, a3 ), a4_( a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a4_, 0);
    }

    A4 a4_;
};



template<class A1, class A2, class A3, int I> struct storage4< A1, A2, A3, boost::arg<I> >: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, boost::arg<I> ): storage3<A1, A2, A3>( a1, a2, a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a4_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, int I> struct storage4< A1, A2, A3, boost::arg<I> (*) () >: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, boost::arg<I> (*) () ): storage3<A1, A2, A3>( a1, a2, a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a4_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5> struct storage5: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ), a5_( a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a5_, 0);
    }

    A5 a5_;
};



template<class A1, class A2, class A3, class A4, int I> struct storage5< A1, A2, A3, A4, boost::arg<I> >: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I> ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a5_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, int I> struct storage5< A1, A2, A3, A4, boost::arg<I> (*) () >: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I> (*) () ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a5_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6> struct storage6: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ), a6_( a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a6_, 0);
    }

    A6 a6_;
};



template<class A1, class A2, class A3, class A4, class A5, int I> struct storage6< A1, A2, A3, A4, A5, boost::arg<I> >: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I> ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a6_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, int I> struct storage6< A1, A2, A3, A4, A5, boost::arg<I> (*) () >: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I> (*) () ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a6_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct storage7: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ), a7_( a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a7_, 0);
    }

    A7 a7_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, int I> struct storage7< A1, A2, A3, A4, A5, A6, boost::arg<I> >: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I> ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a7_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, int I> struct storage7< A1, A2, A3, A4, A5, A6, boost::arg<I> (*) () >: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I> (*) () ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a7_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> struct storage8: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8 ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ), a8_( a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a8_, 0);
    }

    A8 a8_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I> struct storage8< A1, A2, A3, A4, A5, A6, A7, boost::arg<I> >: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I> ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a8_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I> struct storage8< A1, A2, A3, A4, A5, A6, A7, boost::arg<I> (*) () >: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I> (*) () ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a8_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> struct storage9: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9 ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ), a9_( a9 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a9_, 0);
    }

    A9 a9_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I> struct storage9< A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> >: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I> ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a9_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I> struct storage9< A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> (*) () >: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I> (*) () ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a9_() { return boost::arg<I>(); }
};



}

}
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3






namespace boost
{

namespace _bi
{



template<class R, class F> struct result_traits
{
    typedef R type;
};



struct unspecified {};

template<class F> struct result_traits<unspecified, F>
{
    typedef typename F::result_type type;
};

template<class F> struct result_traits< unspecified, reference_wrapper<F> >
{
    typedef typename F::result_type type;
};





template<class T> bool ref_compare( T const & a, T const & b, long )
{
    return a == b;
}

template<int I> bool ref_compare( arg<I> const &, arg<I> const &, int )
{
    return true;
}

template<int I> bool ref_compare( arg<I> (*) (), arg<I> (*) (), int )
{
    return true;
}

template<class T> bool ref_compare( reference_wrapper<T> const & a, reference_wrapper<T> const & b, int )
{
    return a.get_pointer() == b.get_pointer();
}



template<class R, class F, class L> class bind_t;



template<class T> class value
{
public:

    value(T const & t): t_(t) {}

    T & get() { return t_; }
    T const & get() const { return t_; }

    bool operator==(value const & rhs) const
    {
        return t_ == rhs.t_;
    }

private:

    T t_;
};



template<class T> class type {};



template<class F> struct unwrapper
{
    static inline F & unwrap( F & f, long )
    {
        return f;
    }

    template<class F2> static inline F2 & unwrap( reference_wrapper<F2> rf, int )
    {
        return rf.get();
    }

    template<class R, class T> static inline _mfi::dm<R, T> unwrap( R T::* pm, int )
    {
        return _mfi::dm<R, T>( pm );
    }
};



class list0
{
public:

    list0() {}

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A &, long)
    {
        return unwrapper<F>::unwrap(f, 0)();
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A &, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)();
    }

    template<class F, class A> void operator()(type<void>, F & f, A &, int)
    {
        unwrapper<F>::unwrap(f, 0)();
    }

    template<class F, class A> void operator()(type<void>, F const & f, A &, int) const
    {
        unwrapper<F const>::unwrap(f, 0)();
    }

    template<class V> void accept(V &) const
    {
    }

    bool operator==(list0 const &) const
    {
        return true;
    }
};

template< class A1 > class list1: private storage1< A1 >
{
private:

    typedef storage1< A1 > base_type;

public:

    explicit list1( A1 a1 ): base_type( a1 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list1 const & rhs) const
    {
        return ref_compare(base_type::a1_, rhs.a1_, 0);
    }
};

template< class A1, class A2 > class list2: private storage2< A1, A2 >
{
private:

    typedef storage2< A1, A2 > base_type;

public:

    list2( A1 a1, A2 a2 ): base_type( a1, a2 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list2 const & rhs) const
    {
        return ref_compare(base_type::a1_, rhs.a1_, 0) && ref_compare(base_type::a2_, rhs.a2_, 0);
    }
};

template< class A1, class A2, class A3 > class list3: private storage3< A1, A2, A3 >
{
private:

    typedef storage3< A1, A2, A3 > base_type;

public:

    list3( A1 a1, A2 a2, A3 a3 ): base_type( a1, a2, a3 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list3 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 );
    }
};

template< class A1, class A2, class A3, class A4 > class list4: private storage4< A1, A2, A3, A4 >
{
private:

    typedef storage4< A1, A2, A3, A4 > base_type;

public:

    list4( A1 a1, A2 a2, A3 a3, A4 a4 ): base_type( a1, a2, a3, a4 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list4 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 );
    }
};

template< class A1, class A2, class A3, class A4, class A5 > class list5: private storage5< A1, A2, A3, A4, A5 >
{
private:

    typedef storage5< A1, A2, A3, A4, A5 > base_type;

public:

    list5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): base_type( a1, a2, a3, a4, a5 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list5 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6> class list6: private storage6< A1, A2, A3, A4, A5, A6 >
{
private:

    typedef storage6< A1, A2, A3, A4, A5, A6 > base_type;

public:

    list6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): base_type( a1, a2, a3, a4, a5, a6 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list6 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> class list7: private storage7< A1, A2, A3, A4, A5, A6, A7 >
{
private:

    typedef storage7< A1, A2, A3, A4, A5, A6, A7 > base_type;

public:

    list7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): base_type( a1, a2, a3, a4, a5, a6, a7 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list7 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class list8: private storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
private:

    typedef storage8< A1, A2, A3, A4, A5, A6, A7, A8 > base_type;

public:

    list8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8 ): base_type( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8>) const { return base_type::a8_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8> (*) ()) const { return base_type::a8_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list8 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 ) &&
            ref_compare( base_type::a8_, rhs.a8_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> class list9: private storage9< A1, A2, A3, A4, A5, A6, A7, A8, A9 >
{
private:

    typedef storage9< A1, A2, A3, A4, A5, A6, A7, A8, A9 > base_type;

public:

    list9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9 ): base_type( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8>) const { return base_type::a8_; }
    A9 operator[] (boost::arg<9>) const { return base_type::a9_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8> (*) ()) const { return base_type::a8_; }
    A9 operator[] (boost::arg<9> (*) ()) const { return base_type::a9_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list9 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 ) &&
            ref_compare( base_type::a8_, rhs.a8_, 0 ) &&
            ref_compare( base_type::a9_, rhs.a9_, 0 );
    }
};





template<class R, class F, class L> class bind_t
{
public:

    typedef bind_t this_type;

    bind_t(F f, L const & l): f_(f), l_(l) {}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/bind_template.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/bind_template.hpp" 3
    typedef typename result_traits<R, F>::type result_type;

    result_type operator()()
    {
        list0 a;
        return l_(type<result_type>(), f_, a, 0);
    }

    result_type operator()() const
    {
        list0 a;
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1> result_type operator()(A1 & a1)
    {
        list1<A1 &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1> result_type operator()(A1 & a1) const
    {
        list1<A1 &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1> result_type operator()(A1 const & a1)
    {
        list1<A1 const &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1> result_type operator()(A1 const & a1) const
    {
        list1<A1 const &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2> result_type operator()(A1 & a1, A2 & a2)
    {
        list2<A1 &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 & a2) const
    {
        list2<A1 &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2> result_type operator()(A1 const & a1, A2 & a2)
    {
        list2<A1 const &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 & a2) const
    {
        list2<A1 const &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }


    template<class A1, class A2> result_type operator()(A1 & a1, A2 const & a2)
    {
        list2<A1 &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 const & a2) const
    {
        list2<A1 &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }


    template<class A1, class A2> result_type operator()(A1 const & a1, A2 const & a2)
    {
        list2<A1 const &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 const & a2) const
    {
        list2<A1 const &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3> result_type operator()(A1 & a1, A2 & a2, A3 & a3)
    {
        list3<A1 &, A2 &, A3 &> a(a1, a2, a3);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3> result_type operator()(A1 & a1, A2 & a2, A3 & a3) const
    {
        list3<A1 &, A2 &, A3 &> a(a1, a2, a3);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4)
    {
        list4<A1 &, A2 &, A3 &, A4 &> a(a1, a2, a3, a4);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4) const
    {
        list4<A1 &, A2 &, A3 &, A4 &> a(a1, a2, a3, a4);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5)
    {
        list5<A1 &, A2 &, A3 &, A4 &, A5 &> a(a1, a2, a3, a4, a5);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5) const
    {
        list5<A1 &, A2 &, A3 &, A4 &, A5 &> a(a1, a2, a3, a4, a5);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6)
    {
        list6<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &> a(a1, a2, a3, a4, a5, a6);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6) const
    {
        list6<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &> a(a1, a2, a3, a4, a5, a6);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7)
    {
        list7<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &> a(a1, a2, a3, a4, a5, a6, a7);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7) const
    {
        list7<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &> a(a1, a2, a3, a4, a5, a6, a7);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8)
    {
        list8<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &> a(a1, a2, a3, a4, a5, a6, a7, a8);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8) const
    {
        list8<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &> a(a1, a2, a3, a4, a5, a6, a7, a8);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9)
    {
        list9<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &, A9 &> a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9) const
    {
        list9<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &, A9 &> a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A> result_type eval(A & a)
    {
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A> result_type eval(A & a) const
    {
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class V> void accept(V & v) const
    {


        using boost::visit_each;


        visit_each(v, f_, 0);
        l_.accept(v);
    }

    bool compare(this_type const & rhs) const
    {
        return ref_compare(f_, rhs.f_, 0) && l_ == rhs.l_;
    }

private:

    F f_;
    L l_;
# 825 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3


};
# 891 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
template<class R, class F, class L> bool function_equal( bind_t<R, F, L> const & a, bind_t<R, F, L> const & b )
{
    return a.compare(b);
}
# 936 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
template<class T> struct add_value
{
    typedef _bi::value<T> type;
};

template<class T> struct add_value< value<T> >
{
    typedef _bi::value<T> type;
};

template<class T> struct add_value< reference_wrapper<T> >
{
    typedef reference_wrapper<T> type;
};

template<int I> struct add_value< arg<I> >
{
    typedef boost::arg<I> type;
};

template<int I> struct add_value< arg<I> (*) () >
{
    typedef boost::arg<I> (*type) ();
};

template<class R, class F, class L> struct add_value< bind_t<R, F, L> >
{
    typedef bind_t<R, F, L> type;
};
# 1007 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
template<class A1> struct list_av_1
{
    typedef typename add_value<A1>::type B1;
    typedef list1<B1> type;
};

template<class A1, class A2> struct list_av_2
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef list2<B1, B2> type;
};

template<class A1, class A2, class A3> struct list_av_3
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef list3<B1, B2, B3> type;
};

template<class A1, class A2, class A3, class A4> struct list_av_4
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef list4<B1, B2, B3, B4> type;
};

template<class A1, class A2, class A3, class A4, class A5> struct list_av_5
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef list5<B1, B2, B3, B4, B5> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6> struct list_av_6
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef list6<B1, B2, B3, B4, B5, B6> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct list_av_7
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef list7<B1, B2, B3, B4, B5, B6, B7> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> struct list_av_8
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef typename add_value<A8>::type B8;
    typedef list8<B1, B2, B3, B4, B5, B6, B7, B8> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> struct list_av_9
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef typename add_value<A8>::type B8;
    typedef typename add_value<A9>::type B9;
    typedef list9<B1, B2, B3, B4, B5, B6, B7, B8, B9> type;
};



struct logical_not
{
    template<class V> bool operator()(V const & v) const { return !v; }
};

template<class R, class F, class L>
    bind_t< bool, logical_not, list1< bind_t<R, F, L> > >
    operator! (bind_t<R, F, L> const & f)
{
    typedef list1< bind_t<R, F, L> > list_type;
    return bind_t<bool, logical_not, list_type> ( logical_not(), list_type(f) );
}
# 1130 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
struct equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v == w; } }; template<class R, class F, class L, class A2> bind_t< bool, equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator == (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, equal, list_type> ( equal(), list_type(f, a2) ); }
struct not_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v != w; } }; template<class R, class F, class L, class A2> bind_t< bool, not_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator != (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, not_equal, list_type> ( not_equal(), list_type(f, a2) ); }

struct less { template<class V, class W> bool operator()(V const & v, W const & w) const { return v < w; } }; template<class R, class F, class L, class A2> bind_t< bool, less, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator < (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, less, list_type> ( less(), list_type(f, a2) ); }
struct less_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v <= w; } }; template<class R, class F, class L, class A2> bind_t< bool, less_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator <= (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, less_equal, list_type> ( less_equal(), list_type(f, a2) ); }

struct greater { template<class V, class W> bool operator()(V const & v, W const & w) const { return v > w; } }; template<class R, class F, class L, class A2> bind_t< bool, greater, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator > (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, greater, list_type> ( greater(), list_type(f, a2) ); }
struct greater_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v >= w; } }; template<class R, class F, class L, class A2> bind_t< bool, greater_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator >= (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, greater_equal, list_type> ( greater_equal(), list_type(f, a2) ); }
# 1167 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
template<class V, class T> void visit_each( V & v, value<T> const & t, int )
{
    using boost::visit_each;
    visit_each( v, t.get(), 0 );
}

template<class V, class R, class F, class L> void visit_each( V & v, bind_t<R, F, L> const & t, int )
{
    t.accept( v );
}



}
# 1207 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
template<class R, class F>
    _bi::bind_t<R, F, _bi::list0>
    bind(F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class F, class A1>
    _bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>
    bind(F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class F, class A1, class A2>
    _bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>
    bind(F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R, class F, class A1, class A2, class A3>
    _bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R, class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}



template<class R, class F>
    _bi::bind_t<R, F, _bi::list0>
    bind(boost::type<R>, F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class F, class A1>
    _bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>
    bind(boost::type<R>, F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class F, class A1, class A2>
    _bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R, class F, class A1, class A2, class A3>
    _bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R, class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}





template<class F>
    _bi::bind_t<_bi::unspecified, F, _bi::list0>
    bind(F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type());
}

template<class F, class A1>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_1<A1>::type>
    bind(F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type(a1));
}

template<class F, class A1, class A2>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_2<A1, A2>::type>
    bind(F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type(a1, a2));
}

template<class F, class A1, class A2, class A3>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3));
}

template<class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1460 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/bind_cc.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/bind_cc.hpp" 3
template<class R>
    _bi::bind_t<R, R ( *) (), _bi::list0>
    bind( R ( *f) ())
{
    typedef R ( *F) ();
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class B1, class A1>
    _bi::bind_t<R, R ( *) (B1), typename _bi::list_av_1<A1>::type>
    bind( R ( *f) (B1), A1 a1)
{
    typedef R ( *F) (B1);
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class B1, class B2, class A1, class A2>
    _bi::bind_t<R, R ( *) (B1, B2), typename _bi::list_av_2<A1, A2>::type>
    bind( R ( *f) (B1, B2), A1 a1, A2 a2)
{
    typedef R ( *F) (B1, B2);
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R,
    class B1, class B2, class B3,
    class A1, class A2, class A3>
    _bi::bind_t<R, R ( *) (B1, B2, B3), typename _bi::list_av_3<A1, A2, A3>::type>
    bind( R ( *f) (B1, B2, B3), A1 a1, A2 a2, A3 a3)
{
    typedef R ( *F) (B1, B2, B3);
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4), typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind( R ( *f) (B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef R ( *F) (B1, B2, B3, B4);
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5), typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef R ( *F) (B1, B2, B3, B4, B5);
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6), typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6);
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7), typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7);
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7, B8), typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7, B8);
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class B9,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7, B8, B9), typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7, B8, B9), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7, B8, B9);
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1461 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3
# 1506 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/bind_mf_cc.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/bind_mf_cc.hpp" 3
template<class R, class T,
    class A1>
    _bi::bind_t<R, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(R ( T::*f) (), A1 a1)
{
    typedef _mfi::mf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
}

template<class R, class T,
    class A1>
    _bi::bind_t<R, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(R ( T::*f) () const, A1 a1)
{
    typedef _mfi::cmf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
}



template<class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<R, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(R ( T::*f) (B1), A1 a1, A2 a2)
{
    typedef _mfi::mf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
}

template<class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<R, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(R ( T::*f) (B1) const, A1 a1, A2 a2)
{
    typedef _mfi::cmf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
}



template<class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<R, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(R ( T::*f) (B1, B2), A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::mf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<R, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(R ( T::*f) (B1, B2) const, A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::cmf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
}



template<class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(R ( T::*f) (B1, B2, B3), A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::mf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(R ( T::*f) (B1, B2, B3) const, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::cmf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}



template<class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(R ( T::*f) (B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::mf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(R ( T::*f) (B1, B2, B3, B4) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::cmf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1507 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3
# 1563 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 3
namespace _bi
{

template< class Pm, int I > struct add_cref;

template< class M, class T > struct add_cref< M T::*, 0 >
{
    typedef M type;
};

template< class M, class T > struct add_cref< M T::*, 1 >
{
    typedef M const & type;
};

template< class R, class T > struct add_cref< R (T::*) (), 1 >
{
    typedef void type;
};



template< class R, class T > struct add_cref< R (T::*) () const, 1 >
{
    typedef void type;
};



template<class R> struct isref
{
    enum value_type { value = 0 };
};

template<class R> struct isref< R& >
{
    enum value_type { value = 1 };
};

template<class R> struct isref< R* >
{
    enum value_type { value = 1 };
};

template<class Pm, class A1> struct dm_result
{
    typedef typename add_cref< Pm, 1 >::type type;
};

template<class Pm, class R, class F, class L> struct dm_result< Pm, bind_t<R, F, L> >
{
    typedef typename bind_t<R, F, L>::result_type result_type;
    typedef typename add_cref< Pm, isref< result_type >::value >::type type;
};

}

template< class A1, class M, class T >

_bi::bind_t<
    typename _bi::dm_result< M T::*, A1 >::type,
    _mfi::dm<M, T>,
    typename _bi::list_av_1<A1>::type
>

bind( M T::*f, A1 a1 )
{
    typedef typename _bi::dm_result< M T::*, A1 >::type result_type;
    typedef _mfi::dm<M, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t< result_type, F, list_type >( F( f ), list_type( a1 ) );
}



}



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/placeholders.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/placeholders.hpp" 3
namespace
{



static inline boost::arg<1> _1() { return boost::arg<1>(); }
static inline boost::arg<2> _2() { return boost::arg<2>(); }
static inline boost::arg<3> _3() { return boost::arg<3>(); }
static inline boost::arg<4> _4() { return boost::arg<4>(); }
static inline boost::arg<5> _5() { return boost::arg<5>(); }
static inline boost::arg<6> _6() { return boost::arg<6>(); }
static inline boost::arg<7> _7() { return boost::arg<7>(); }
static inline boost::arg<8> _8() { return boost::arg<8>(); }
static inline boost::arg<9> _9() { return boost::arg<9>(); }
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind/placeholders.hpp" 3
}
# 1643 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/bind.hpp" 2 3
# 60 "../Source_Files/Misc/sdl_widgets.h" 2

# 1 "../Source_Files/Network/Metaserver/metaserver_messages.h" 1
# 28 "../Source_Files/Network/Metaserver/metaserver_messages.h"
# 1 "../Source_Files/TCPMess/Message.h" 1
# 32 "../Source_Files/TCPMess/Message.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 33 "../Source_Files/TCPMess/Message.h" 2







typedef Uint16 MessageTypeID;

class UninflatedMessage;

class Message
{
public:
 virtual MessageTypeID type() const = 0;


 virtual bool inflateFrom(const UninflatedMessage& inUninflated) = 0;


 virtual UninflatedMessage* deflate() const = 0;

 virtual Message* clone() const = 0;

 virtual ~Message() {}

protected:
};



class UninflatedMessage : public Message
{
public:
 enum { kTypeID = 0xffff };




 UninflatedMessage(MessageTypeID inType, size_t inLength, Uint8* inBytes = __null)
  : mType(inType), mLength(inLength), mBuffer(inBytes)
 {
  if(mBuffer == __null)
   mBuffer = new Uint8[mLength];
 }

 UninflatedMessage(const UninflatedMessage& inSource) { copyToThis(inSource); }

 UninflatedMessage& operator =(const UninflatedMessage& inSource)
 {
  if(&inSource != this)
   copyToThis(inSource);

  return *this;
 }

 MessageTypeID type() const { return kTypeID; }
 bool inflateFrom(const UninflatedMessage& inUninflated) { *this = inUninflated; return true; }
 UninflatedMessage* deflate() const { return new UninflatedMessage(*this); }

 UninflatedMessage* clone() const { return new UninflatedMessage(*this); }

 ~UninflatedMessage() { delete [] mBuffer; }

 MessageTypeID inflatedType() const { return mType; }
 size_t length() const { return mLength; }
 Uint8* buffer() { return mBuffer; }
 const Uint8* buffer() const { return mBuffer; }

private:
 void copyToThis(const UninflatedMessage& inSource)
 {
  mType = inSource.mType;
  mLength = inSource.mLength;
  mBuffer = new Uint8[mLength];
  memcpy(mBuffer, inSource.mBuffer, mLength);
 }

 MessageTypeID mType;
 size_t mLength;
 Uint8* mBuffer;
};



class AIStream;
class AOStream;

class SmallMessageHelper : public Message
{
public:
 bool inflateFrom(const UninflatedMessage& inUninflated);
 UninflatedMessage* deflate() const;

protected:
 virtual bool reallyInflateFrom(AIStream& inStream) = 0;
 virtual void reallyDeflateTo(AOStream& inStream) const = 0;

private:
};



class BigChunkOfDataMessage : public Message
{
public:
 BigChunkOfDataMessage(MessageTypeID inType, const Uint8* inBuffer = __null, size_t inLength = 0);
 BigChunkOfDataMessage(const BigChunkOfDataMessage& other) : mLength(0), mBuffer(__null)
 {
  mType = other.type();
  copyBufferFrom(other.buffer(), other.length());
 }

 BigChunkOfDataMessage& operator =(const BigChunkOfDataMessage& other)
 {
  if(&other != this)
  {
   mType = other.type();
   copyBufferFrom(other.buffer(), other.length());
  }

  return *this;
 }

 bool inflateFrom(const UninflatedMessage& inUninflated);
 UninflatedMessage* deflate() const;
 MessageTypeID type() const { return mType; }

 void copyBufferFrom(const Uint8* inBuffer, size_t inLength);

 size_t length() const { return mLength; }
 Uint8* buffer() { return mBuffer; }
 const Uint8* buffer() const { return mBuffer; }

 BigChunkOfDataMessage* clone() const;

 ~BigChunkOfDataMessage();

private:
 MessageTypeID mType;
 size_t mLength;
 Uint8* mBuffer;
};



template <typename tValueType>
class SimpleMessage : public SmallMessageHelper
{
public:
 typedef tValueType ValueType;

 SimpleMessage(MessageTypeID inType)
  : mType(inType)
 {

  new (static_cast<void*>(&mValue)) tValueType();
 }

 SimpleMessage(MessageTypeID inType, const tValueType& inValue)
  : mType(inType), mValue(inValue)
 {
 }

 SimpleMessage<tValueType>* clone() const
  { return new SimpleMessage<tValueType>(*this); }

 MessageTypeID type() const { return mType; }

 void setValue(const tValueType& inValue) { mValue = inValue; }
 const tValueType& value() const { return mValue; }

protected:
 void reallyDeflateTo(AOStream& inStream) const
 {
  inStream << mValue;
 }

 bool reallyInflateFrom(AIStream& inStream)
 {
  inStream >> mValue;
  return true;
 }

private:
 MessageTypeID mType;
 tValueType mValue;
};



template <MessageTypeID tMessageType>
class DatalessMessage : public Message
{
public:
 enum { kType = tMessageType };

 MessageTypeID type() const { return kType; }

 bool inflateFrom(const UninflatedMessage& inUninflated)
 {
  return inUninflated.inflatedType() == kType && inUninflated.length() == 0;
 }

 UninflatedMessage* deflate() const { return new UninflatedMessage(kType, 0); }

 DatalessMessage<tMessageType>* clone() const
 { return new DatalessMessage<tMessageType>; }
};
# 29 "../Source_Files/Network/Metaserver/metaserver_messages.h" 2


# 1 "/usr/local/pspdev/psp/include/SDL/SDL_net.h" 1
# 28 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 29 "/usr/local/pspdev/psp/include/SDL/SDL_net.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h" 1
# 47 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_types.h" 1
# 48 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_rwops.h" 1
# 49 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_byteorder.h" 1
# 50 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 52 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h" 2


extern "C" {
# 89 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h"
static __inline__ Uint16 SDL_Swap16(Uint16 x) {
 return((x<<8)|(x>>8));
}
# 123 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h"
static __inline__ Uint32 SDL_Swap32(Uint32 x) {
 return((x<<24)|((x<<8)&0x00FF0000)|((x>>8)&0x0000FF00)|(x>>24));
}
# 149 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h"
static __inline__ Uint64 SDL_Swap64(Uint64 x)
{
 Uint32 hi, lo;


 lo = (Uint32)(x&0xFFFFFFFF);
 x >>= 32;
 hi = (Uint32)(x&0xFFFFFFFF);
 x = SDL_Swap32(lo);
 x <<= 32;
 x |= SDL_Swap32(hi);
 return(x);
}
# 190 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h"
extern Uint16 SDL_ReadLE16(SDL_RWops *src);
extern Uint16 SDL_ReadBE16(SDL_RWops *src);
extern Uint32 SDL_ReadLE32(SDL_RWops *src);
extern Uint32 SDL_ReadBE32(SDL_RWops *src);
extern Uint64 SDL_ReadLE64(SDL_RWops *src);
extern Uint64 SDL_ReadBE64(SDL_RWops *src);


extern int SDL_WriteLE16(SDL_RWops *dst, Uint16 value);
extern int SDL_WriteBE16(SDL_RWops *dst, Uint16 value);
extern int SDL_WriteLE32(SDL_RWops *dst, Uint32 value);
extern int SDL_WriteBE32(SDL_RWops *dst, Uint32 value);
extern int SDL_WriteLE64(SDL_RWops *dst, Uint64 value);
extern int SDL_WriteBE64(SDL_RWops *dst, Uint64 value);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 211 "/usr/local/pspdev/psp/include/SDL/SDL_endian.h" 2
# 30 "/usr/local/pspdev/psp/include/SDL/SDL_net.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_version.h" 1
# 31 "/usr/local/pspdev/psp/include/SDL/SDL_net.h" 2
# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 32 "/usr/local/pspdev/psp/include/SDL/SDL_net.h" 2





extern "C" {
# 60 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern const SDL_version * SDLNet_Linked_Version(void);





extern int SDLNet_Init(void);
extern void SDLNet_Quit(void);





typedef struct {
 Uint32 host;
 Uint16 port;
} IPaddress;
# 93 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_ResolveHost(IPaddress *address, const char *host, Uint16 port);






extern const char * SDLNet_ResolveIP(IPaddress *ip);






typedef struct _TCPsocket *TCPsocket;
# 117 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern TCPsocket SDLNet_TCP_Open(IPaddress *ip);




extern TCPsocket SDLNet_TCP_Accept(TCPsocket server);




extern IPaddress * SDLNet_TCP_GetPeerAddress(TCPsocket sock);






extern int SDLNet_TCP_Send(TCPsocket sock, const void *data,
  int len);







extern int SDLNet_TCP_Recv(TCPsocket sock, void *data, int maxlen);


extern void SDLNet_TCP_Close(TCPsocket sock);
# 158 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
typedef struct _UDPsocket *UDPsocket;
typedef struct {
 int channel;
 Uint8 *data;
 int len;
 int maxlen;
 int status;
 IPaddress address;
} UDPpacket;




extern UDPpacket * SDLNet_AllocPacket(int size);
extern int SDLNet_ResizePacket(UDPpacket *packet, int newsize);
extern void SDLNet_FreePacket(UDPpacket *packet);






extern UDPpacket ** SDLNet_AllocPacketV(int howmany, int size);
extern void SDLNet_FreePacketV(UDPpacket **packetV);
# 190 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern UDPsocket SDLNet_UDP_Open(Uint16 port);
# 201 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_UDP_Bind(UDPsocket sock, int channel, IPaddress *address);


extern void SDLNet_UDP_Unbind(UDPsocket sock, int channel);







extern IPaddress * SDLNet_UDP_GetPeerAddress(UDPsocket sock, int channel);
# 221 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_UDP_SendV(UDPsocket sock, UDPpacket **packets, int npackets);
# 235 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_UDP_Send(UDPsocket sock, int channel, UDPpacket *packet);
# 247 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_UDP_RecvV(UDPsocket sock, UDPpacket **packets);
# 259 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_UDP_Recv(UDPsocket sock, UDPpacket *packet);


extern void SDLNet_UDP_Close(UDPsocket sock);






typedef struct _SDLNet_SocketSet *SDLNet_SocketSet;


typedef struct {
 int ready;
} *SDLNet_GenericSocket;





extern SDLNet_SocketSet SDLNet_AllocSocketSet(int maxsockets);






extern int SDLNet_AddSocket(SDLNet_SocketSet set, SDLNet_GenericSocket sock);






extern int SDLNet_DelSocket(SDLNet_SocketSet set, SDLNet_GenericSocket sock);
# 303 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern int SDLNet_CheckSockets(SDLNet_SocketSet set, Uint32 timeout);
# 313 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
extern void SDLNet_FreeSocketSet(SDLNet_SocketSet set);







extern void SDLNet_Write16(Uint16 value, void *area);
extern void SDLNet_Write32(Uint32 value, void *area);


extern Uint16 SDLNet_Read16(void *area);
extern Uint32 SDLNet_Read32(void *area);
# 440 "/usr/local/pspdev/psp/include/SDL/SDL_net.h"
}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 443 "/usr/local/pspdev/psp/include/SDL/SDL_net.h" 2
# 32 "../Source_Files/Network/Metaserver/metaserver_messages.h" 2
# 1 "../Source_Files/Misc/Scenario.h" 1
# 33 "../Source_Files/Misc/Scenario.h"
using namespace std;

class Scenario
{
public:
 static Scenario *instance();

 const string GetName() { return m_name; }
 void SetName(const string name) { m_name = string(name, 0, 31); }

 const string GetVersion() { return m_version; }
 void SetVersion(const string version) { m_version = string(version, 0, 7); }

 const string GetID() { return m_id; }
 void SetID(const string id) { m_id = string(id, 0, 23); }

 bool IsCompatible(const string);
 void AddCompatible(const string);

private:
 Scenario() { }

 string m_name;
 string m_version;
 string m_id;

 vector<string> m_compatibleVersions;

 static Scenario *m_instance;
};


XML_ElementParser *Scenario_GetParser();
# 33 "../Source_Files/Network/Metaserver/metaserver_messages.h" 2
# 1 "../Source_Files/Network/network.h" 1
# 56 "../Source_Files/Network/network.h"
enum
{
 _appletalk_remote,
 _localtalk,
 _tokentalk,
 _ethernet,



 NUMBER_OF_NETWORK_TYPES
};

typedef struct game_info
{
 uint16 initial_random_seed;
 int16 net_game_type;
 int32 time_limit;
 int16 kill_limit;
 int16 game_options;
 int16 difficulty_level;
 bool server_is_playing;
 bool allow_mic;

        int16 cheat_flags;


 int16 level_number;
 char level_name[64 +1];


 int16 initial_updates_per_packet;
 int16 initial_update_latency;
} game_info;




typedef struct player_info
{
 unsigned char name[32 +1];
 int16 desired_color;
 int16 team;
 int16 color;
 byte long_serial_number[10];
} player_info;


struct prospective_joiner_info {
 uint16 stream_id;
 unsigned char name[32];
 int16 color;
 int16 team;
 bool gathering;
};




enum
{
 removeEntity,
 insertEntity
};

class GatherCallbacks
{
 public:
  virtual ~GatherCallbacks() { };

  virtual void JoinSucceeded(const prospective_joiner_info *player) = 0;
  virtual void JoiningPlayerDropped(const prospective_joiner_info *player) = 0;
  virtual void JoinedPlayerDropped(const prospective_joiner_info *player) = 0;
  virtual void JoinedPlayerChanged(const prospective_joiner_info *player) { };
};

class ChatCallbacks
{
 public:
  virtual ~ChatCallbacks() { };
  static void SendChatMessage(const std::string& message);
  virtual void ReceivedMessageFromPlayer(const char *player_name,
      const char *message) = 0;
};

class InGameChatCallbacks : public ChatCallbacks
{
 public:
  ~InGameChatCallbacks() { }
  static InGameChatCallbacks *instance();
  void ReceivedMessageFromPlayer(const char *player_name, const char *message);

  static std::string prompt();

 private:
  InGameChatCallbacks() { }
  static InGameChatCallbacks *m_instance;
};






enum
{
 netUninitialized,
 netGathering,
 netConnecting,
 netJoining,
 netWaiting,
 netStartingUp,
 netActive,
 netComingDown,
 netDown,
 netCancelled,
 netPlayerAdded,
 netPlayerDropped,
 netPlayerChanged,
 netJoinErrorOccurred,
        netChatMessageReceived,
        netStartingResumeGame,
 netAwaitingHello
};



typedef void (*NetDistributionProc)(void *buffer, short buffer_size, short player_index);
typedef void (*CheckPlayerProcPtr)(short player_index, short num_players);


void NetSetGatherCallbacks(GatherCallbacks *gc);
void NetSetChatCallbacks(ChatCallbacks *cc);
bool NetEnter();
void NetDoneGathering (void);
void NetExit(void);

bool NetGather(void *game_data, short game_data_size, void *player_data,
 short player_data_size, bool resuming_game);

struct SSLP_ServiceInstance;

enum {
        kGatherPlayerFailed,
        kGatherPlayerSuccessful,
        kGatheredUnacceptablePlayer

};

int NetGatherPlayer(

const prospective_joiner_info &player,
CheckPlayerProcPtr check_player);

void NetHandleUngatheredPlayer(prospective_joiner_info ungathered_player);


bool NetGameJoin(void *player_data, short player_data_size, const char* host_address_string);

bool NetCheckForNewJoiner (prospective_joiner_info &info);
short NetUpdateJoinState(void);
void NetCancelJoin(void);



void NetChangeColors(int16 color, int16 team);
# 230 "../Source_Files/Network/network.h"
bool NetGetMostRecentChatMessage(player_info** outSendingPlayerData, char** outMessage);


OSErr NetDistributeChatMessage(short sender_identifier, const char* message);

void NetProcessMessagesInGame();

short NetGetLocalPlayerIndex(void);
short NetGetPlayerIdentifier(short player_index);

bool NetNumberOfPlayerIsValid(void);
short NetGetNumberOfPlayers(void);

void *NetGetPlayerData(short player_index);
void *NetGetGameData(void);

struct player_start_data;

void NetSetupTopologyFromStarts(const player_start_data* inStartArray, short inStartCount);

void NetSetInitialParameters(short updates_per_packet, short update_latency);

bool NetSync(void);
bool NetUnSync(void);

bool NetStart(void);
void NetCancelGather(void);

long NetGetNetTime(void);

bool NetChangeMap(struct entry_point *entry);
OSErr NetDistributeGameDataToAllPlayers(byte* wad_buffer, long wad_length, bool do_physics);
byte* NetReceiveGameData(bool do_physics);

void DeferredScriptSend (byte* data, size_t length);
void SetNetscriptStatus (bool status);

void display_net_game_stats(void);




void NetAddDistributionFunction(int16 type, NetDistributionProc proc, bool lossy);
void NetDistributeInformation(short type, void *buffer, short buffer_size, bool send_to_self, bool send_only_to_team = false);
void NetRemoveDistributionFunction(short type);


bool NetAllowCrosshair();
bool NetAllowTunnelVision();
bool NetAllowBehindview();
bool NetAllowCarnageMessages();
bool NetAllowSavingLevel();



int32 NetGetUnconfirmedActionFlagsCount();
uint32 NetGetUnconfirmedActionFlag(int32 offset);
void NetUpdateUnconfirmedActionFlags();

enum {
 kNetLatencyInvalid = -1,
 kNetLatencyDisconnected = -2
};


int32 NetGetLatency();

int32 NetGetLatency(int player_index);


bool NetDisplayPings();
# 34 "../Source_Files/Network/Metaserver/metaserver_messages.h" 2



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/config.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/locale" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/locale" 3
       
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/locale" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 66 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 102 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 121 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    locale() throw();
# 130 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 140 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 155 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 168 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 180 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 194 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 209 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 228 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 256 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 272 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 307 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };





    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 340 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];





    static void
    _S_initialize_once();

  protected:
# 371 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 431 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 574 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 591 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 608 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 635 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 649 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 666 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 685 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 699 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 728 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 744 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 757 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;
# 784 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.tcc" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.tcc" 3
       
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);
# 274 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.tcc" 3
}
# 815 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_classes.h" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/locale" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwctype" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwctype" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwctype" 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/wctype.h" 1 3







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 9 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/wctype.h" 2 3





extern "C" {



typedef int wctype_t;




typedef int wctrans_t;


int iswalpha (wint_t);
int iswalnum (wint_t);
int iswblank (wint_t);
int iswcntrl (wint_t);
int iswctype (wint_t, wctype_t);
int iswdigit (wint_t);
int iswgraph (wint_t);
int iswlower (wint_t);
int iswprint (wint_t);
int iswpunct (wint_t);
int iswspace (wint_t);
int iswupper (wint_t);
int iswxdigit (wint_t);
wint_t towctrans (wint_t, wctrans_t);
wint_t towupper (wint_t);
wint_t towlower (wint_t);
wctrans_t wctrans (const char *);
wctype_t wctype (const char *);

}
# 52 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cwctype" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cctype" 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/ctype_base.h" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef char mask;
    static const mask upper = 01;
    static const mask lower = 02;
    static const mask alpha = 01 | 02;
    static const mask digit = 04;
    static const mask xdigit = 0100 | 04;
    static const mask space = 010;
    static const mask print = 020 | 01 | 02 | 04 | 0200;
    static const mask graph = 020 | 01 | 02 | 04;
    static const mask cntrl = 040;
    static const mask punct = 020;
    static const mask alnum = 01 | 02 | 04;
  };

}
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstdio" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 203 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 255 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 330 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 361 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;





    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 394 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 420 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 437 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 449 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:




    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 558 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 574 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 591 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 617 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 668 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 680 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 691 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 702 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 721 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 737 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 758 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 775 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
       
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 118 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 184 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 265 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 279 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 297 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 319 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 338 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 352 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 377 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 404 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 430 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 444 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 462 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 478 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 489 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 509 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 525 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 535 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 556 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 571 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 582 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 594 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 607 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual int
      sync() { return 0; }
# 629 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 645 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 667 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 680 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 704 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 722 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 747 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 762 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);







}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf.tcc" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf.tcc" 3
       
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);
# 177 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf.tcc" 3
}
# 802 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/streambuf" 2 3
# 52 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf_iterator.h" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf_iterator.h" 3
       
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 56 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 167 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 184 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 200 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 216 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 230 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 245 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 259 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 274 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 291 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 310 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 329 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 351 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 376 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 395 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 414 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 433 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 451 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 468 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 484 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 501 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 520 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 541 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 563 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 587 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 610 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 679 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 716 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 729 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 742 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 757 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 771 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 785 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 800 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 817 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 833 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 850 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 870 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 897 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 928 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 961 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1010 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1027 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1043 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1060 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1080 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1103 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1129 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1155 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 if (__builtin_memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);

 _M_narrow_ok = 1;
 if (__builtin_memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {


     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1515 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };
# 1556 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/ctype_inline.h" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }

}
# 1560 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1684 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1721 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1735 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1749 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1762 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1793 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1806 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1819 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1836 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1848 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1861 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1874 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1887 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
# 1916 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1956 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1977 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 2003 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2039 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2098 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2140 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2270 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2287 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2308 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2326 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2368 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2431 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2456 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2504 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
       
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__np.grouping()[0]) > 0);

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
# 124 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (__gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 const __unsigned_type __max = __negative
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testfail = true;
       else
  {
    __result *= __base;
    __testfail |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testfail = true;
    else
      {
        __result *= __base;
        __testfail |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!__testfail && (__sep_pos || __found_zero
       || __found_grouping.size()))
   __v = __negative ? -__result : __result;
 else
   __err |= ios_base::failbit;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;

       if (__testf)
         {
    if (__n < __lc->_M_falsename_size)
      __testf = __c == __lc->_M_falsename[__n];
    else
      break;
  }

       if (__testt)
         {
    if (__n < __lc->_M_truename_size)
      __testt = __c == __lc->_M_truename[__n];
    else
      break;
  }

       if (!__testf && !__testt)
  break;

       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = false;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = true;
   else
     __err |= ios_base::failbit;

          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
# 717 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 952 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);
# 994 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
 const bool __fixed = __io.flags() & ios_base::fixed;
 const int __max_exp =
   __gnu_cxx::__numeric_traits<_ValueT>::__max_exponent10;







 const int __cs_size = __fixed ? __max_exp + __prec + 4
                               : __max_digits * 2 + __prec;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, 0, __fbuf,
          __prec, __v);




 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1190 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);
# 1351 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.tcc" 3
}
# 2636 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets.h" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/locale" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
       
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ctime" 1 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ctime" 3
       
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ctime" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ctime" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/time.h" 1 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ctime" 2 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ctime" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {







  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];
# 175 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 212 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;
# 346 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/time_members.h" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }

}
# 350 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 365 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 387 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 404 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 428 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 453 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 481 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 510 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 536 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 556 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 574 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 593 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 612 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 631 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 650 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 706 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 727 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 746 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 766 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 793 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 831 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 952 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 964 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 979 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 993 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1006 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1035 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1048 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1065 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1082 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1098 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1133 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1155 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1167 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1180 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1193 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1206 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1219 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1233 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1247 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1261 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);
# 1310 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;


# 1355 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1377 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1407 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1437 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1460 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1472 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1483 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1504 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1525 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1545 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1567 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1601 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1624 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1635 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;






  struct messages_base
  {
    typedef int catalog;
  };
# 1674 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1702 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1716 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1729 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1747 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1765 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1776 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1796 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1815 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 1872 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;
# 1891 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 3
   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };

}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/messages_members.h" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/psp/bits/messages_members.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }

}
# 1911 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 119 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 158 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 199 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 240 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };
# 452 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);
# 500 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/codecvt.h" 3
}
# 1914 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 3
       
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__mp.grouping()[0]) > 0);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }



  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 346 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 551 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
# 577 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 3
      const int __cs_size =
 __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 3;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, 0, "%.*Lf",
     0, __units);

      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }






  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':





    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 61, 2,

      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __tmperr);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }






  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);
# 1329 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.tcc" 3
}
# 1917 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/locale_facets_nonio.h" 2 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/locale" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 1 3
# 10 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 1 3
# 62 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 78 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 93 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 2 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 1 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 3
       
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
       
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ios" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ios" 3
       
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ios" 3







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
       
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3






namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.tcc" 1 3
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.tcc" 3
       
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 150 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;






}
# 476 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/basic_ios.h" 2 3
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ios" 2 3
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 85 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 111 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 168 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 253 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 286 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 314 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 327 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      flush();
# 338 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      pos_type
      tellp();
# 349 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 361 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 383 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 402 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 412 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 430 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 451 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 493 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 543 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream.tcc" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream.tcc" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);
# 410 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/ostream.tcc" 3
}
# 573 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/ostream" 2 3
# 71 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
       
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 94 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 122 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 169 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 241 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 251 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 283 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      int_type
      get();
# 297 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      get(char_type& __c);
# 324 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 335 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 358 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 368 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 397 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 408 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 432 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 449 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      int_type
      peek();
# 467 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 486 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 502 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      putback(char_type __c);
# 517 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      unget();
# 535 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      int
      sync();
# 549 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      pos_type
      tellg();
# 564 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      seekg(pos_type);
# 580 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);
# 638 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 670 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 680 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 700 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 741 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 768 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 829 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/istream.tcc" 1 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/istream.tcc" 3
       
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<short>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<short>::__max)
     __n = short(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<int>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<int>::__max)
     __n = int(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 468 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;
# 1025 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/istream.tcc" 3
}
# 837 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/istream" 2 3
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stream_iterator.h" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stream_iterator.h" 3
       
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {
 ;


 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {
 ;


 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {
 ;


 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 150 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 181 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;


 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };

}
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/iterator" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator.hpp" 2 3


namespace boost
{
# 39 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator.hpp" 3
  namespace detail {
   template <class Category, class T, class Distance, class Pointer, class Reference>

   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator.hpp" 3
  }

  template <class Category, class T, class Distance = std::ptrdiff_t,
            class Pointer = T*, class Reference = T&>
  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};

}
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/enable_if.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/enable_if.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/identity.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/identity.hpp" 3
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/enable_if.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/enable_if.hpp" 2 3







namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
# 62 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/enable_if.hpp" 3
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {



    };

  }

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 85 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/enable_if.hpp" 2 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/iterator.hpp" 1 3
# 77 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/iterator.hpp" 3
namespace boost { namespace detail {


template <class Iterator>
struct iterator_traits
    : std::iterator_traits<Iterator>
{};
using std::distance;

}}
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/eval_if.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/eval_if.hpp" 3
namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;




   
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg_fwd.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg_fwd.hpp" 3
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_assert.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_assert.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/not.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/not.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/nested_type_wknd.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/nested_type_wknd.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/not.hpp" 2 3



namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/yes_no.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/yes_no.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/arrays.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/yes_no.hpp" 2 3




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/yes_no.hpp" 3
}}}
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 2 3
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 2 3
# 61 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 3
namespace mpl_ {

struct failed {};
# 74 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 3
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 122 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 3
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};






template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};

template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );

template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 211 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/assert.hpp" 3
}
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/na_assert.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/arity_spec.hpp" 1 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/arg_typedef.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 2 3





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/compiler.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/stringize.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 2 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 3
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 2 3






namespace boost {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};
# 108 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 3
  template <class Traversal>
  struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal,random_access_traversal_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Traversal,bidirectional_traversal_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Traversal,forward_traversal_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Traversal,single_pass_traversal_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Traversal,incrementable_traversal_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {
  };
# 142 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 3
}





template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename boost::detail::iterator_traits<Iterator>::iterator_category
    >
{};
# 184 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 187 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_categories.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/interoperable.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/interoperable.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/or.hpp" 1 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/or.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }





}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/or.hpp" 2 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/interoperable.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/interoperable.hpp" 2 3

namespace boost
{
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/interoperable.hpp" 3
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/interoperable.hpp" 2 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_traits.hpp" 1 3
# 11 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_traits.hpp" 3
namespace boost {
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_traits.hpp" 3
template <class Iterator>
struct iterator_value
{
    typedef typename detail::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename detail::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename detail::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename detail::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename detail::iterator_traits<Iterator>::iterator_category type;
};
# 90 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_traits.hpp" 3
}
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/and.hpp" 1 3
# 40 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/and.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 41 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/and.hpp" 2 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_same.hpp" 1 3
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_same.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_same.hpp" 2 3

namespace boost {



template< typename T, typename U > struct is_same : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_same< T,T > : ::boost::integral_constant<bool,true> { };
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_same.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 101 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_same.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_pointer.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_pointer.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_pointer.hpp" 2 3

namespace boost {



template< typename T > struct remove_pointer { typedef T type; };
template< typename T > struct remove_pointer<T*> { typedef T type; };
template< typename T > struct remove_pointer<T* const> { typedef T type; };
template< typename T > struct remove_pointer<T* volatile> { typedef T type; };
template< typename T > struct remove_pointer<T* const volatile> { typedef T type; };







}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 42 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/remove_pointer.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 2 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 3
namespace boost { namespace detail {

namespace indirect_traits {


template <class T>
struct is_reference_to_const : mpl::false_
{
};

template <class T>
struct is_reference_to_const<T const&> : mpl::true_
{
};
# 55 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_function : mpl::false_
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : mpl::false_
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : mpl::false_
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
   
};

template <class T>
struct is_reference_to_function_pointer_aux
    : mpl::and_<
          is_reference<T>
        , is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : mpl::if_<
          is_reference_to_function<T>
        , mpl::false_
        , is_reference_to_function_pointer_aux<T>
     >::type
{
};

template <class T>
struct is_reference_to_non_const
    : mpl::and_<
          is_reference<T>
        , mpl::not_<
             is_reference_to_const<T>
          >
      >
{
};

template <class T>
struct is_reference_to_volatile : mpl::false_
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : mpl::true_
{
};
# 149 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_pointer : mpl::false_
{
};

template <class T>
struct is_reference_to_pointer<T*&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_class
    : mpl::and_<
          is_reference<T>
        , is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{
   
};

template <class T>
struct is_pointer_to_class
    : mpl::and_<
          is_pointer<T>
        , is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >
      >
{
   
};
# 481 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/detail/indirect_traits.hpp" 3
}

using namespace indirect_traits;

}}
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3







namespace boost { struct use_default; }

namespace boost { namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
# 87 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 3
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{
# 154 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 3
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( !(is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >::value) ) >)> boost_static_assert_typedef_158;





    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( is_iterator_category<Category>::value ) >)> boost_static_assert_typedef_160;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( !is_iterator_category<Traversal>::value ) >)> boost_static_assert_typedef_161;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( !is_iterator_traversal<Category>::value ) >)> boost_static_assert_typedef_162;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( is_iterator_traversal<Traversal>::value ) >)> boost_static_assert_typedef_164;


};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( !is_iterator_category<Traversal>::value ) >)> boost_static_assert_typedef_175;


    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 208 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/implicit_cast.hpp" 1 3
# 10 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/implicit_cast.hpp" 3
namespace boost {






template <typename T>
inline T implicit_cast (typename mpl::identity<T>::type x) {
    return x;
}






}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_scalar.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_scalar.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_scalar.hpp" 2 3

namespace boost {

namespace detail {

template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value);






};



template <> struct is_scalar_impl<void>{ static const bool value = false; };

template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };


}

template< typename T > struct is_scalar : ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 54 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_scalar.hpp" 2 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 2 3

namespace boost {


template< typename T > struct is_POD;

namespace detail {



template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, false >::value);






};


template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : is_pod_impl<T>
{
};
# 118 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 3
template<> struct is_pod_impl< void > { static const bool value = (true); };


template<> struct is_pod_impl< void const > { static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { static const bool value = (true); };


}

template< typename T > struct is_POD : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };
template< typename T > struct is_pod : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 134 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/type_traits/is_pod.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/always.hpp" 1 3
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/always.hpp" 3
namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
          typename T
        , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 1 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_fwd.hpp" 1 3
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_fwd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 3
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_fwd.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/has_apply.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/has_apply.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/has_xxx.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/has_xxx.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/type_wrapper.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/type_wrapper.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/has_xxx.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/has_xxx.hpp" 1 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/has_xxx.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/msvc_typename.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/has_xxx.hpp" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/has_apply.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/has_apply.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/has_apply.hpp" 2 3

namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/msvc_never_true.hpp" 1 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 2 3
# 34 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 3
namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 2 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind_fwd.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind_fwd.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/config/bind.hpp" 1 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind_fwd.hpp" 2 3






# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 3
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 33 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind_fwd.hpp" 2 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/placeholders.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/next.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/next.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/next_prior.hpp" 1 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/next_prior.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/common_name_wknd.hpp" 1 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/next_prior.hpp" 2 3



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/next.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/protect.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/protect.hpp" 3
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/protect.hpp" 3
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply_wrap.hpp" 1 3
# 28 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 2 3
# 50 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind.hpp" 2 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda.hpp" 2 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/bind_fwd.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/quote.hpp" 1 3
# 22 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/quote.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/void.hpp" 1 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/void.hpp" 3
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/quote.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/has_type.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/has_type.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/quote.hpp" 2 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/quote.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 3
namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/quote.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/arg.hpp" 1 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/template_arity.hpp" 1 3
# 43 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/template_arity.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) );



};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1;


};

template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value );




    typedef mpl::int_<value> type;
};

}}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/template_arity.hpp" 2 3
# 30 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 44 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/lambda.hpp" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 2 3
# 36 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 3
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{
   




};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   




};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   




};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   




};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 37 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/mpl/apply.hpp" 2 3
# 35 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 38 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3

namespace boost
{


  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable
# 80 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
      : ::boost::iterators::enable_if<
           mpl::or_<
               is_convertible<Facade1, Facade2>
             , is_convertible<Facade2, Facade1>
           >
         , Return
        >
    {};






    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;

        typedef typename mpl::eval_if<
            detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
# 130 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
# 244 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
# 269 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<Reference,Value const&>



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class T>
    struct operator_arrow_proxy
    {
        operator_arrow_proxy(T const* px) : m_value(*px) {}
        T* operator->() const { return &m_value; }


        operator T*() const { return &m_value; }
        mutable T m_value;
    };




    template <class ValueType, class Reference, class Pointer>
    struct operator_arrow_result
    {



        typedef typename mpl::if_<
            is_reference<Reference>
          , Pointer
          , operator_arrow_proxy<ValueType>
        >::type type;

        static type make(Reference x)
        {
            return implicit_cast<type>(&x);
        }
    };
# 342 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :
# 420 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };
  }
# 471 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
  class iterator_core_access
  {







      template <class I, class V, class TC, class R, class D> friend class iterator_facade;




      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs);
      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs);

      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs);
      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs);
      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs);
      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs);


      template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > friend typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }

   private:

      iterator_core_access();
  };





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade






  {
   private:



      Derived& derived()
      {
          return *static_cast<Derived*>(this);
      }

      Derived const& derived() const
      {
          return *static_cast<Derived const*>(this);
      }

      typedef detail::iterator_facade_types<
         Value, CategoryOrTraversal, Reference, Difference
      > associated_types;

   protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;

   public:

      typedef typename associated_types::value_type value_type;
      typedef Reference reference;
      typedef Difference difference_type;
      typedef typename associated_types::pointer pointer;
      typedef typename associated_types::iterator_category iterator_category;

      reference operator*() const
      {
          return iterator_core_access::dereference(this->derived());
      }

      typename detail::operator_arrow_result<
          value_type
        , reference
        , pointer
      >::type
      operator->() const
      {
          return detail::operator_arrow_result<
              value_type
            , reference
            , pointer
          >::make(*this->derived());
      }

      typename detail::operator_brackets_result<Derived,Value,reference>::type
      operator[](difference_type n) const
      {
          typedef detail::use_operator_brackets_proxy<Value,Reference> use_proxy;

          return detail::make_operator_brackets_result<Derived>(
              this->derived() + n
            , use_proxy()
          );
      }

      Derived& operator++()
      {
          iterator_core_access::increment(this->derived());
          return this->derived();
      }
# 680 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
      Derived& operator--()
      {
          iterator_core_access::decrement(this->derived());
          return this->derived();
      }

      Derived operator--(int)
      {
          Derived tmp(this->derived());
          --*this;
          return tmp;
      }

      Derived& operator+=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), n);
          return this->derived();
      }

      Derived& operator-=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), -n);
          return this->derived();
      }

      Derived operator-(difference_type x) const
      {
          Derived result(this->derived());
          return result -= x;
      }
# 722 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
  };


  template <class I, class V, class TC, class R, class D>
  inline typename detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
# 837 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_837; return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_838; return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }

  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_840; return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_841; return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_842; return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_843; return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }



  template < class Derived1, class V1, class TC1, class R1, class D1 , class Derived2, class V2, class TC2, class R2, class D2 > inline typename detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, R1, D1> const& lhs , iterator_facade<Derived2, V2, TC2, R2, D2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( ( is_interoperable< Derived1, Derived2 >::value ) ) >)> boost_static_assert_typedef_852; return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 863 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 3
template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }






}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 878 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_facade.hpp" 2 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 31 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 32 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 2 3



namespace boost
{



  struct use_default;





  template<class To>
  struct is_convertible<use_default,To>
    : mpl::false_ {};


  namespace detail
  {
# 61 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 3
    struct enable_type;
  }
# 143 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 3
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , detail::enable_type
      >
  {};






  namespace detail
  {


    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };



    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived


          , typename detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type






          , typename detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type

          , typename detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type

          , typename detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };


    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( (is_convertible<Tr1, Tr2>::value) ) >)> boost_static_assert_typedef_225;
    }
  }
# 254 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 3
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;

   protected:
      typedef typename detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}

      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }

      typedef Base base_type;

      Base const& base() const
        { return m_iterator; }

   protected:

      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;




      Base const& base_reference() const
        { return m_iterator; }

      Base& base_reference()
        { return m_iterator; }

   private:






      typename super_t::reference dereference() const
        { return *m_iterator; }

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {




          return m_iterator == x.base();
      }

      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;




      void advance(typename super_t::difference_type n)
      {
          detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }

      void increment() { ++m_iterator; }

      void decrement()
      {
          detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();




          return y.base() - m_iterator;
      }



   private:
      Base m_iterator;
  };

}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 365 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 2 3
# 29 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_def.hpp" 1 3
# 30 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 2 3


namespace boost
{
  template <class UnaryFunction, class Iterator, class Reference = use_default, class Value = use_default>
  class transform_iterator;

  namespace detail
  {

    template <class UnaryFunction>
    struct function_object_result
    {
      typedef typename UnaryFunction::result_type type;
    };


    template <class Return, class Argument>
    struct function_object_result<Return(*)(Argument)>
    {
      typedef Return type;
    };



    template <class UnaryFunction, class Iterator, class Reference, class Value>
    struct transform_iterator_base
    {
     private:




        typedef typename ia_dflt_help<
            Reference
          , function_object_result<UnaryFunction>
        >::type reference;






        typedef typename ia_dflt_help<
            Value
          , remove_reference<reference>
        >::type cv_value_type;

     public:
        typedef iterator_adaptor<
            transform_iterator<UnaryFunction, Iterator, Reference, Value>
          , Iterator
          , cv_value_type
          , use_default
          , reference
        > type;
    };
  }

  template <class UnaryFunction, class Iterator, class Reference, class Value>
  class transform_iterator
    : public detail::transform_iterator_base<UnaryFunction, Iterator, Reference, Value>::type
  {
    typedef typename
    detail::transform_iterator_base<UnaryFunction, Iterator, Reference, Value>::type
    super_t;

    friend class iterator_core_access;

  public:
    transform_iterator() { }

    transform_iterator(Iterator const& x, UnaryFunction f)
      : super_t(x), m_f(f) { }

    explicit transform_iterator(Iterator const& x)
      : super_t(x)
    {





        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( is_class<UnaryFunction>::value ) >)> boost_static_assert_typedef_113;

    }

    template<
        class OtherUnaryFunction
      , class OtherIterator
      , class OtherReference
      , class OtherValue>
    transform_iterator(
         transform_iterator<OtherUnaryFunction, OtherIterator, OtherReference, OtherValue> const& t
       , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0

       , typename enable_if_convertible<OtherUnaryFunction, UnaryFunction>::type* = 0

    )
      : super_t(t.base()), m_f(t.functor())
   {}

    UnaryFunction functor() const
      { return m_f; }

  private:
    typename super_t::reference dereference() const
    { return m_f(*this->base()); }



    UnaryFunction m_f;
  };

  template <class UnaryFunction, class Iterator>
  transform_iterator<UnaryFunction, Iterator>
  make_transform_iterator(Iterator it, UnaryFunction fun)
  {
      return transform_iterator<UnaryFunction, Iterator>(it, fun);
  }
# 158 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 3
  template <class UnaryFunction, class Iterator>



  typename iterators::enable_if<

      is_class<UnaryFunction>
    , transform_iterator<UnaryFunction, Iterator>



  >::type
  make_transform_iterator(Iterator it)
  {
      return transform_iterator<UnaryFunction, Iterator>(it, UnaryFunction());
  }
# 184 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 3
}

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/detail/config_undef.hpp" 1 3
# 187 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/iterator/transform_iterator.hpp" 2 3
# 17 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/config.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 2 3





# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/iterator.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/iterator.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/iterator.hpp" 2 3


namespace boost
{




    template< typename C >
    struct range_iterator
    {
        typedef typename C::iterator type;
    };





    template< typename Iterator >
    struct range_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };

    template< typename Iterator >
    struct range_iterator< const std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };





    template< typename T, std::size_t sz >
    struct range_iterator< T[sz] >
    {
        typedef T* type;
    };

    template< typename T, std::size_t sz >
    struct range_iterator< const T[sz] >
    {
        typedef const T* type;
    };





    template<>
    struct range_iterator< char* >
    {
        typedef char* type;
    };

    template<>
    struct range_iterator< wchar_t* >
    {
        typedef wchar_t* type;
    };

    template<>
    struct range_iterator< const char* >
    {
        typedef const char* type;
    };

    template<>
    struct range_iterator< const wchar_t* >
    {
        typedef const wchar_t* type;
    };

    template<>
    struct range_iterator< char* const >
    {
        typedef char* type;
    };

    template<>
    struct range_iterator< wchar_t* const >
    {
        typedef wchar_t* type;
    };

    template<>
    struct range_iterator< const char* const >
    {
        typedef const char* type;
    };

    template<>
    struct range_iterator< const wchar_t* const >
    {
        typedef const wchar_t* type;
    };

}
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/const_iterator.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/const_iterator.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/const_iterator.hpp" 2 3


namespace boost
{




    template< typename C >
    struct range_const_iterator
    {
        typedef typename C::const_iterator type;
    };





    template< typename Iterator >
    struct range_const_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };

    template< typename Iterator >
    struct range_const_iterator< const std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };





    template< typename T, std::size_t sz >
    struct range_const_iterator< T[sz] >
    {
        typedef const T* type;
    };

    template< typename T, std::size_t sz >
    struct range_const_iterator< const T[sz] >
    {
        typedef const T* type;
    };





    template<>
    struct range_const_iterator< char* >
    {
        typedef const char* type;
    };

    template<>
    struct range_const_iterator< wchar_t* >
    {
        typedef const wchar_t* type;
    };

    template<>
    struct range_const_iterator< const char* >
    {
        typedef const char* type;
    };

    template<>
    struct range_const_iterator< const wchar_t* >
    {
        typedef const wchar_t* type;
    };

    template<>
    struct range_const_iterator< char* const >
    {
        typedef const char* type;
    };

    template<>
    struct range_const_iterator< wchar_t* const >
    {
        typedef const wchar_t* type;
    };

    template<>
    struct range_const_iterator< const char* const >
    {
        typedef const char* type;
    };

    template<>
    struct range_const_iterator< const wchar_t* const >
    {
        typedef const wchar_t* type;
    };

}
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 2 3

namespace boost
{




namespace range_detail
{






    template< typename C >
    inline typename range_const_iterator<C>::type
    boost_range_begin( const C& c )
    {
        return c.begin();
    }

    template< typename C >
    inline typename range_iterator<
                                                                        typename remove_const<C>::type >::type
    boost_range_begin( C& c )
    {
        return c.begin();
    }





    template< typename Iterator >
    inline Iterator boost_range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }

    template< typename Iterator >
    inline Iterator boost_range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }





    template< typename T, std::size_t sz >
    inline const T* boost_range_begin( const T (&array)[sz] )
    {
        return array;
    }

    template< typename T, std::size_t sz >
    inline T* boost_range_begin( T (&array)[sz] )
    {
        return array;
    }
# 96 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 3
    inline const char* boost_range_begin( const char* s )
    {
        return s;
    }

    inline char* boost_range_begin( char* s )
    {
        return s;
    }

    inline const wchar_t* boost_range_begin( const wchar_t* s )
    {
        return s;
    }

    inline wchar_t* boost_range_begin( wchar_t* s )
    {
        return s;
    }
# 140 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 3
}



template< class T >
inline typename range_iterator<
                        typename remove_const<T>::type >::type begin( T& r )
{



    using namespace range_detail;

    return boost_range_begin( r );
}

template< class T >
inline typename range_const_iterator<T>::type begin( const T& r )
{



    using namespace range_detail;

    return boost_range_begin( r );
}
# 183 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/begin.hpp" 3
}



namespace boost
{
    template< class T >
    inline typename range_const_iterator<T>::type
    const_begin( const T& r )
    {
        return boost::begin( r );
    }
}
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/end.hpp" 1 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/end.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/implementation_help.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/implementation_help.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/common.hpp" 1 3
# 19 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/common.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/sfinae.hpp" 1 3
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/sfinae.hpp" 3
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;





        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );

        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );

        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );

        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );

        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );

        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );

        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );





        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );





        struct char_or_wchar_t_array_tag {};

    }

}
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/common.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/common.hpp" 2 3





namespace boost
{
    namespace range_detail
    {
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/common.hpp" 3
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;

        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;

            static const bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            static const bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_string_ = (boost::type_traits::ice_or<is_const_char_ptr_, is_const_wchar_t_ptr_>::value );
            static const bool is_array_ = boost::is_array<C>::value;

        };

        template< typename C >
        class range
        {
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef typename boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/implementation_help.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 1 3
# 45 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3
       
# 46 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/cstddef" 2 3
# 18 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/detail/implementation_help.hpp" 2 3






namespace boost
{
    namespace range_detail
    {





        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }







        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            if( s == 0 || s[0] == 0 )
                return s;
            while( *++s != 0 )
                ;
            return s;
        }


        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }

        template< class T, std::size_t sz >
        inline T* array_end( T (&boost_range_array)[sz], int )
        {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        inline const T* array_end( const T (&boost_range_array)[sz], int )
        {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        inline T* array_end( T (&boost_range_array)[sz], char_or_wchar_t_array_tag )
        {
            return boost_range_array + sz - 1;
        }

        template< class T, std::size_t sz >
        inline const T* array_end( const T (&boost_range_array)[sz], char_or_wchar_t_array_tag )
        {
            return boost_range_array + sz - 1;
        }

        template< class T, std::size_t sz >
        inline T* array_end( T (&boost_range_array)[sz] )
        {
            typedef typename boost::mpl::if_c< is_same<char,T>::value || is_same<wchar_t,T>::value,
                                                                char_or_wchar_t_array_tag,
                                                                int >::type tag;

            return array_end<T,sz>( boost_range_array, tag() );
        }

        template< class T, std::size_t sz >
        inline const T* array_end( const T (&boost_range_array)[sz] )
        {
            typedef typename boost::mpl::if_c< is_same<char,T>::value || is_same<wchar_t,T>::value,
                                                                char_or_wchar_t_array_tag,
                                                                int >::type tag;

            return array_end<T,sz>( boost_range_array, tag() );
        }





        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz], int )
        {
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz], int )
        {
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz], char_or_wchar_t_array_tag )
        {
            return sz - 1;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz], char_or_wchar_t_array_tag )
        {
            return sz - 1;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            typedef typename boost::mpl::if_c< is_same<const char,T>::value || is_same<const wchar_t,T>::value ||
                                                                   is_same<char,T>::value || is_same<wchar_t,T>::value,
                                                                char_or_wchar_t_array_tag,
                                                                int >::type tag;
            return array_size<T,sz>( boost_range_array, tag() );
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            typedef typename boost::mpl::if_c< is_same<char,T>::value || is_same<wchar_t,T>::value,
                                                                char_or_wchar_t_array_tag,
                                                                int >::type tag;
            return array_size<T,sz>( boost_range_array, tag() );
        }

    }

}
# 26 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/end.hpp" 2 3



namespace boost
{




namespace range_detail
{






        template< typename C >
        inline typename range_const_iterator<C>::type
        boost_range_end( const C& c )
        {
            return c.end();
        }

        template< typename C >
                inline typename range_iterator<
                                        typename remove_const<C>::type >::type
        boost_range_end( C& c )
        {
            return c.end();
        }





        template< typename Iterator >
        inline Iterator boost_range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }

        template< typename Iterator >
        inline Iterator boost_range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }





        template< typename T, std::size_t sz >
        inline const T* boost_range_end( const T (&array)[sz] )
        {
            return range_detail::array_end<T,sz>( array );
        }

        template< typename T, std::size_t sz >
        inline T* boost_range_end( T (&array)[sz] )
        {
            return range_detail::array_end<T,sz>( array );
        }







        inline char* boost_range_end( char* s )
        {
            return range_detail::str_end( s );
        }

        inline wchar_t* boost_range_end( wchar_t* s )
        {
            return range_detail::str_end( s );
        }

        inline const char* boost_range_end( const char* s )
        {
            return range_detail::str_end( s );
        }

        inline const wchar_t* boost_range_end( const wchar_t* s )
        {
            return range_detail::str_end( s );
        }
# 140 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/end.hpp" 3
}


template< class T >
inline typename range_iterator<
                typename remove_const<T>::type >::type end( T& r )
{



    using namespace range_detail;

    return boost_range_end( r );
}

template< class T >
inline typename range_const_iterator<T>::type end( const T& r )
{



    using namespace range_detail;

    return boost_range_end( r );
}
# 184 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/end.hpp" 3
}






namespace boost
{
    template< class T >
    inline typename range_const_iterator<T>::type
    const_end( const T& r )
    {
        return boost::end( r );
    }
}
# 20 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/value_type.hpp" 1 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/range/value_type.hpp" 3
namespace boost
{
        template< class T >
    struct range_value
        {
                typedef typename iterator_value<
                        typename range_iterator<T>::type >::type
                                type;
        };
}
# 21 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/detail/case_conv.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/detail/case_conv.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/functional" 1 3
# 52 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/functional" 3
       
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/functional" 3
# 16 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/detail/case_conv.hpp" 2 3

namespace boost {
    namespace algorithm {
        namespace detail {




            template<typename CharT>
            struct to_lowerF : public std::unary_function<CharT, CharT>
            {

                to_lowerF( const std::locale& Loc ) : m_Loc( Loc ) {}


                CharT operator ()( CharT Ch ) const
                {



                        return std::tolower<CharT>( Ch, m_Loc );

                }
            private:
                const std::locale& m_Loc;
            };


            template<typename CharT>
            struct to_upperF : public std::unary_function<CharT, CharT>
            {

                to_upperF( const std::locale& Loc ) : m_Loc( Loc ) {}


                CharT operator ()( CharT Ch ) const
                {



                        return std::toupper<CharT>( Ch, m_Loc );

                }
            private:
                const std::locale& m_Loc;
            };

        }
    }
}
# 23 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 2 3







namespace boost {
    namespace algorithm {
# 51 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT
        to_lower_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const std::locale& Loc=std::locale())
        {
            return std::transform(
                begin(Input),
                end(Input),
                Output,
                ::boost::algorithm::detail::to_lowerF<
                    typename range_value<RangeT>::type >(Loc));
        }





        template<typename SequenceT>
        inline SequenceT to_lower_copy(
            const SequenceT& Input,
            const std::locale& Loc=std::locale())
        {
            return SequenceT(
                make_transform_iterator(
                    begin(Input),
                    ::boost::algorithm::detail::to_lowerF<
                        typename range_value<SequenceT>::type >(Loc)),
                make_transform_iterator(
                    end(Input),
                    ::boost::algorithm::detail::to_lowerF<
                        typename range_value<SequenceT>::type >(Loc)));
        }
# 94 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename WritableRangeT>
        inline void to_lower(
            WritableRangeT& Input,
            const std::locale& Loc=std::locale())
        {
            std::transform(
                begin(Input),
                end(Input),
                begin(Input),
                ::boost::algorithm::detail::to_lowerF<
                    typename range_value<WritableRangeT>::type >(Loc));
        }
# 124 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT
        to_upper_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const std::locale& Loc=std::locale())
        {
            return std::transform(
                begin(Input),
                end(Input),
                Output,
                ::boost::algorithm::detail::to_upperF<
                    typename range_value<RangeT>::type >(Loc));
        }





        template<typename SequenceT>
        inline SequenceT to_upper_copy(
            const SequenceT& Input,
            const std::locale& Loc=std::locale())
        {
            return SequenceT(
                make_transform_iterator(
                    begin(Input),
                    ::boost::algorithm::detail::to_upperF<
                        typename range_value<SequenceT>::type >(Loc)),
                make_transform_iterator(
                    end(Input),
                    ::boost::algorithm::detail::to_upperF<
                        typename range_value<SequenceT>::type >(Loc)));

        }
# 168 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename WritableRangeT>
        inline void to_upper(
            WritableRangeT& Input,
            const std::locale& Loc=std::locale())
        {
            std::transform(
                begin(Input),
                end(Input),
                begin(Input),
                ::boost::algorithm::detail::to_upperF<
                    typename range_value<WritableRangeT>::type >(Loc));
        }

    }


    using algorithm::to_lower;
    using algorithm::to_lower_copy;
    using algorithm::to_upper;
    using algorithm::to_upper_copy;

}
# 38 "../Source_Files/Network/Metaserver/metaserver_messages.h" 2

using boost::algorithm::to_lower_copy;

enum
{

 kSERVER_ROOMLIST = 0,
 kSERVER_PLAYERLIST = 1,
 kSERVER_GAMELIST = 2,
 kSERVER_DENY = 3,
 kSERVER_SALT = 6,
 kSERVER_LOGINSUCCESS = 7,
 kSERVER_SETPLAYERDATA = 8,
 kSERVER_LIMIT = 9,
 kSERVER_BROADCAST = 10,
 kSERVER_ACCEPT = 12,
 kSERVER_FIND = 14,
 kSERVER_STATS = 17,


 kCLIENT_LOGIN = 100,
 kCLIENT_ROOM_LOGIN = 101,
 kCLIENT_LOGOUT = 102,
 kCLIENT_NAME_TEAM = 103,
 kCLIENT_CREATEGAME = 104,
 kCLIENT_REMOVEGAME = 105,
 kCLIENT_PLAYERMODE = 107,
 kCLIENT_KEY = 109,
 kCLIENT_SYNCGAMES = 110,
        kCLIENT_GAMEPLAYERLIST = 111,
        kCLIENT_GAMESCORE = 112,
 kCLIENT_RESETGAME = 113,
 kCLIENT_STARTGAME = 114,
 kCLIENT_LOCALIZE = 115,
 kCLIENT_FIND = 117,
 kCLIENT_STATS = 121,


 kBOTH_CHAT = 200,
 kBOTH_PRIVATE_MESSAGE = 201,
 kBOTH_KEEP_ALIVE = 202,
};



typedef uint8 HandoffToken[32];

AIStream& operator >>(AIStream& stream, HandoffToken& token);





struct GameDescription
{
 uint16 m_type;
 int32 m_timeLimit;
 uint32 m_mapChecksum;
 uint16 m_difficulty;
 uint16 m_maxPlayers;
 bool m_teamsAllowed;
 bool m_closed;
 bool m_running;
 uint8 m_numPlayers;
 std::string m_name;
 std::string m_mapName;


 std::string m_scenarioID;
 std::string m_networkSetupProtocolID;


 std::string m_scenarioName;
 std::string m_scenarioVersion;
 std::string m_alephoneBuildString;
 std::string m_netScript;


 bool m_hasGameOptions;
 int16 m_gameOptions;
 int16 m_cheatFlags;
 int16 m_killLimit;
 std::string m_mapFileName;
 std::string m_physicsName;

 GameDescription()
  : m_type(0)
  , m_timeLimit(0)
  , m_mapChecksum(0)
  , m_difficulty(0)
  , m_maxPlayers(8)
  , m_teamsAllowed(false)
  , m_closed(false)
  , m_running(false)
  , m_numPlayers(1)
  , m_name("Untitled Game")
  , m_mapName("Unspecified Map")
  , m_scenarioID(Scenario::instance()->GetID())
  , m_networkSetupProtocolID("Aleph One WonderNAT V1")
  , m_scenarioName(Scenario::instance()->GetName())
  , m_scenarioVersion(Scenario::instance()->GetVersion())
  , m_hasGameOptions(false)
  , m_gameOptions(0)
  , m_cheatFlags(0)
  , m_killLimit(0)
 {}

};

AIStream& operator >>(AIStream& stream, GameDescription& desc);
AOStream& operator <<(AOStream& stream, const GameDescription& desc);
std::ostream& operator <<(std::ostream& stream, const GameDescription& desc);



class LoginAndPlayerInfoMessage : public SmallMessageHelper
{
public:
 LoginAndPlayerInfoMessage(const std::string& userName, const std::string& playerName, const std::string& teamName)
  : m_userName(userName), m_playerName(playerName), m_teamName(teamName) {}

 enum { kType = kCLIENT_LOGIN };

 MessageTypeID type() const { return kType; }

 LoginAndPlayerInfoMessage* clone() const
 { return new LoginAndPlayerInfoMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const;

 bool reallyInflateFrom(AIStream& inStream)
 {

  return false;
 }

private:
 std::string m_userName;
 std::string m_playerName;
 std::string m_teamName;
};

typedef DatalessMessage<kCLIENT_LOGOUT> LogoutMessage;

class SetPlayerModeMessage : public SmallMessageHelper
{
public:
 enum { kType = kCLIENT_PLAYERMODE };

 MessageTypeID type() const { return kType; }

 SetPlayerModeMessage* clone() const
  { return new SetPlayerModeMessage(*this); }

 SetPlayerModeMessage(uint16 mode) : m_mode(mode) { }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
  {
   thePacket << m_mode;
  }

 bool reallyInflateFrom(AIStream& inStream)
  { ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 202, __PRETTY_FUNCTION__, "false")); }

private:
 uint16 m_mode;
};

class SaltMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_SALT, kKeyLength = 16 };

 enum { kPlaintextEncryption, kBraindeadSimpleEncryption };

 uint16 encryptionType() const { return m_encryptionType; }
 const uint8* salt() const { return &(m_salt[0]); }

 MessageTypeID type() const { return kType; }

 SaltMessage* clone() const
 { return new SaltMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 227, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 uint16 m_encryptionType;
 uint8 m_salt[kKeyLength];
};



typedef DatalessMessage<kSERVER_ACCEPT> AcceptMessage;



class LocalizationMessage : public SmallMessageHelper
{
public:
 enum { kType = kCLIENT_LOCALIZE };

 MessageTypeID type() const { return kType; }

 LocalizationMessage* clone() const
 { return new LocalizationMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const;

 bool reallyInflateFrom(AIStream& inStream)
 {

  return false;
 }
};



class RoomDescription
{
public:
 enum
 {
  kNormalRoomType = 0,
  kRankedRoomType,
  kTournamentRoomType
 };

 void read(AIStream& inStream);

 const std::string roomName() const;
 int playerCount() const { return m_playerCount; }
 int gameCount() const { return m_gameCount; }
 int roomType() const { return m_type; }
 const IPaddress roomServerAddress() const { return m_address; }

private:
 uint16 m_id;
 uint16 m_playerCount;
 uint16 m_gameCount;
 uint16 m_type;
 IPaddress m_address;
};

std::ostream& operator <<(std::ostream& out, const RoomDescription& roomDesc);

class RoomListMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_ROOMLIST };

 MessageTypeID type() const { return kType; }

 RoomListMessage* clone() const
 { return new RoomListMessage(*this); }

 const std::vector<RoomDescription>& rooms() const { return m_rooms; }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 309, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 std::vector<RoomDescription> m_rooms;
};

std::ostream& operator <<(std::ostream& out, const RoomListMessage& message);



class RoomLoginMessage : public SmallMessageHelper
{
public:
 enum { kType = kCLIENT_ROOM_LOGIN, kKeyLength = 16 };

 MessageTypeID type() const { return kType; }

 RoomLoginMessage* clone() const
 { return new RoomLoginMessage(*this); }

 RoomLoginMessage(const std::string& login, const HandoffToken& token) : m_loginName(login)
 {
  memcpy(m_token, token, sizeof(m_token));
 }

protected:
 void reallyDeflateTo(AOStream& out) const;

 bool reallyInflateFrom(AIStream&)
 {

  return false;
 }

private:
 HandoffToken m_token;
 std::string m_loginName;
};



class NameAndTeamMessage : public SmallMessageHelper
{
public:
 enum { kType = kCLIENT_NAME_TEAM };

 MessageTypeID type() const { return kType; }

 NameAndTeamMessage* clone() const
 { return new NameAndTeamMessage(*this); }

 NameAndTeamMessage(const std::string& name, const std::string& team) : m_name(name), m_team(team), m_away(false), m_away_message("") {}

 NameAndTeamMessage(const std::string& name, const std::string& team, bool away, const std::string& away_message) : m_name(name), m_team(team), m_away(away), m_away_message(away_message) { }

protected:
 void reallyDeflateTo(AOStream& out) const;

 bool reallyInflateFrom(AIStream&)
 {

  return false;
 }

private:
 std::string m_name;
 std::string m_team;

 bool m_away;
 std::string m_away_message;
};

class IDAndLimitMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_LIMIT };

 uint32 playerID() const { return m_playerID; }
 uint16 playerLimit() const { return m_playerLimit; }

 MessageTypeID type() const { return kType; }

 IDAndLimitMessage* clone() const
 { return new IDAndLimitMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 401, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 uint32 m_playerID;
 uint16 m_playerLimit;
};



class DenialMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_DENY };

 MessageTypeID type() const { return kType; }

 uint32 code() const { return m_code; }
 const std::string message() const { return m_message; }

 DenialMessage* clone() const
 { return new DenialMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 430, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 uint32 m_code;
 std::string m_message;
};



class BroadcastMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_BROADCAST };

 MessageTypeID type() const { return kType; }

 const std::string message() const { return m_message; }

 BroadcastMessage* clone() const
 { return new BroadcastMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 458, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 std::string m_message;
};

class PrivateMessage : public SmallMessageHelper
{
public:
 enum { kType = kBOTH_PRIVATE_MESSAGE };
 static const int kDirectedBit = 0x1;

 MessageTypeID type() const { return kType; }

 PrivateMessage() {}

 PrivateMessage(uint32 inSenderID, const std::string& inSenderName, uint32 inSelectedID, const std::string& inMessage);

 const uint32 senderID() const { return m_senderID; }
 const uint32 selectedID() const { return m_selectedID; }
 const uint16 internalType() const { return m_internalType; }
 const std::string senderName() const { return m_senderName; }
 const std::string message() const { return m_message; }
 const bool directed() const { return m_flags & kDirectedBit; }

 PrivateMessage* clone() const
  { return new PrivateMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const;
 bool reallyInflateFrom(AIStream& inStream);

private:
 uint16 m_color[3];
 uint32 m_senderID;
 uint32 m_selectedID;
 uint16 m_internalType;
 uint16 m_flags;
 std::string m_senderName;
 std::string m_message;
};


class ChatMessage : public SmallMessageHelper
{
public:
 enum { kType = kBOTH_CHAT };

 static const int kDirectedBit = 0x1;

 MessageTypeID type() const { return kType; }

 ChatMessage() {}

 ChatMessage(uint32 inSenderID, const std::string& inSenderName, const std::string& inMessage);

 const uint32 senderID() const { return m_senderID; }
 const uint16 internalType() const { return m_internalType; }
 const std::string senderName() const { return m_senderName; }
 const std::string message() const { return m_message; }
 const bool directed() const { return m_flags & kDirectedBit; }

 ChatMessage* clone() const
 { return new ChatMessage(*this); }

protected:
 void reallyDeflateTo(AOStream& thePacket) const;
 bool reallyInflateFrom(AIStream& inStream);

private:
 uint16 m_color[3];
 uint32 m_senderID;
 uint16 m_internalType;
 uint16 m_flags;
 std::string m_senderName;
 std::string m_message;
};



typedef DatalessMessage<kBOTH_KEEP_ALIVE> KeepAliveMessage;



class MetaserverPlayerInfo
{
public:

 static const uint16 kNotAdmin = 0x0;
 static const uint16 kBungie = 0x1;
 static const uint16 kAdmin = 0x4;

 MetaserverPlayerInfo(AIStream& fromStream);

 uint16 verb() const { return m_verb; }
 uint32 playerID() const { return m_playerID; }
 const std::string& name() const { return m_name; }

 const uint16 *color() const { return m_primaryColor; }
 const uint16 *team_color() const { return m_secondaryColor; }

 static bool sort(const MetaserverPlayerInfo& a, const MetaserverPlayerInfo& b) {
  return (a.m_adminFlags == b.m_adminFlags) ? ( (a.m_status == b.m_status) ? a.playerID() < b.playerID() : a.m_status < b.m_status) : a.m_adminFlags > b.m_adminFlags;
 }

 friend std::ostream& operator <<(std::ostream& out, const MetaserverPlayerInfo& info);

 bool away() const { return m_status & 0x1; }


 typedef uint32 IDType;
 static const IDType IdNone = 0xffffffff;

 IDType id() const { return playerID(); }

 bool target() const { return m_target; }
 void target(bool _target) { m_target = _target; }

private:
 MetaserverPlayerInfo();

 uint16 m_verb;
 uint16 m_adminFlags;
 uint32 m_ranking;
 uint32 m_playerID;
 uint32 m_roomID;
 uint16 m_rank;
 uint16 m_playerDataSize;
 uint8 m_icon;
 uint8 m_status;
 uint16 m_primaryColor[3];
 uint16 m_secondaryColor[3];
 std::string m_name;
 std::string m_team;

 bool m_target;
};

class PlayerListMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_PLAYERLIST };

 MessageTypeID type() const { return kType; }

 PlayerListMessage() {}

 PlayerListMessage* clone() const
 { return new PlayerListMessage(*this); }

 const std::vector<MetaserverPlayerInfo>& players() const { return m_players; }


protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 618, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 std::vector<MetaserverPlayerInfo> m_players;
};

std::ostream& operator <<(std::ostream& out, const PlayerListMessage& info);



class CreateGameMessage : public SmallMessageHelper
{
public:
 enum { kType = kCLIENT_CREATEGAME };

 MessageTypeID type() const { return kType; }

 CreateGameMessage(uint16 gamePort, const GameDescription& description)
  : m_gamePort(gamePort)
  , m_description(description)
 {}

 CreateGameMessage* clone() const
 { return new CreateGameMessage(*this); }


protected:
 void reallyDeflateTo(AOStream& thePacket) const;

 bool reallyInflateFrom(AIStream& inStream)
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 653, __PRETTY_FUNCTION__, "false"));
  return false;
 }


private:
 uint16 m_gamePort;
 GameDescription m_description;
};



typedef DatalessMessage<kCLIENT_SYNCGAMES> SyncGamesMessage;



class LoginSuccessfulMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_LOGINSUCCESS };

 MessageTypeID type() const { return kType; }

 LoginSuccessfulMessage* clone() const
 { return new LoginSuccessfulMessage(*this); }

 uint32 userID() const { return m_userID; }
 const HandoffToken& token() const { return m_token; }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 686, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 uint32 m_userID;
 uint16 m_order;
 HandoffToken m_token;
};



class SetPlayerDataMessage : public SmallMessageHelper
{
public:
 enum { kType = kSERVER_SETPLAYERDATA };

 MessageTypeID type() const { return kType; }

 SetPlayerDataMessage* clone() const
 { return new SetPlayerDataMessage(*this); }


protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 714, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
};



class GameListMessage : public SmallMessageHelper
{
public:
 struct GameListEntry
 {

  typedef uint32 IDType;
  static const IDType IdNone = 0xffffffff;
  IDType id() const { return m_gameID; }
  uint8 verb() const { return m_verb; }

  bool target() const { return m_target; }
  void target(bool _target) { m_target = _target; }

  bool running() const { return m_description.m_running; }
  bool compatible() const { return Scenario::instance()->IsCompatible(m_description.m_scenarioID); }

  static bool sort(const GameListEntry& a, const GameListEntry& b) {



   if (a.compatible() && b.compatible())
   {
    if (a.running() == b.running())
    {
     return a.id() < b.id();
    }
    else
    {
     return !a.running();
    }
   }
   else if (a.compatible() == b.compatible())
   {
    return a.id() < b.id();
   }
   else
    return a.compatible();
  }

  int minutes_remaining() const {
   if (m_timeRemaining == -1) return -1;
   int remaining = m_timeRemaining / 60 - (SDL_GetTicks() - m_ticks) / 1000 / 60;
   if (remaining < 0) remaining = 0;
   return remaining;
  }

  std::string format_for_chat(const std::string& player_name) const;
  std::string game_string() const;


  const std::string& name() const { return m_description.m_name; }

  uint32 m_gameID;
  uint8 m_ipAddress[4];
  uint16 m_port;
  uint8 m_verb;
  uint8 m_gameEnable;
  uint32 m_timeRemaining;
  uint32 m_hostPlayerID;
  uint16 m_len;
  GameDescription m_description;

  uint32 m_ticks;
  std::string m_hostPlayerName;

 GameListEntry() : m_target(false) { }
  bool m_target;
 };

 enum { kType = kSERVER_GAMELIST };

 MessageTypeID type() const { return kType; }

 GameListMessage* clone() const
 { return new GameListMessage(*this); }

 const std::vector<GameListEntry>& entries() const { return m_entries; }

protected:
 void reallyDeflateTo(AOStream& thePacket) const
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 807, __PRETTY_FUNCTION__, "false"));
 }

 bool reallyInflateFrom(AIStream& inStream);

private:
 std::vector<GameListEntry> m_entries;
};

AIStream& operator >>(AIStream& stream, GameListMessage::GameListEntry& entry);
std::ostream& operator <<(std::ostream& stream, const GameListMessage::GameListEntry& entry);



typedef DatalessMessage<kCLIENT_RESETGAME> ResetGameMessage;
typedef DatalessMessage<kCLIENT_REMOVEGAME> RemoveGameMessage;



class StartGameMessage : public SmallMessageHelper
{
public:
 enum { kType = kCLIENT_STARTGAME };

 MessageTypeID type() const { return kType; }

 StartGameMessage* clone() const
 { return new StartGameMessage(*this); }

 StartGameMessage(int32 gameTimeInSeconds) : m_gameTimeInSeconds(gameTimeInSeconds) {}

protected:
 void reallyDeflateTo(AOStream& thePacket) const;

 bool reallyInflateFrom(AIStream& inStream)
 {

  ((false) ? (void)0 : __assert_func ("../Source_Files/Network/Metaserver/metaserver_messages.h", 844, __PRETTY_FUNCTION__, "false"));
  return false;
 }

private:
 int32 m_gameTimeInSeconds;
};
# 62 "../Source_Files/Misc/sdl_widgets.h" 2


# 1 "../Source_Files/Misc/binders.h" 1
# 26 "../Source_Files/Misc/binders.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/list" 1 3
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/list" 3
       
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/list" 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 1 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {

      _Tp _M_data;
    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 291 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }
# 357 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 415 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;







      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }
# 492 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(__a) { }
# 517 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 530 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 556 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 581 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 612 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 628 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 757 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 781 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 837 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 859 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 874 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 895 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 928 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 960 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 980 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 1004 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 1025 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 1042 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void



      swap(list& __x)

      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1082 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x)

      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 1106 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x, iterator __i)

      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 1136 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void




      splice(iterator __position, list& __x, iterator __first,
      iterator __last)

      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 1165 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1179 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1193 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      unique();
# 1208 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1221 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void



      merge(list& __x);
# 1240 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void



        merge(list&, _StrictWeakOrdering);







      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }
# 1314 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }



      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }
# 1355 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        _M_get_Tp_allocator().destroy(&__n->_M_data);
        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1384 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1413 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
# 1461 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_list.h" 3
}
# 69 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/list" 2 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/list.tcc" 1 3
# 65 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   _M_get_Tp_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
    }
# 96 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (&*__first != &__value)
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::



    merge(list& __x)

    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::



      merge(list& __x, _StrictWeakOrdering __comp)

      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }

}
# 72 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/list" 2 3
# 27 "../Source_Files/Misc/binders.h" 2


template<typename T>
class Bindable
{
public:
 virtual T bind_export () = 0;
 virtual void bind_import (T) = 0;

 virtual ~Bindable () {}
};

class ABinder
{
public:
 virtual void migrate_first_to_second () = 0;
 virtual void migrate_second_to_first () = 0;

 virtual ~ABinder () {}
};

template<typename T>
class Binder : public ABinder
{
public:
 Binder (Bindable<T>* t1, Bindable<T>* t2)
  : thing1 (t1)
  , thing2 (t2)
  {}

 void migrate_first_to_second () { thing2->bind_import (thing1->bind_export ()); }
 void migrate_second_to_first () { thing1->bind_import (thing2->bind_export ()); }

private:
 Bindable<T>* thing1;
 Bindable<T>* thing2;
};

class BinderSet
{
public:
 BinderSet () {}
 ~BinderSet () { for_each (m_list.begin (), m_list.end (), delete_it); }

 template<typename T>
 void insert (Bindable<T>* first, Bindable<T>* second)
 { if (first && second) m_list.push_back (new Binder<T> (first, second)); }

 void migrate_all_first_to_second () { for_each (m_list.begin (), m_list.end (), call_first_second); }
 void migrate_all_second_to_first () { for_each (m_list.begin (), m_list.end (), call_second_first); }

private:
 std::list<ABinder*> m_list;

 static void call_first_second (ABinder* b) { b->migrate_first_to_second (); }
 static void call_second_first (ABinder* b) { b->migrate_second_to_first (); }
 static void delete_it (ABinder* b) { delete b; }
};
# 65 "../Source_Files/Misc/sdl_widgets.h" 2

struct SDL_Surface;


typedef boost::function<void (void)> ControlHitCallback;
typedef boost::function<void (char)> GotCharacterCallback;




class w_label;

class widget : public placeable{
 friend class dialog;

public:
    enum alignment {
            kAlignNatural,
            kAlignLeft,
            kAlignCenter,
            kAlignRight
    };


 widget();
        widget(int theme_widget);
 virtual ~widget() {}


 virtual void draw(SDL_Surface *s) const = 0;


    void set_enabled(bool inEnabled);


 virtual void mouse_move(int , int ) {}
 virtual void mouse_down(int x, int y) { click(x, y); }
 virtual void mouse_up(int , int ) {}
 virtual void click(int , int ) {}
 virtual void event(SDL_Event & ) {}


 virtual bool is_selectable(void) const {return enabled; }


        short get_identifier() const {return identifier;}
        void set_identifier(short id) {identifier = id;}


        dialog* get_owning_dialog() { return owning_dialog; }


 virtual void set_rect(const SDL_Rect &r) { rect = r; }


 void place(const SDL_Rect &r, placement_flags flags);
 int min_height() { return saved_min_height; }
 int min_width() { return saved_min_width; }

 virtual bool is_dirty() { return dirty; }




 w_label *label(const char *);
 void associate_label(w_label *label);

protected:

        void set_owning_dialog(dialog* new_owner) { owning_dialog = new_owner; }

 SDL_Rect rect;

 bool active;
 bool dirty;
    bool enabled;

 font_info *font;
 uint16 style;

        short identifier;
        dialog* owning_dialog;

 int saved_min_width;
 int saved_min_height;

 w_label* associated_label;
};






class w_spacer : public placeable {
public:
 w_spacer(uint16 space = get_theme_space(SPACER_WIDGET)) : m_space(space) { }

 int min_height() { return m_space; }
 int min_width() { return m_space; }
 void place(const SDL_Rect&, placement_flags) { }

private:
 uint16 m_space;
};
# 178 "../Source_Files/Misc/sdl_widgets.h"
class w_static_text : public widget {
public:
 w_static_text(const char *text, int theme_type = MESSAGE_WIDGET);

 void draw(SDL_Surface *s) const;


        void set_text(const char* t);

 bool is_selectable(void) const {return false;}

        ~w_static_text();

protected:
 char *text;
private:
 int theme_type;
};

class w_label : public w_static_text {
 friend class dialog;
public:
 w_label(const char *text) : w_static_text(text, LABEL_WIDGET), associated_widget(0) {}

 void associate_widget(widget *w) { associated_widget = w; }
 void draw(SDL_Surface *s) const;
 void click(int, int);
 bool is_selectable(void) const { if (associated_widget) return associated_widget->is_selectable(); else return false; }
private:
 widget *associated_widget;
};

class w_title : public w_static_text {
public:
 w_title(const char *text) : w_static_text(text, TITLE_WIDGET) {}
};





class w_pict : public widget {
public:
 w_pict(int id);
 ~w_pict();

 void draw(SDL_Surface *s) const;
 bool is_selectable(void) const {return false;}

private:
 SDL_Surface *picture;
};







typedef boost::function<void (void*)> action_proc;

class w_button_base : public widget {
public:
 w_button_base(const char *text, action_proc proc = __null, void *arg = __null, int type = BUTTON_WIDGET);
 virtual ~w_button_base();

 void set_callback (action_proc proc, void *arg);

 void draw(SDL_Surface *s) const;
 void mouse_move(int x, int y);
 void mouse_down(int x, int y);
 void mouse_up(int x, int y);
 void click(int x, int y);

protected:
 const std::string text;
 action_proc proc;
 void *arg;

 bool down, pressed;

 int type;

 SDL_Surface *button_c_default;
 SDL_Surface *button_c_active;
 SDL_Surface *button_c_disabled;
 SDL_Surface *button_c_pressed;
};


class w_button : public w_button_base {
public:
 w_button(const char *text, action_proc proc = __null, void *arg = __null) : w_button_base(text, proc, arg, BUTTON_WIDGET) {}
};

class w_tiny_button : public w_button_base {
public:
 w_tiny_button(const char *text, action_proc proc = __null, void *arg = __null) : w_button_base(text, proc, arg, TINY_BUTTON) {}
};





class w_tab : public widget {
public:
 w_tab(const vector<string>& labels, tab_placer *placer);
 ~w_tab();
 void draw(SDL_Surface *s) const;
 void click(int x, int y);
 void event(SDL_Event& e);

 void choose_tab(int i);
private:
 vector<string> labels;
 vector<int> widths;
 tab_placer *placer;

 vector<vector<SDL_Surface *> > images;

 int pressed_tab;
 int active_tab;
};





class w_select_button : public widget {
public:
 w_select_button(const char *selection, action_proc proc = __null, void *arg = __null, bool utf8 = false);

 void draw(SDL_Surface *s) const;
 void click(int x, int y);

 void set_selection(const char *selection);
 void set_callback(action_proc p, void* a) { proc = p; arg = a; }

 void place(const SDL_Rect& r, placement_flags flags = placeable::kDefault);

protected:
 void set_arg(void *arg) { this->arg = arg; }
 placement_flags p_flags;
private:
 const char *selection;
 action_proc proc;
 void *arg;

 int16 selection_x;
 bool utf8;
};







class w_select;

typedef boost::function<void (w_select*)> selection_changed_callback_t;

class w_select : public widget {
public:
 w_select(size_t selection, const char **labels);
 virtual ~w_select();

 void draw(SDL_Surface *s) const;
 void click(int x, int y);
 void event(SDL_Event &e);

 void place(const SDL_Rect& r, placement_flags flags = placeable::kDefault);
 int min_width();

 size_t get_selection(void) const {return (num_labels > 0 ? selection : UNONE);}
 void set_selection(size_t selection, bool simulate_user_input = false);






 void set_labels(const char** inLabels);




 void set_labels_stringset(short inStringSetID);



 void set_selection_changed_callback(selection_changed_callback_t proc) { selection_changed_callback = proc; }

 void labels_are_utf8(bool _utf8) { utf8 = _utf8; }

protected:
 virtual void selection_changed(void);

 const char **labels;
 size_t num_labels;
 bool we_own_labels;




 size_t selection;


 selection_changed_callback_t selection_changed_callback;


 uint16 get_largest_label_width();

 bool utf8;
};






class w_toggle : public w_select {
public:
 static const char *onoff_labels[3];

 w_toggle(bool selection, const char **labels = onoff_labels);
 int min_width();
 void draw(SDL_Surface *) const;
};
# 415 "../Source_Files/Misc/sdl_widgets.h"
class w_enabling_toggle : public w_toggle
{
public:
 w_enabling_toggle(bool inSelection, bool inEnablesWhenOn = true, const char** inLabels = onoff_labels);
 void add_dependent_widget(widget* inWidget) { dependents.insert(inWidget); update_widget_enabled(inWidget); }
 void remove_dependent_widget(widget* inWidget) { dependents.erase(inWidget); }

protected:
 void selection_changed();

private:
 void update_widget_enabled(widget* inWidget)
 {
  inWidget->set_enabled(selection == enables_when_on);
 }

 typedef std::set<widget*> DependentCollection;

 DependentCollection dependents;
 bool enables_when_on;
};






class w_player_color : public w_select {
public:
 w_player_color(int selection);

 void draw(SDL_Surface *s) const;
};





class w_text_entry : public widget {
public:
 typedef boost::function<void (w_text_entry*)> Callback;

 w_text_entry(size_t max_chars, const char *initial_text = __null);
 ~w_text_entry();

 void draw(SDL_Surface *s) const;
 void event(SDL_Event &e);
 void click(int, int) { get_owning_dialog()->activate_widget(this, true); }

 void set_text(const char *text);
 const char *get_text(void) {return buf;}


        void set_enter_pressed_callback(Callback func) { enter_pressed_callback = func; }



        void set_value_changed_callback(Callback func) { value_changed_callback = func; }

 void enable_mac_roman_input(bool enable = true) { enable_mac_roman = enable; }
 void place(const SDL_Rect& r, placement_flags flags);


protected:
 char *buf;

        Callback enter_pressed_callback;
        Callback value_changed_callback;

private:
 void modified_text(void);

 size_t num_chars;
 size_t max_chars;
 int16 text_x;
 uint16 max_text_width;

 bool enable_mac_roman;
};

class w_chat_entry : public w_text_entry {
public:
 w_chat_entry(size_t max_c) : w_text_entry(max_c, "") {
  font = get_theme_font(CHAT_ENTRY, style);
  saved_min_height = (int16) font->get_ascent() + font->get_descent() + font->get_leading();
 }
};




class w_number_entry : public w_text_entry {
public:
 w_number_entry(int initial_number = 0);

 void event(SDL_Event &e);

 void set_number(int number);
 int get_number(void) {return atoi(get_text());}
};





class w_password_entry : public w_text_entry {
public:
 w_password_entry(size_t max_chars, const char *initial_text = 0);

 void draw(SDL_Surface *s) const;
};





class w_key : public widget {
public:
 w_key(SDLKey key);

 void draw(SDL_Surface *s) const;
 void click(int x, int y);
 void event(SDL_Event &e);

 virtual void set_key(SDLKey key);
 SDLKey get_key(void) {return key;}
 void place(const SDL_Rect& r, placement_flags flags);


private:
 const char *name;

 int16 key_x;

 SDLKey key;
 bool binding;
};






class w_progress_bar : public widget {
public:
w_progress_bar(int inWidth) : widget(), max_value(10), value(0) {
  rect.w = inWidth;
  rect.h = 14;

  saved_min_width = rect.w;
  saved_min_height = rect.h;
        }

        ~w_progress_bar() {}

        void draw(SDL_Surface* s) const;

        bool is_selectable() { return false; }

        void set_progress(int inValue, int inMaxValue);

protected:
        int max_value;
        int value;
};







class w_slider : public widget {
public:
 w_slider(int num_items, int sel);
 ~w_slider();

 void draw(SDL_Surface *s) const;
 void mouse_move(int x, int y);
 void click(int x, int y);
 void event(SDL_Event &e);

 int get_selection(void) {return selection;}
 void set_selection(int selection);

 virtual void item_selected(void) {}

 void place(const SDL_Rect& r, placement_flags flags);

protected:
 int16 slider_x;

 int selection;
 int num_items;

 bool thumb_dragging;
 int thumb_x;
 int trough_width;

 int thumb_drag_x;

 SDL_Surface *slider_l, *slider_c, *slider_r, *thumb;
private:
 int thumb_width() const;
};

class w_color_picker : public widget {
public:
 w_color_picker(rgb_color &color) : widget(MESSAGE_WIDGET), m_color(color) {
  saved_min_width = 48;
  saved_min_height = font->get_line_height();
 }

 const rgb_color& get_selection() { return m_color; }

 void draw(SDL_Surface *s) const;
 void click(int, int);

private:
 rgb_color m_color;

 struct update_color {
  update_color(w_slider *red, w_slider *green, w_slider *blue, uint16 *i_red, uint16 *i_green, uint16 *i_blue) : red_w(red), green_w(green), blue_w(blue), red(i_red), blue(i_blue), green(i_green) { }
  void operator()(dialog *) {
   *red = red_w->get_selection() << 12;
   *green = green_w->get_selection() << 12;
   *blue = blue_w->get_selection() << 12;
  }

  w_slider *red_w;
  w_slider *green_w;
  w_slider *blue_w;

  uint16* red;
  uint16* blue;
  uint16* green;
 };
};






class w_list_base : public widget {
public:
 w_list_base(uint16 width, size_t lines, size_t sel);
 ~w_list_base();

 void draw(SDL_Surface *s) const;
 void mouse_move(int x, int y);
 void click(int x, int y);
 void event(SDL_Event &e);

 size_t get_selection(void) {return selection;}

 virtual bool is_item_selectable(size_t ) {return true;}
 virtual void item_selected(void) = 0;

 void place(const SDL_Rect& r, placement_flags flags);

protected:
 virtual void draw_items(SDL_Surface *s) const = 0;
 void draw_image(SDL_Surface *dst, SDL_Surface *s, int16 x, int16 y) const;
 void set_selection(size_t s);
 void new_items(void);
 void center_item(size_t i);
 void set_top_item(size_t i);
 virtual uint16 item_height() const { return font->get_line_height(); }

 size_t selection;

 size_t num_items;
 size_t shown_items;
 size_t top_item;

 bool thumb_dragging;
 SDL_Rect trough_rect;
 uint16 thumb_height;
 uint16 min_thumb_height;
 int16 thumb_y;

 int thumb_drag_y;

 SDL_Surface *frame_tl, *frame_t, *frame_tr, *frame_l, *frame_r, *frame_bl, *frame_b, *frame_br;
 SDL_Surface *thumb_t, *thumb_tc, *thumb_c, *thumb_bc, *thumb_b;
};

template <class T>
class w_list : public w_list_base {
public:
 w_list(const vector<T> &it, uint16 width, size_t lines, size_t sel) : w_list_base(width, lines, sel), items(it)
 {
  num_items = items.size();
  new_items();
  set_selection(sel);
  center_item(selection);
 }

 uint16 item_height() const { return font->get_line_height(); }

 ~w_list() {}

protected:
 void draw_items(SDL_Surface *s) const
 {
  typename vector<T>::const_iterator i = items.begin() + top_item;
  int16 x = rect.x + get_theme_space(LIST_WIDGET, L_SPACE);
  int16 y = rect.y + get_theme_space(LIST_WIDGET, T_SPACE);
  uint16 width = rect.w - get_theme_space(LIST_WIDGET, L_SPACE) - get_theme_space(LIST_WIDGET, R_SPACE);
  for (size_t n=top_item; n<top_item + ((shown_items)<=(num_items) ? (shown_items) : (num_items)); n++, i++, y=y+item_height())
   draw_item(i, s, x, y, width, n == selection && active);
 }

 const vector<T> &items;

private:
 virtual void draw_item(typename vector<T>::const_iterator i, SDL_Surface *s, int16 x, int16 y, uint16 width, bool selected) const = 0;

 w_list(const w_list<T>&);
 w_list<T>& operator =(const w_list<T>&);
};
# 746 "../Source_Files/Misc/sdl_widgets.h"
class w_levels : public w_list<entry_point> {
public:
 w_levels(const vector<entry_point> &items, dialog *d);
 w_levels(const vector<entry_point>& items, dialog* d, uint16 inWidth,
 size_t inNumLines, size_t inSelectedItem, bool in_show_level_numbers);

 void item_selected(void);

 void draw_item(vector<entry_point>::const_iterator i, SDL_Surface *s, int16 x, int16 y, uint16 width, bool selected) const;

private:
 dialog *parent;
 bool show_level_numbers;
};






class w_string_list : public w_list<string> {
public:
 w_string_list(const vector<string> &items, dialog *d, int sel);

 void item_selected(void);

 void draw_item(vector<string>::const_iterator i, SDL_Surface *s, int16 x, int16 y, uint16 width, bool selected) const;

private:
 dialog *parent;
};






class w_select_popup : public w_select_button {
public:
 w_select_popup (action_proc p = __null, void *a = __null);

 void set_labels (const vector<string>& inLabels);
 void set_selection (int value);
 int get_selection () {return selection;}


 void set_popup_callback (action_proc p, void* a) {action = p; arg = a;}

private:
 int selection;
 vector<string> labels;

 action_proc action;
 void* arg;

 static void gotSelectedCallback (void* arg) {reinterpret_cast<w_select_popup*>(arg)->gotSelected();}
 void gotSelected ();
};






class w_file_chooser : public w_select_button
{
public:
 w_file_chooser(const char* inDialogPrompt, Typecode inTypecode);

 void click(int x, int y);

 void set_file(const FileSpecifier& inFile);
 const FileSpecifier& get_file() { return file; }



 void set_callback (ControlHitCallback callback) { m_callback = callback; }

private:
 void update_filename();

 FileSpecifier file;
 char filename[256];
 char dialog_prompt[256];
 Typecode typecode;
 ControlHitCallback m_callback;
};






extern void set_drawing_clip_rectangle(short top, short left, short bottom, short right);

const string w_items_in_room_get_name_of_item (GameListMessage::GameListEntry item);
const string w_items_in_room_get_name_of_item (prospective_joiner_info item);
const string w_items_in_room_get_name_of_item (MetaserverPlayerInfo item);

template <typename tElement>
class w_items_in_room : public w_list_base
{
public:
 typedef typename boost::function<void (const tElement& item)> ItemClickedCallback;
 typedef typename std::vector<tElement> ElementVector;

 w_items_in_room(ItemClickedCallback itemClicked, int width, int numRows) :
  w_list_base(width, numRows, 0),
  m_itemClicked(itemClicked)
 {
  num_items = 0;
  new_items();
 }

 void set_collection(const std::vector<tElement>& elements) {
  m_items = elements;
  num_items = m_items.size();
  new_items();


  get_owning_dialog ()->draw_dirty_widgets ();
 }

 void set_item_clicked_callback (ItemClickedCallback itemClicked) { m_itemClicked = itemClicked; }

 void item_selected() {
  if(m_itemClicked)
   m_itemClicked(m_items[selection]);
 }

 uint16 item_height() const { return font->get_line_height(); }

protected:
 void draw_items(SDL_Surface* s) const {
  typename ElementVector::const_iterator i = m_items.begin();
  int16 x = rect.x + get_theme_space(LIST_WIDGET, L_SPACE);
  int16 y = rect.y + get_theme_space(LIST_WIDGET, T_SPACE);
  uint16 width = rect.w - get_theme_space(LIST_WIDGET, L_SPACE) - get_theme_space(LIST_WIDGET, R_SPACE);

  for(size_t n = 0; n < top_item; n++)
   ++i;

  for (size_t n=top_item; n<top_item + ((shown_items)<=(num_items) ? (shown_items) : (num_items)); n++, ++i, y=y+item_height())
   draw_item(*i, s, x, y, width, n == selection && active);
 }

private:
 ElementVector m_items;
 ItemClickedCallback m_itemClicked;


 virtual void draw_item(const tElement& item, SDL_Surface* s,
   int16 x, int16 y, uint16 width, bool selected) const {
  y += font->get_ascent();
  set_drawing_clip_rectangle(0, x, static_cast<short>(s->h), x + width);
  draw_text(s, w_items_in_room_get_name_of_item(item).c_str(), x, y, selected ? get_theme_color(ITEM_WIDGET, ACTIVE_STATE) : get_theme_color(ITEM_WIDGET, DEFAULT_STATE), font, style);
  set_drawing_clip_rectangle((-32767 - 1), (-32767 - 1), 32767, 32767);
 }

 w_items_in_room(const w_items_in_room<tElement>&);
 w_items_in_room<tElement>& operator =(const w_items_in_room<tElement>&);
};


typedef w_items_in_room<prospective_joiner_info> w_joining_players_in_room;

class w_games_in_room : public w_items_in_room<GameListMessage::GameListEntry>
{
public:
 w_games_in_room(w_items_in_room<GameListMessage::GameListEntry>::ItemClickedCallback itemClicked, int width, int numRows)
  : w_items_in_room<GameListMessage::GameListEntry>(itemClicked, width, numRows), kGameSpacing(get_theme_space(METASERVER_GAMES, GAME_SPACING))
  { font = get_theme_font(METASERVER_GAMES, style); saved_min_height = item_height() * static_cast<uint16>(shown_items) + get_theme_space(LIST_WIDGET, T_SPACE) + get_theme_space(LIST_WIDGET, B_SPACE); }

 uint16 item_height() const { return 3 * font->get_line_height() + 2 + kGameSpacing; }

 void refresh() {
  dirty = true;
  get_owning_dialog()->draw_dirty_widgets();
 }

 enum {
  GAME_ENTRIES,
  GAME_SPACING,
 };

 enum {
  GAME,
  RUNNING_GAME,
  INCOMPATIBLE_GAME,
  SELECTED_GAME,
  SELECTED_RUNNING_GAME,
  SELECTED_INCOMPATIBLE_GAME,
 };
private:
 const int kGameSpacing;
 void draw_item(const GameListMessage::GameListEntry& item, SDL_Surface* s, int16 x, int16 y, uint16 width, bool selected) const;
};

class w_players_in_room : public w_items_in_room<MetaserverPlayerInfo>
{
public:
 w_players_in_room(w_items_in_room<MetaserverPlayerInfo>::ItemClickedCallback itemClicked, int width, int numRows)
 : w_items_in_room<MetaserverPlayerInfo>(itemClicked, width, numRows)
 {
  font = get_theme_font(METASERVER_PLAYERS, style);
  saved_min_height = item_height() * static_cast<uint16>(shown_items) + get_theme_space(LIST_WIDGET, T_SPACE) + get_theme_space(LIST_WIDGET, B_SPACE);
 }

protected:
 uint16 item_height() const { return font->get_line_height() + 4; }
private:
 static const int kPlayerColorSwatchWidth = 8;
 static const int kTeamColorSwatchWidth = 4;
 static const int kSwatchGutter = 2;

 void draw_item(const MetaserverPlayerInfo& item, SDL_Surface* s,
  int16 x, int16 y, uint16 width, bool selected) const;
};



struct ColoredChatEntry
{
 enum Type {
  ChatMessage,
  PrivateMessage,
  ServerMessage,
  LocalMessage
 } type;



 rgb_color color;
 std::string sender;

 std::string message;

 ColoredChatEntry() : type(ChatMessage) { color.red = color.blue = color.green = 0x7fff; }
};

class w_colorful_chat : public w_list<ColoredChatEntry>
{
private:
 vector<ColoredChatEntry> entries;
public:
 w_colorful_chat(int width, int numRows) :
  w_list<ColoredChatEntry>(entries, width, numRows, 0),
  kNameWidth(get_theme_space(CHAT_ENTRY) - taper_width())
  { num_items = 0; font = get_theme_font(CHAT_ENTRY, style); saved_min_height = item_height() * static_cast<uint16>(shown_items) + get_theme_space(LIST_WIDGET, T_SPACE) + get_theme_space(LIST_WIDGET, B_SPACE); }

 virtual bool is_selectable(void) const { return true; }

 void item_selected() {}

 void append_entry(const ColoredChatEntry&);

 void clear() { entries.clear(); num_items = 0; new_items(); }

 ~w_colorful_chat() {}

 uint16 item_height() const { return font->get_line_height() + 2; }

private:
 const int kNameWidth;

 uint16 taper_width() const { return (font->get_line_height() + 1) / 2 - 1; }

 void draw_item(vector<ColoredChatEntry>::const_iterator i, SDL_Surface *s, int16 x, int16 y, uint16 width, bool selected) const;
};





class SDLWidgetWidget
{
public:
 void hide ();
 void show ();

 void activate ();
 void deactivate ();

protected:
 SDLWidgetWidget (widget* in_widget)
  : m_widget (in_widget)
  , hidden (false)
  , inactive (false)
  {}

 widget* m_widget;

private:
 bool hidden, inactive;
};

class ColorfulChatWidgetImpl : public SDLWidgetWidget
{
public:
 ColorfulChatWidgetImpl(w_colorful_chat* w)
  : SDLWidgetWidget(w), m_chat(w) { }

 void Append(const ColoredChatEntry& e) { m_chat->append_entry(e); }
 void Clear () { m_chat->clear (); }

private:
 w_colorful_chat *m_chat;
};


class ToggleWidget : public SDLWidgetWidget, public Bindable<bool>
{
public:
 ToggleWidget (w_toggle* toggle)
  : SDLWidgetWidget (toggle)
  , m_toggle (toggle)
  , m_callback (__null)
  { m_toggle->set_selection_changed_callback (boost::bind(&ToggleWidget::massage_callback, this, _1)); }

 void set_callback (ControlHitCallback callback) { m_callback = callback; }

 bool get_value () { return m_toggle->get_selection (); }
 void set_value (bool value) { m_toggle->set_selection (value); }

 bool bind_export () { return get_value (); }
 void bind_import (bool value) { set_value (value); }

private:
 void massage_callback (w_select* ignored)
  { if (m_callback) m_callback (); }

 w_toggle* m_toggle;
 ControlHitCallback m_callback;
};

class SelectorWidget : public SDLWidgetWidget, public Bindable<int>
{
public:
 virtual void set_callback (ControlHitCallback callback) { m_callback = callback; }

 virtual void set_labels (int stringset) { set_labels (build_stringvector_from_stringset (stringset)); }
 virtual void set_labels (const std::vector<std::string>& labels) = 0;

 virtual int get_value () = 0;
 virtual void set_value (int value) = 0;

 int bind_export () { return get_value (); }
 void bind_import (int value) { set_value (value); }

 virtual ~SelectorWidget () {}

protected:
 SelectorWidget (widget* in_widget)
  : SDLWidgetWidget (in_widget)
  , m_callback (__null)
  {}

 ControlHitCallback m_callback;
};

class PopupSelectorWidget : public SelectorWidget
{
public:
 PopupSelectorWidget (w_select_popup* select_popup_w)
  : SelectorWidget (select_popup_w)
  , m_select_popup (select_popup_w)
  { select_popup_w->set_popup_callback (boost::bind(&PopupSelectorWidget::massage_callback, this, _1), __null); }

 virtual void set_labels (const std::vector<std::string>& labels) { m_select_popup->set_labels (labels); }

 virtual int get_value () { return m_select_popup->get_selection (); }
 virtual void set_value (int value) { m_select_popup->set_selection (value); }

private:
 w_select_popup* m_select_popup;

 void massage_callback (void* ignored) { if (m_callback) m_callback (); }
};

class SelectSelectorWidget : public SelectorWidget
{
public:
 SelectSelectorWidget (w_select* select_w)
  : SelectorWidget (select_w)
  , m_select (select_w)
  { m_select->set_selection_changed_callback (boost::bind(&SelectSelectorWidget::massage_callback, this, _1)); }


 virtual void set_labels (int stringset) { m_select->set_labels_stringset (stringset); }
 virtual void set_labels (const std::vector<std::string>& labels) {}

 virtual int get_value () { return m_select->get_selection (); }
 virtual void set_value (int value) { m_select->set_selection (value); }

private:
 w_select* m_select;

 void massage_callback (w_select* ignored)
  { if (m_callback) m_callback (); }
};

class ColourSelectorWidget : public SelectSelectorWidget
{
public:
 ColourSelectorWidget (w_player_color* player_color_w)
  : SelectSelectorWidget (player_color_w) {}


 virtual void set_labels (int stringset) {}
 virtual void set_labels (const std::vector<std::string>& labels) {}
};

class SliderSelectorWidget : public SelectorWidget
{
public:
 SliderSelectorWidget (w_slider* slider_w)
  : SelectorWidget (slider_w)
  , m_slider (slider_w)
  {}


 virtual void set_labels (const std::vector<std::string>& labels) {};

 virtual int get_value () { return m_slider->get_selection (); }
 virtual void set_value (int value) { m_slider->set_selection (value); }



private:
 w_slider* m_slider;
};

class ButtonWidget : public SDLWidgetWidget
{
public:
 ButtonWidget (w_button_base* button)
  : SDLWidgetWidget (button)
  , m_button (button)
  , m_callback (__null)
  { m_button->set_callback (bounce_callback, this); }

 void set_callback (ControlHitCallback callback) { m_callback = callback; }

 void push () { if (m_callback) m_callback (); }

private:
 static void bounce_callback(void* arg)
  { reinterpret_cast<ButtonWidget*>(arg)->push (); }

 w_button_base* m_button;
 ControlHitCallback m_callback;
};

class StaticTextWidget : public SDLWidgetWidget
{
public:
 StaticTextWidget (w_static_text* static_text_w)
  : SDLWidgetWidget (static_text_w)
  , m_static_text (static_text_w)
  {}

 void set_text (std::string s) { m_static_text->set_text (s.c_str ()); }

private:
 w_static_text* m_static_text;
};

class EditTextWidget : public SDLWidgetWidget, public Bindable<std::string>
{
public:
 EditTextWidget (w_text_entry* text_entry)
  : SDLWidgetWidget (text_entry)
  , m_text_entry (text_entry)
  { m_text_entry->set_enter_pressed_callback (boost::bind(&EditTextWidget::got_submit, this, _1)); }

 void set_callback (GotCharacterCallback callback) { m_callback = callback; }

 void set_text (string s) { m_text_entry->set_text(s.c_str ()); }
 const string get_text () { return string(m_text_entry->get_text()); }

 std::string bind_export () { return get_text (); }
 void bind_import (std::string s) { set_text (s); }

private:
 w_text_entry* m_text_entry;
 GotCharacterCallback m_callback;


 void got_submit(w_text_entry* ignored) { if (m_callback) m_callback ('\r'); }
};

class EditNumberWidget : public SDLWidgetWidget, public Bindable<int>
{
public:
 EditNumberWidget (w_number_entry* number_entry)
  : SDLWidgetWidget (number_entry)
  , m_number_entry (number_entry)
  {}

 void set_label (const std::string& s) { }

 void set_value (int value) { m_number_entry->set_number (value); }
 int get_value () { return m_number_entry->get_number (); }

 int bind_export () { return get_value (); }
 void bind_import (int value) { set_value (value); }

private:
 w_number_entry* m_number_entry;
};

class FileChooserWidget : public SDLWidgetWidget, public Bindable<FileSpecifier>
{
public:
 FileChooserWidget (w_file_chooser* file_chooser)
  : SDLWidgetWidget (file_chooser)
  , m_file_chooser (file_chooser)
  {}

 void set_callback (ControlHitCallback callback) { m_file_chooser->set_callback (callback); }

 void set_file (const FileSpecifier& file) { m_file_chooser->set_file (file); }
 FileSpecifier get_file () { return m_file_chooser->get_file (); }

 virtual FileSpecifier bind_export () { return get_file (); }
 virtual void bind_import (FileSpecifier f) { set_file (f); }

private:
 w_file_chooser* m_file_chooser;
};


class GameListWidget
{
public:
 GameListWidget (w_games_in_room* games_in_room)
  : m_games_in_room (games_in_room)
  {
   m_games_in_room->set_item_clicked_callback(boost::bind(&GameListWidget::bounce_callback, this, _1));
  }

 void SetItems(const vector<GameListMessage::GameListEntry>& items) { m_games_in_room->set_collection (items); }

 void SetItemSelectedCallback(const boost::function<void (GameListMessage::GameListEntry)> itemSelected)
  { m_callback = itemSelected; }

private:
 w_games_in_room* m_games_in_room;
 boost::function<void (GameListMessage::GameListEntry)> m_callback;

 void bounce_callback (GameListMessage::GameListEntry thingy)
  { m_callback (thingy); }
};

class PlayerListWidget
{
public:
 PlayerListWidget (w_players_in_room* players_in_room)
  : m_players_in_room (players_in_room) {
  m_players_in_room->set_item_clicked_callback(boost::bind(&PlayerListWidget::bounce_callback, this, _1));
 }

 void SetItems(const vector<MetaserverPlayerInfo>& items) { m_players_in_room->set_collection (items); }
 void SetItemSelectedCallback(const boost::function<void (MetaserverPlayerInfo)> itemSelected)
 { m_callback = itemSelected; }



private:
 w_players_in_room* m_players_in_room;
 boost::function<void (MetaserverPlayerInfo)> m_callback;

 void bounce_callback (MetaserverPlayerInfo thingy)
 { m_callback(thingy); }
};

class JoiningPlayerListWidget
{
public:
 JoiningPlayerListWidget (w_joining_players_in_room* joining_players_in_room)
  : m_joining_players_in_room (joining_players_in_room)
  {
   m_joining_players_in_room->set_item_clicked_callback(boost::bind(&JoiningPlayerListWidget::bounce_callback, this, _1));
  }

 void SetItems(const vector<prospective_joiner_info>& items) { m_joining_players_in_room->set_collection (items); }

 void SetItemSelectedCallback(const boost::function<void (prospective_joiner_info)> itemSelected)
  { m_callback = itemSelected; }

private:
 w_joining_players_in_room* m_joining_players_in_room;
 boost::function<void (prospective_joiner_info)> m_callback;

 void bounce_callback (prospective_joiner_info thingy)
  { m_callback (thingy); }
};

class w_players_in_game2;
class PlayersInGameWidget : SDLWidgetWidget
{
public:
 PlayersInGameWidget (w_players_in_game2*);

 void redraw ();

private:
 w_players_in_game2* m_pig;
};


class ColourPickerWidget : public Bindable<RGBColor> {};
# 70 "shell.cpp" 2

# 1 "../Source_Files/RenderOther/TextStrings.h" 1
# 38 "../Source_Files/RenderOther/TextStrings.h"
void TS_PutString(short ID, short Index, unsigned char *String);

void TS_PutCString(short ID, short Index, const char *String);




unsigned char *TS_GetString(short ID, size_t Index);


char *TS_GetCString(short ID, size_t Index);


bool TS_IsPresent(short ID);


size_t TS_CountStrings(short ID);


void TS_DeleteString(short ID, short Index);


void TS_DeleteStringSet(short ID);


void TS_DeleteAllStrings();





class XML_ElementParser;
XML_ElementParser *TS_GetParser();
# 72 "shell.cpp" 2


# 1 "confpaths.h" 1
# 75 "shell.cpp" 2







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/unistd.h" 1 3



# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/unistd.h" 1 3




extern "C" {







# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stddef.h" 1 3 4
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/unistd.h" 2 3

extern char **environ;

void _exit (int __status ) __attribute__ ((noreturn));

int access (const char *__path, int __amode );
unsigned alarm (unsigned __secs );
int chdir (const char *__path );
int chmod (const char *__path, mode_t __mode );

int chown (const char *__path, uid_t __owner, gid_t __group );




int close (int __fildes );



char *ctermid (char *__s );
char *cuserid (char *__s );



int dup (int __fildes );
int dup2 (int __fildes, int __fildes2 );



int execl (const char *__path, const char *, ... );
int execle (const char *__path, const char *, ... );
int execlp (const char *__file, const char *, ... );
int execv (const char *__path, char * const __argv[] );
int execve (const char *__path, char * const __argv[], char * const __envp[] );
int execvp (const char *__file, char * const __argv[] );



int fchmod (int __fildes, mode_t __mode );

int fchown (int __fildes, uid_t __owner, gid_t __group );

pid_t fork (void );
long fpathconf (int __fd, int __name );
int fsync (int __fd);
int fdatasync (int __fd);
char *getcwd (char *__buf, size_t __size );




gid_t getegid (void );
uid_t geteuid (void );
gid_t getgid (void );

int getgroups (int __gidsetsize, gid_t __grouplist[] );



char *getlogin (void );



char *getpass (const char *__prompt);
size_t getpagesize (void);



pid_t getpgid (pid_t);
pid_t getpgrp (void );
pid_t getpid (void );
pid_t getppid (void );




uid_t getuid (void );






int isatty (int __fildes );

int lchown (const char *__path, uid_t __owner, gid_t __group );

int link (const char *__path1, const char *__path2 );
int nice (int __nice_value );

off_t lseek (int __fildes, off_t __offset, int __whence );
# 113 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/unistd.h" 3
long pathconf (const char *__path, int __name );
int pause (void );



int pipe (int __fildes[2] );
ssize_t pread (int __fd, void *__buf, size_t __nbytes, off_t __offset);
ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, off_t __offset);
int read (int __fd, void *__buf, size_t __nbyte );




int rmdir (const char *__path );



void * sbrk (ptrdiff_t __incr);





int setgid (gid_t __gid );




int setpgid (pid_t __pid, pid_t __pgid );
int setpgrp (void );




pid_t setsid (void );

int setuid (uid_t __uid );




unsigned sleep (unsigned int __seconds );
void swab (const void *, void *, ssize_t);
long sysconf (int __name );
pid_t tcgetpgrp (int __fildes );
int tcsetpgrp (int __fildes, pid_t __pgrp_id );
char *ttyname (int __fildes );



int unlink (const char *__path );
int usleep (useconds_t __useconds);
int vhangup (void );
int write (int __fd, const void *__buf, size_t __nbyte );






extern char *optarg;
extern int optind, opterr, optopt;
int getopt(int, char * const [], const char *);
extern int optreset;



pid_t vfork (void );

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);
# 453 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/sys/unistd.h" 3
}
# 5 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/unistd.h" 2 3
# 83 "shell.cpp" 2
# 106 "shell.cpp"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL.h" 1
# 107 "shell.cpp" 2


# 1 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h" 1
# 33 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h"
# 1 "/usr/local/pspdev/psp/include/SDL/SDL_version.h" 1
# 34 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h" 2

# 1 "/usr/local/pspdev/psp/include/SDL/begin_code.h" 1
# 36 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h" 2


extern "C" {
# 170 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h"
struct SDL_SysWMmsg {
 SDL_version version;
 int data;
};


typedef struct SDL_SysWMinfo {
 SDL_version version;
 int data;
} SDL_SysWMinfo;
# 197 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h"
extern int SDL_GetWMInfo(SDL_SysWMinfo *info);




}

# 1 "/usr/local/pspdev/psp/include/SDL/close_code.h" 1
# 205 "/usr/local/pspdev/psp/include/SDL/SDL_syswm.h" 2
# 110 "shell.cpp" 2

# 1 "../Source_Files/Misc/alephversion.h" 1
# 112 "shell.cpp" 2

# 1 "../Source_Files/Misc/Logging.h" 1
# 33 "../Source_Files/Misc/Logging.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stdarg.h" 1 3 4
# 105 "/usr/local/pspdev/lib/gcc/psp/4.3.2/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 34 "../Source_Files/Misc/Logging.h" 2

enum {
 logFatalLevel = 0,
 logErrorLevel = 10,
 logWarningLevel = 20,
 logAnomalyLevel = 30,
 logNoteLevel = 40,
 logSummaryLevel = 45,
 logTraceLevel = 50,
 logDumpLevel = 60
};


class Logger {
public:
 virtual void pushLogContext(const char* inFile, int inLine, const char* inContext, ...);
 virtual void logMessage(const char* inDomain, int inLevel, const char* inFile, int inLine, const char* inMessage, ...);
 virtual void logMessageNMT(const char* inDomain, int inLevel, const char* inFile, int inLine, const char* inMessage, ...);

 virtual void pushLogContextV(const char* inFile, int inLine, const char* inContext, va_list inArgList) = 0;
 virtual void popLogContext() = 0;
 virtual void logMessageV(const char* inDomain, int inLevel, const char* inFile, int inLine, const char* inMessage, va_list inArgList) = 0;

 virtual ~Logger();
};



Logger* GetCurrentLogger();


class XML_ElementParser;
XML_ElementParser* Logging_GetParser();
void setLoggingThreshhold(const char* inDomain, short inThreshhold);
void setShowLoggingLocations(const char* inDomain, bool inShowLocations);
void setFlushLoggingOutput(const char* inDomain, bool inFlushOutput);




extern const char* logDomain;
# 98 "../Source_Files/Misc/Logging.h"
# 1 "../Source_Files/Misc/Logging_gruntwork.h" 1
# 99 "../Source_Files/Misc/Logging.h" 2
# 118 "../Source_Files/Misc/Logging.h"
class LogContext {
public:
 LogContext(bool inNonMainThread) : contextSet(false), nonMainThread(inNonMainThread) {}

 LogContext(const char* inFile, int inLine, const char* inContext, ...) : contextSet(false), nonMainThread(false) {
  va_list theVarArgs;
  __builtin_va_start(theVarArgs,inContext);
  enterContextV(inFile, inLine, inContext, theVarArgs);
  __builtin_va_end(theVarArgs);
 }

 LogContext(bool inNonMainThread, const char* inFile, int inLine, const char* inContext, ...) : contextSet(false), nonMainThread(inNonMainThread) {
  va_list theVarArgs;
  __builtin_va_start(theVarArgs,inContext);
  enterContextV(inFile, inLine, inContext, theVarArgs);
  __builtin_va_end(theVarArgs);
 }

 void enterContext(const char* inFile, int inLine, const char* inContext, ...) {
  va_list theVarArgs;
  __builtin_va_start(theVarArgs,inContext);
  enterContextV(inFile, inLine, inContext, theVarArgs);
  __builtin_va_end(theVarArgs);
 }

 void enterContextV(const char* inFile, int inLine, const char* inContext, va_list inArgs) {
  if(contextSet)
   leaveContext();




   GetCurrentLogger()->pushLogContextV(inFile, inLine, inContext, inArgs);

  contextSet = true;
 }

 void leaveContext() {



   if(contextSet)
    GetCurrentLogger()->popLogContext();

  contextSet = false;
 }

 ~LogContext() {
  leaveContext();
 }

protected:
 bool contextSet;
 bool nonMainThread;
};
# 114 "shell.cpp" 2

# 1 "../Source_Files/Misc/Console.h" 1
# 27 "../Source_Files/Misc/Console.h"
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/map" 1 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/map" 3
       
# 64 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/map" 3


# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 1 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 89 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 175 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 199 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 215 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 238 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 264 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 383 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 410 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 432 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 467 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 494 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 506 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 521 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 536 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 551 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 566 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      void



      swap(map& __x)

      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 613 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 628 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 640 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 655 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 670 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 709 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 728 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 753 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 770 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 825 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_map.h" 3
}
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/map" 2 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 1 3
# 67 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 173 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 197 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 213 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 236 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 262 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 379 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 406 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 430 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 442 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 457 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 472 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 487 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 502 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      void



      swap(multimap& __x)

      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 549 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 564 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 588 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 603 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 640 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 657 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 682 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 699 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 754 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/bits/stl_multimap.h" 3
}
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/c++/4.3.2/map" 2 3
# 28 "../Source_Files/Misc/Console.h" 2
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 1 3
# 62 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 48 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 53 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 58 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 68 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 73 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 78 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 83 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 88 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 93 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function/detail/function_iterate.hpp" 2 3
# 98 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 63 "/usr/local/pspdev/lib/gcc/psp/4.3.2/../../../../psp/include/boost/function.hpp" 2 3
# 29 "../Source_Files/Misc/Console.h" 2

# 1 "../Source_Files/Misc/preferences.h" 1
# 31 "../Source_Files/Misc/Console.h" 2

class CommandParser
{
public:
 CommandParser() { }
 ~CommandParser() { }
 void register_command(std::string command, boost::function<void(const std::string&)> f);
 void register_command(std::string command, const CommandParser& command_parser);
 void unregister_command(std::string command);

 virtual void parse_and_execute(const std::string& command_string);
private:
 typedef std::map<std::string, boost::function<void(const std::string&)> > command_map;
 command_map m_commands;
};

class Console : public CommandParser
{
public:
 static Console* instance();


 void enter();
 void abort();
 void backspace();
 void clear();
 void key(const char);
 const std::string &displayBuffer() { return m_displayBuffer; }

 void activate_input(boost::function<void (const std::string&)> callback,
       const std::string& prompt);
 void deactivate_input();

 bool input_active() { return m_active; }

 void register_macro(std::string macro, std::string replacement);
 void unregister_macro(std::string macro);


 void set_carnage_message(int16 projectile_type, const std::string& on_kill, const std::string& on_suicide = "");
 void report_kill(int16 player_index, int16 aggressor_player_index, int16 projectile_index);

 bool use_lua_console() { return m_use_lua_console || environment_preferences->use_solo_lua; };
 void use_lua_console(bool f_use) { m_use_lua_console = f_use; }


 void clear_saves();

private:
 Console();
 static Console* m_instance;

 boost::function<void (std::string)> m_callback;
 std::string m_buffer;
 std::string m_displayBuffer;
 std::string m_prompt;
 bool m_active;

 std::map<std::string, std::string> m_macros;

 bool m_carnage_messages_exist;
 std::vector<std::pair<std::string, std::string> > m_carnage_messages;

 bool m_use_lua_console;

 void register_save_commands();
};

XML_ElementParser *Console_GetParser();
# 116 "shell.cpp" 2



extern bool CheatsActive;


vector <FileSpecifier> data_search_path;
FileSpecifier local_data_dir;
FileSpecifier preferences_dir;
FileSpecifier saved_games_dir;
FileSpecifier recordings_dir;
std::string arg_directory;


bool option_nogl = false;
bool option_nosound = false;
bool option_nogamma = false;
bool option_debug = false;
static bool force_fullscreen = false;
static bool force_windowed = false;


static void main_event_loop(void);
extern int process_keyword_key(char key);
extern void handle_keyword(int type_of_cheat);

void PlayInterfaceButtonSound(short SoundID);
# 151 "shell.cpp"
extern bool get_default_music_spec(FileSpecifier &file);


void execute_timer_tasks(uint32 time);


static void initialize_application(void);
static void shutdown_application(void);
static void initialize_marathon_music_handler(void);
static void process_event(const SDL_Event &event);


short vidmasterStringSetID = -1;

static void usage(const char *prg_name)
{



 printf("\nUsage: %s\n"

   "\t[-h | --help]          Display this help message\n"
   "\t[-v | --version]       Display the game version\n"
   "\t[-d | --debug]         Allow saving of core files\n"
   "\t                       (by disabling SDL parachute)\n"
   "\t[-f | --fullscreen]    Run the game fullscreen\n"
   "\t[-w | --windowed]      Run the game in a window\n"



   "\t[-s | --nosound]       Do not access the sound card\n"
   "\t[-m | --nogamma]       Disable gamma table effects (menu fades)\n"







   , prg_name

 );
 exit(0);
}



int SDL_main(int argc, char *argv[])



{

 printf ("Aleph One " "Aleph One " "Unknown" " " "2008-07-21" " " "0.20.2" "\n"
   "http://marathon.sourceforge.net/\n\n"
   "Original code by Bungie Software <http://www.bungie.com/>\n"
   "Additional work by Loren Petrich, Chris Pruett, Rhys Hill et al.\n"
   "TCP/IP networking by Woody Zenfell\n"
   "Expat XML library by James Clark\n"
   "SDL port by Christian Bauer <Christian.Bauer@uni-mainz.de>\n"



   "\nThis is free software with ABSOLUTELY NO WARRANTY.\n"
   "You are welcome to redistribute it under certain conditions.\n"
   "For details, see the file COPYING.\n"







   "\nBuilt with network play enabled.\n"


   "\nBuilt with Lua scripting enabled.\n"

    );


 char *prg_name = argv[0];
 argc--;
 argv++;
 while (argc > 0) {
  if (strcmp(*argv, "-h") == 0 || strcmp(*argv, "--help") == 0) {
   usage(prg_name);
  } else if (strcmp(*argv, "-v") == 0 || strcmp(*argv, "--version") == 0) {
   printf("Aleph One " "Aleph One " "Unknown" " " "2008-07-21" " " "0.20.2" "\n");
   exit(0);
  } else if (strcmp(*argv, "-f") == 0 || strcmp(*argv, "--fullscreen") == 0) {
   force_fullscreen = true;
  } else if (strcmp(*argv, "-w") == 0 || strcmp(*argv, "--windowed") == 0) {
   force_windowed = true;
  } else if (strcmp(*argv, "-g") == 0 || strcmp(*argv, "--nogl") == 0) {
   option_nogl = true;
  } else if (strcmp(*argv, "-s") == 0 || strcmp(*argv, "--nosound") == 0) {
   option_nosound = true;
  } else if (strcmp(*argv, "-m") == 0 || strcmp(*argv, "--nogamma") == 0) {
   option_nogamma = true;
  } else if (strcmp(*argv, "-d") == 0 || strcmp(*argv, "--debug") == 0) {
    option_debug = true;
  } else if (arg_directory == "") {

   FileSpecifier f(*argv);
   if (f.IsDir())
   {
    arg_directory = *argv;
   }

   else
    printf("%s is not a directory\n", *argv);
  } else {
   printf("Unrecognized argument '%s'.\n", *argv);
   usage(prg_name);
  }
  argc--;
  argv++;
 }

 try {


  initialize_application();


  main_event_loop();

 } catch (exception &e) {
  fprintf((_impure_ptr->_stderr), "Unhandled exception: %s\n", e.what());
  exit(1);
 } catch (...) {
  fprintf ((_impure_ptr->_stderr), "Unknown exception\n");
  exit(1);
 }

 return 0;
}

static void initialize_application(void)
{





 FileSpecifier default_data_dir;
# 347 "shell.cpp"
 default_data_dir = "";
 local_data_dir = "";
# 359 "shell.cpp"
 if (arg_directory != "")
  default_data_dir = arg_directory;


 const char *data_env = getenv("ALEPHONE_DATA");
 if (data_env) {

  string path = data_env;
  string::size_type pos;
  while ((pos = path.find(':')) != string::npos) {
   if (pos) {
    string element = path.substr(0, pos);
    data_search_path.push_back(element);
   }
   path.erase(0, pos + 1);
  }
  if (!path.empty())
   data_search_path.push_back(path);
 } else {
# 389 "shell.cpp"
  data_search_path.push_back(default_data_dir);

  data_search_path.push_back(local_data_dir);
 }


 preferences_dir = local_data_dir;
 saved_games_dir = local_data_dir + "Saved Games";
 recordings_dir = local_data_dir + "Recordings";


 local_data_dir.CreateDirectory();
 saved_games_dir.CreateDirectory();
 recordings_dir.CreateDirectory();



 FileSpecifier local_mml_dir = local_data_dir + "MML";

 local_mml_dir.CreateDirectory();



 FileSpecifier local_themes_dir = local_data_dir + "Themes";

 local_themes_dir.CreateDirectory();

 initialize_resources();

 init_physics_wad_data();

 initialize_fonts();


 SetupParseTree();
 LoadBaseMMLScripts();


 if (!TS_IsPresent(128) || !TS_IsPresent(129)) {
  fprintf((_impure_ptr->_stderr), "Can't find required text strings (missing MML?).\n");
  exit(1);
 }


 initialize_preferences();

 graphics_preferences->screen_mode.acceleration = _no_acceleration;

 if (force_fullscreen)
  graphics_preferences->screen_mode.fullscreen = true;
 if (force_windowed)
  graphics_preferences->screen_mode.fullscreen = false;
 write_preferences();
# 464 "shell.cpp"
 if (SDL_Init(0x00000020 |
       (option_nosound ? 0 : 0x00000010) |
       (option_debug ? 0x00100000 : 0)
       ) < 0) {
  fprintf((_impure_ptr->_stderr), "Couldn't initialize SDL (%s)\n", SDL_GetError());
  exit(1);
 }
 SDL_WM_SetCaption("Aleph One", "Aleph One");
 atexit(shutdown_application);



 if (SDLNet_Init () < 0) {
  fprintf ((_impure_ptr->_stderr), "Couldn't initialize SDL_net (%s)\n", SDL_GetError());
  exit(1);
 }
# 491 "shell.cpp"
 if (TTF_Init() < 0) {
  fprintf ((_impure_ptr->_stderr), "Couldn't initialize SDL_ttf (%s)\n", SDL_GetError());
  exit(1);
 }





 mytm_initialize();

 SoundManager::instance()->Initialize(*sound_preferences);
 initialize_marathon_music_handler();
 initialize_keyboard_controller();
 initialize_screen(&graphics_preferences->screen_mode, false);
 initialize_marathon();
 initialize_screen_drawing();
 FileSpecifier theme = environment_preferences->theme_dir;
 initialize_dialogs(theme);
 initialize_terminal_manager();
 initialize_shape_handler();
 initialize_fades();
 initialize_images_manager();
 load_environment_from_preferences();
 initialize_game_state();
}

static void shutdown_application(void)
{

        static bool already_shutting_down = false;
        if(already_shutting_down)
                return;

        already_shutting_down = true;


 SDLNet_Quit();





 TTF_Quit();

 SDL_Quit();
}

bool networking_available(void)
{

 return true;



}

static void initialize_marathon_music_handler(void)
{
 FileSpecifier file;
 if (get_default_music_spec(file))
  Music::instance()->SetupIntroMusic(file);
}

bool quit_without_saving(void)
{
 dialog d;
 vertical_placer *placer = new vertical_placer;
 placer->dual_add (new w_static_text("Are you sure you wish to"), d);
 placer->dual_add (new w_static_text("cancel the game in progress?"), d);
 placer->add (new w_spacer(), true);

 horizontal_placer *button_placer = new horizontal_placer;
 w_button *default_button = new w_button("YES", dialog_ok, &d);
 button_placer->dual_add (default_button, d);
 button_placer->dual_add (new w_button("NO", dialog_cancel, &d), d);
 d.activate_widget(default_button);
 placer->add(button_placer, true);
 d.set_widget_placer(placer);
 return d.run() == 0;
}



const int32 AllPlayableLevels = _single_player_entry_point | _multiplayer_carnage_entry_point | _multiplayer_cooperative_entry_point | _kill_the_man_with_the_ball_entry_point | _king_of_hill_entry_point | _rugby_entry_point | _capture_the_flag_entry_point;

short get_level_number_from_user(void)
{

 vector<entry_point> levels;
 if (!get_entry_points(levels, AllPlayableLevels)) {
  entry_point dummy;
  dummy.level_number = 0;
  strcpy(dummy.level_name, "Untitled Level");
  levels.push_back(dummy);
 }


 dialog d;
 vertical_placer *placer = new vertical_placer;
 if (vidmasterStringSetID != -1 && TS_IsPresent(vidmasterStringSetID) && TS_CountStrings(vidmasterStringSetID) > 0) {

  int num_lines = TS_CountStrings(vidmasterStringSetID);

  for (size_t i = 0; i < num_lines; i++) {
   bool message_font_title_color = true;
   char *string = TS_GetCString(vidmasterStringSetID, i);
   if (!strncmp(string, "[QUOTE]", 7)) {
    string = string + 7;
    message_font_title_color = false;
   }
   if (!strlen(string))
    placer->add(new w_spacer(), true);
   else if (message_font_title_color)
    placer->dual_add(new w_static_text(string), d);
   else
    placer->dual_add(new w_static_text(string), d);
  }

 } else {

  placer->dual_add(new w_static_text("Before proceeding any further, you"), d);
  placer->dual_add(new w_static_text ("must take the oath of the vidmaster:"), d);
  placer->add(new w_spacer(), true);
  placer->dual_add(new w_static_text("\xd2I pledge to punch all switches,"), d);
  placer->dual_add(new w_static_text("to never shoot where I could use grenades,"), d);
  placer->dual_add(new w_static_text("to admit the existence of no level"), d);
  placer->dual_add(new w_static_text("except Total Carnage,"), d);
  placer->dual_add(new w_static_text("to never use Caps Lock as my \xd4run\xd5 key,"), d);
  placer->dual_add(new w_static_text("and to never, ever, leave a single Bob alive.\xd3"), d);
 }

 placer->add(new w_spacer(), true);
 placer->dual_add(new w_static_text("Start at level:"), d);

 w_levels *level_w = new w_levels(levels, &d);
 placer->dual_add(level_w, d);
 placer->add(new w_spacer(), true);
 placer->dual_add(new w_button("CANCEL", dialog_cancel, &d), d);

 d.activate_widget(level_w);
 d.set_widget_placer(placer);


 short level;
 if (d.run() == 0)

  level = levels[level_w->get_selection()].level_number;
 else
  level = NONE;


 update_game_window();
 return level;
}

const uint32 TICKS_BETWEEN_EVENT_POLL = 167;
static void main_event_loop(void)
{
 uint32 last_event_poll = 0;
 short game_state;

 while ((game_state = get_game_state()) != _quit_game) {
  uint32 cur_time = SDL_GetTicks();
  bool yield_time = false;
  bool poll_event = false;

  switch (game_state) {
   case _game_in_progress:
   case _change_level:
     if (Console::instance()->input_active() || cur_time - last_event_poll >= TICKS_BETWEEN_EVENT_POLL) {
     poll_event = true;
     last_event_poll = cur_time;
     } else {
     SDL_PumpEvents ();
     }
    break;

   case _display_intro_screens:
   case _display_main_menu:
   case _display_chapter_heading:
   case _display_prologue:
   case _display_epilogue:
   case _begin_display_of_epilogue:
   case _display_credits:
   case _display_intro_screens_for_demo:
   case _display_quit_screens:
   case _displaying_network_game_dialogs:
    yield_time = interface_fade_finished();
    poll_event = true;
    break;

   case _close_game:
   case _switch_demo:
   case _revert_game:
    yield_time = poll_event = true;
    break;
  }

  if (poll_event) {
   global_idle_proc();

   while (true) {
    SDL_Event event;
    event.type = SDL_NOEVENT;
    SDL_PollEvent(&event);

    if (yield_time) {



     int num_tries = 0;
     while (event.type == SDL_NOEVENT && num_tries < 3) {
      SDL_Delay(10);
      SDL_PollEvent(&event);
      num_tries++;
     }
     yield_time = false;
    } else if (event.type == SDL_NOEVENT)
     break;

    process_event(event);
   }
  }

  execute_timer_tasks(SDL_GetTicks());
  idle_game_state(SDL_GetTicks());


  if (game_state == _game_in_progress && !graphics_preferences->hog_the_cpu && (30 - (SDL_GetTicks() - cur_time)) > 10)
  {
   SDL_Delay(1);
  }

 }
}

static bool has_cheat_modifiers(void)
{
 SDLMod m = SDL_GetModState();



 return (m & (KMOD_LSHIFT|KMOD_RSHIFT)) && (m & (KMOD_LCTRL|KMOD_RCTRL)) && !(m & (KMOD_LALT|KMOD_RALT)) && !(m & (KMOD_LMETA|KMOD_RMETA));

}

static void process_screen_click(const SDL_Event &event)
{
 portable_process_screen_click(event.button.x, event.button.y, has_cheat_modifiers());
}

static void handle_game_key(const SDL_Event &event)
{
 SDLKey key = event.key.keysym.sym;
 bool changed_screen_mode = false;
 bool changed_prefs = false;

 if (!game_is_networked && (event.key.keysym.mod & (KMOD_LCTRL|KMOD_RCTRL)) && CheatsActive) {
  int type_of_cheat = process_keyword_key(key);
  if (type_of_cheat != NONE)
   handle_keyword(type_of_cheat);
 }
 if (Console::instance()->input_active()) {
  switch(key) {
  case SDLK_RETURN:
   Console::instance()->enter();
   break;
  case SDLK_ESCAPE:
   Console::instance()->abort();
   break;
  case SDLK_BACKSPACE:
  case SDLK_DELETE:
   Console::instance()->backspace();
   break;
  default:
   if (event.key.keysym.unicode == 8)
   {
    Console::instance()->backspace();
   }
   else if (event.key.keysym.unicode == 21)
   {
    Console::instance()->clear();
   }
   else if (event.key.keysym.unicode >= ' ') {
    Console::instance()->key(unicode_to_mac_roman(event.key.keysym.unicode));
   }
  }
 }
 else
 {
  if (key == SDLK_ESCAPE)
  {
   if(!player_controlling_game())
    do_menu_item_command(mGame, iQuitGame, false);
   else {
    if(get_ticks_since_local_player_in_terminal() > 1 * 30) {
     if(!game_is_networked) {
      do_menu_item_command(mGame, iQuitGame, false);
     }
     else {



      screen_printf("If you wish to quit, press Alt+Q.");

     }
    }
   }
  }
  else if (key == input_preferences->shell_keycodes[_key_volume_up])
  {
   changed_prefs = SoundManager::instance()->AdjustVolumeUp(_snd_adjust_volume);
  }
  else if (key == input_preferences->shell_keycodes[_key_volume_down])
  {
   changed_prefs = SoundManager::instance()->AdjustVolumeDown(_snd_adjust_volume);
  }
  else if (key == input_preferences->shell_keycodes[_key_switch_view])
  {
   walk_player_list();
   render_screen(NONE);
  }
  else if (key == input_preferences->shell_keycodes[_key_zoom_in])
  {
   if (zoom_overhead_map_in())
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
   else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else if (key == input_preferences->shell_keycodes[_key_zoom_out])
  {
   if (zoom_overhead_map_out())
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
   else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else if (key == input_preferences->shell_keycodes[_key_inventory_left])
  {
   if (player_controlling_game()) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    scroll_inventory(-1);
   } else
    decrement_replay_speed();
  }
  else if (key == input_preferences->shell_keycodes[_key_inventory_right])
  {
   if (player_controlling_game()) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    scroll_inventory(1);
   } else
    increment_replay_speed();
  }
  else if (key == input_preferences->shell_keycodes[_key_toggle_fps])
  {
   PlayInterfaceButtonSound(Sound_ButtonSuccess());
   extern bool displaying_fps;
   displaying_fps = !displaying_fps;
  }
  else if (key == input_preferences->shell_keycodes[_key_activate_console])
  {
   if (game_is_networked) {

    Console::instance()->activate_input(InGameChatCallbacks::SendChatMessage, InGameChatCallbacks::prompt());

    PlayInterfaceButtonSound(Sound_ButtonSuccess());
   }
   else if (Console::instance()->use_lua_console())
   {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    Console::instance()->activate_input(ExecuteLuaString, ">");
   }
   else
   {
    PlayInterfaceButtonSound(Sound_ButtonFailure());
   }
  }
  else if (key == SDLK_F1)
  {
   if (graphics_preferences->screen_mode.size > 0) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    graphics_preferences->screen_mode.size--;
    changed_screen_mode = changed_prefs = true;
   } else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else if (key == SDLK_F2)
  {
   if (graphics_preferences->screen_mode.size < NUMBER_OF_VIEW_SIZES - 1) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    graphics_preferences->screen_mode.size++;
    changed_screen_mode = changed_prefs = true;
   } else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else if (key == SDLK_F3)
  {
   if (!OGL_IsActive()) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    graphics_preferences->screen_mode.high_resolution = !graphics_preferences->screen_mode.high_resolution;
    changed_screen_mode = changed_prefs = true;
   } else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else if (key == SDLK_F4)
  {







    PlayInterfaceButtonSound(Sound_ButtonInoperative());
  }
  else if (key == SDLK_F5)
  {
   if (ChaseCam_IsActive())
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
   else
    PlayInterfaceButtonSound(Sound_ButtonInoperative());
   ChaseCam_SwitchSides();
  }
  else if (key == SDLK_F6)
  {
   PlayInterfaceButtonSound(Sound_ButtonSuccess());
   ChaseCam_SetActive(!ChaseCam_IsActive());
  }
  else if (key == SDLK_F7)
  {
   PlayInterfaceButtonSound(Sound_ButtonSuccess());
   SetTunnelVision(!GetTunnelVision());
  }
  else if (key == SDLK_F8)
  {
   PlayInterfaceButtonSound(Sound_ButtonSuccess());
   Crosshairs_SetActive(!Crosshairs_IsActive());
  }
  else if (key == SDLK_F9)
  {
   dump_screen();
  }
  else if (key == SDLK_F10)
  {
   PlayInterfaceButtonSound(Sound_ButtonSuccess());
   {
    extern bool ShowPosition;
    ShowPosition = !ShowPosition;
   }
  }
  else if (key == SDLK_F11)
  {
   if (graphics_preferences->screen_mode.gamma_level) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    graphics_preferences->screen_mode.gamma_level--;
    change_gamma_level(graphics_preferences->screen_mode.gamma_level);
    changed_prefs = true;
   } else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else if (key == SDLK_F12)
  {
   if (graphics_preferences->screen_mode.gamma_level < NUMBER_OF_GAMMA_LEVELS - 1) {
    PlayInterfaceButtonSound(Sound_ButtonSuccess());
    graphics_preferences->screen_mode.gamma_level++;
    change_gamma_level(graphics_preferences->screen_mode.gamma_level);
    changed_prefs = true;
   } else
    PlayInterfaceButtonSound(Sound_ButtonFailure());
  }
  else
  {
   if (get_game_controller() == _demo)
    set_game_state(_close_game);
  }
 }

 if (changed_screen_mode) {
  screen_mode_data temp_screen_mode = graphics_preferences->screen_mode;
  temp_screen_mode.fullscreen = get_screen_mode()->fullscreen;
  change_screen_mode(&temp_screen_mode, true);
  render_screen(0);
 }

 if (changed_prefs)
  write_preferences();
}

static void process_game_key(const SDL_Event &event)
{
 switch (get_game_state()) {
 case _game_in_progress:



  if ((event.key.keysym.mod & (KMOD_LALT|KMOD_RALT)) || (event.key.keysym.mod & (KMOD_LMETA|KMOD_RMETA)))

  {
   int item = -1;
   switch (event.key.keysym.sym) {
   case SDLK_p:
    item = iPause;
    break;
   case SDLK_s:
    item = iSave;
    break;
   case SDLK_r:
    item = iRevert;
    break;




   case SDLK_q:
    item = iQuitGame;
    break;
   case SDLK_RETURN:
    item = 0;
    toggle_fullscreen();
    break;
   default:
    break;
   }
   if (item > 0)
    do_menu_item_command(mGame, item, has_cheat_modifiers());
   else if (item != 0)
    handle_game_key(event);
  } else
   handle_game_key(event);
  break;
 case _display_intro_screens:
 case _display_chapter_heading:
 case _display_prologue:
 case _display_epilogue:
 case _display_credits:
 case _display_quit_screens:
  if (interface_fade_finished())
   force_game_state_change();
  else
   stop_interface_fade();
  break;

 case _display_intro_screens_for_demo:
  stop_interface_fade();
  display_main_menu();
  break;

 case _quit_game:
 case _close_game:
 case _revert_game:
 case _switch_demo:
 case _change_level:
 case _begin_display_of_epilogue:
 case _displaying_network_game_dialogs:
  break;

 case _display_main_menu:
 {
  if (!interface_fade_finished())
   stop_interface_fade();
  int item = -1;
  switch (event.key.keysym.sym) {
  case SDLK_n:
   item = iNewGame;
   break;
  case SDLK_o:
   item = iLoadGame;
   break;
  case SDLK_g:
   item = iGatherGame;
   break;
  case SDLK_j:
   item = iJoinGame;
   break;
  case SDLK_p:
   item = iPreferences;
   break;
  case SDLK_r:
   item = iReplaySavedFilm;
   break;
  case SDLK_c:
   item = iCredits;
   break;




  case SDLK_q:
   item = iQuit;
   break;
  case SDLK_F9:
   dump_screen();
   break;
  case SDLK_RETURN:



   if ((event.key.keysym.mod & (KMOD_LMETA|KMOD_RMETA)) || (event.key.keysym.mod & (KMOD_LALT|KMOD_RALT)))

   {
    toggle_fullscreen();
   }
   break;
  default:
   break;
  }
  if (item > 0) {
   draw_menu_button_for_command(item);
   do_menu_item_command(mInterface, item, has_cheat_modifiers());
  }
  break;
 }
 }
}

static void process_system_event(const SDL_Event &event)
{
# 1120 "shell.cpp"
}

static void process_event(const SDL_Event &event)
{
 switch (event.type) {
 case SDL_MOUSEBUTTONDOWN:
  if (get_game_state() == _game_in_progress)
  {
   if (event.button.button == 4 || event.button.button == 5)
   {
    mouse_scroll(event.button.button == 4);
   }
   else if (!get_keyboard_controller_status())
   {
    hide_cursor();
    set_keyboard_controller_status(true);
   }
  }
  else
   process_screen_click(event);
  break;

 case SDL_KEYDOWN:
  process_game_key(event);
  break;

 case SDL_SYSWMEVENT:
  process_system_event(event);
  break;

 case SDL_QUIT:
  set_game_state(_quit_game);
  break;

 case SDL_ACTIVEEVENT:
  if (event.active.state & 0x02) {
   if (!event.active.gain && !(SDL_GetAppState() & 0x02)) {
    if (get_game_state() == _game_in_progress && get_keyboard_controller_status()) {
     darken_world_window();
     set_keyboard_controller_status(false);
     show_cursor();
    }
   }
  }
  break;
 case SDL_VIDEOEXPOSE:






   update_game_window();

  break;
 }

}

void dump_screen(void)
{

 FileSpecifier file;
 int i = 0;
 do {
  char name[256];
  sprintf(name, "Screenshot_%04d.bmp", i);
  file = local_data_dir + name;
  i++;
 } while (file.Exists());


 SDL_Surface *video = SDL_GetVideoSurface();
 if (!(video->flags & 0x00000002)) {
  SDL_SaveBMP_RW(SDL_GetVideoSurface(), SDL_RWFromFile(file.GetPath(), "wb"), 1);
  return;
 }
# 1228 "shell.cpp"
}

void LoadBaseMMLScripts()
{
 XML_Loader_SDL loader;
 loader.CurrentElement = &RootParser;
 {
  vector <FileSpecifier>::const_iterator i = data_search_path.begin(), end = data_search_path.end();
  while (i != end) {
   FileSpecifier path = *i + "MML";
   loader.ParseDirectory(path);
   path = *i + "Scripts";
   loader.ParseDirectory(path);
   i++;
  }
 }
}



void PlayInterfaceButtonSound(short SoundID)
{
 if (((input_preferences->modifiers)&(_inputmod_use_button_sounds)))
  SoundManager::instance()->PlaySound(SoundID, (world_location3d *) __null, NONE);
}
